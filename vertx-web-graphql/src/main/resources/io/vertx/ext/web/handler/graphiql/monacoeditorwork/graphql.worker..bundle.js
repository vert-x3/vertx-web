(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a, b2) => (typeof require !== "undefined" ? require : a)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/nullthrows/nullthrows.js
  var require_nullthrows = __commonJS({
    "node_modules/nullthrows/nullthrows.js"(exports, module) {
      "use strict";
      function nullthrows2(x2, message) {
        if (x2 != null) {
          return x2;
        }
        var error = new Error(message !== void 0 ? message : "Got unexpected " + x2);
        error.framesToPop = 1;
        throw error;
      }
      module.exports = nullthrows2;
      module.exports.default = nullthrows2;
      Object.defineProperty(module.exports, "__esModule", { value: true });
    }
  });

  // node_modules/picomatch-browser/lib/constants.js
  var require_constants = __commonJS({
    "node_modules/picomatch-browser/lib/constants.js"(exports, module) {
      "use strict";
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var SEP = "/";
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR,
        SEP
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
        SEP: "\\"
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        // regular expressions
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        // Replace globs with equivalent patterns to reduce parsing time.
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        // Digits
        CHAR_0: 48,
        /* 0 */
        CHAR_9: 57,
        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: 65,
        /* A */
        CHAR_LOWERCASE_A: 97,
        /* a */
        CHAR_UPPERCASE_Z: 90,
        /* Z */
        CHAR_LOWERCASE_Z: 122,
        /* z */
        CHAR_LEFT_PARENTHESES: 40,
        /* ( */
        CHAR_RIGHT_PARENTHESES: 41,
        /* ) */
        CHAR_ASTERISK: 42,
        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: 38,
        /* & */
        CHAR_AT: 64,
        /* @ */
        CHAR_BACKWARD_SLASH: 92,
        /* \ */
        CHAR_CARRIAGE_RETURN: 13,
        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: 94,
        /* ^ */
        CHAR_COLON: 58,
        /* : */
        CHAR_COMMA: 44,
        /* , */
        CHAR_DOT: 46,
        /* . */
        CHAR_DOUBLE_QUOTE: 34,
        /* " */
        CHAR_EQUAL: 61,
        /* = */
        CHAR_EXCLAMATION_MARK: 33,
        /* ! */
        CHAR_FORM_FEED: 12,
        /* \f */
        CHAR_FORWARD_SLASH: 47,
        /* / */
        CHAR_GRAVE_ACCENT: 96,
        /* ` */
        CHAR_HASH: 35,
        /* # */
        CHAR_HYPHEN_MINUS: 45,
        /* - */
        CHAR_LEFT_ANGLE_BRACKET: 60,
        /* < */
        CHAR_LEFT_CURLY_BRACE: 123,
        /* { */
        CHAR_LEFT_SQUARE_BRACKET: 91,
        /* [ */
        CHAR_LINE_FEED: 10,
        /* \n */
        CHAR_NO_BREAK_SPACE: 160,
        /* \u00A0 */
        CHAR_PERCENT: 37,
        /* % */
        CHAR_PLUS: 43,
        /* + */
        CHAR_QUESTION_MARK: 63,
        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        /* > */
        CHAR_RIGHT_CURLY_BRACE: 125,
        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        /* ] */
        CHAR_SEMICOLON: 59,
        /* ; */
        CHAR_SINGLE_QUOTE: 39,
        /* ' */
        CHAR_SPACE: 32,
        /*   */
        CHAR_TAB: 9,
        /* \t */
        CHAR_UNDERSCORE: 95,
        /* _ */
        CHAR_VERTICAL_LINE: 124,
        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        /* \uFEFF */
        /**
         * Create EXTGLOB_CHARS
         */
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        /**
         * Create GLOB_CHARS
         */
        globChars(win322) {
          return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    }
  });

  // node_modules/picomatch-browser/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/picomatch-browser/lib/utils.js"(exports) {
      "use strict";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants();
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1) return input;
        if (input[idx - 1] === "\\") return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? "" : "^";
        const append = options.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
      exports.basename = (path, { windows } = {}) => {
        if (windows) {
          return path.replace(/[\\/]$/, "").replace(/.*[\\/]/, "");
        } else {
          return path.replace(/\/$/, "").replace(/.*\//, "");
        }
      };
    }
  });

  // node_modules/picomatch-browser/lib/scan.js
  var require_scan = __commonJS({
    "node_modules/picomatch-browser/lib/scan.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var {
        CHAR_ASTERISK,
        /* * */
        CHAR_AT,
        /* @ */
        CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH2,
        /* \ */
        CHAR_COMMA,
        /* , */
        CHAR_DOT: CHAR_DOT2,
        /* . */
        CHAR_EXCLAMATION_MARK,
        /* ! */
        CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH2,
        /* / */
        CHAR_LEFT_CURLY_BRACE,
        /* { */
        CHAR_LEFT_PARENTHESES,
        /* ( */
        CHAR_LEFT_SQUARE_BRACKET,
        /* [ */
        CHAR_PLUS,
        /* + */
        CHAR_QUESTION_MARK: CHAR_QUESTION_MARK2,
        /* ? */
        CHAR_RIGHT_CURLY_BRACE,
        /* } */
        CHAR_RIGHT_PARENTHESES,
        /* ) */
        CHAR_RIGHT_SQUARE_BRACKET
        /* ] */
      } = require_constants();
      var isPathSeparator2 = (code) => {
        return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
      };
      var depth = (token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      };
      var scan = (input, options) => {
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = () => index >= length;
        const peek = () => str.charCodeAt(index + 1);
        const advance = () => {
          prev = code;
          return str.charCodeAt(++index);
        };
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH2) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT2 && (code = advance()) === CHAR_DOT2) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH2) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true) continue;
            if (prev === CHAR_DOT2 && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK2 || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH2) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK2) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
            }
          }
          if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base = str;
        let prefix = "";
        let glob = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex);
          glob = str.slice(lastIndex);
        } else if (isGlob === true) {
          base = "";
          glob = str;
        } else {
          base = str;
        }
        if (base && base !== "" && base !== "/" && base !== str) {
          if (isPathSeparator2(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
          }
        }
        if (opts.unescape === true) {
          if (glob) glob = utils.removeBackslashes(glob);
          if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base,
          glob,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated
        };
        if (opts.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator2(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      };
      module.exports = scan;
    }
  });

  // node_modules/picomatch-browser/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/picomatch-browser/lib/parse.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var utils = require_utils();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = (args, options) => {
        if (typeof options.expandRange === "function") {
          return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v2) => utils.escapeRegex(v2)).join("..");
        }
        return value;
      };
      var syntaxError2 = (type2, char) => {
        return `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`;
      };
      var parse2 = (input, options) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        const bos = { type: "bos", value: "", output: opts.prepend || "" };
        const tokens = [bos];
        const capture = opts.capture ? "" : "?:";
        const PLATFORM_CHARS = constants.globChars(opts.windows);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = (opts2) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? "" : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        if (typeof opts.noext === "boolean") {
          opts.noextglob = opts.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = () => state.index === len - 1;
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index];
        const remaining = () => input.slice(state.index + 1);
        const consume = (value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        };
        const append = (token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        };
        const negate = () => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        };
        const increment = (type2) => {
          state[type2]++;
          stack.push(type2);
        };
        const decrement = (type2) => {
          state[type2]--;
          stack.pop();
        };
        const push = (tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output) append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        };
        const extglobOpen = (type2, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output = (opts.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type: type2, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output });
          extglobs.push(token);
        };
        const extglobClose = (token) => {
          let output = token.close + (opts.capture ? ")" : "");
          if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
              output = token.close = `)$))${extglobStar}`;
            }
            if (token.prev.type === "bos" && eos()) {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output });
          decrement("parens");
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star : "");
              }
              return star;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts.unescape === true) {
              output = output.replace(/\\/g, "");
            } else {
              output = output.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output === input && opts.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output, state, options);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
              slashes = match[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts.unescape === true) {
              value = advance() || "";
            } else {
              value += advance() || "";
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix2 = POSIX_REGEX_SOURCE[rest2];
                  if (posix2) {
                    prev.value = pre + posix2;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output = expandRange(range, opts);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output = "\\}";
              state.output = out;
              for (const t2 of toks) {
                state.output += t2.output || t2.value;
              }
            }
            push({ type: "brace", value, output });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output = "|";
            }
            push({ type: "comma", value, output });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".") prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output = `\\${value}`;
              }
              push({ type: "text", value, output });
              continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
              value += match[0];
              state.index += match[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star };
          if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts.strictBrackets === true) throw new SyntaxError(syntaxError2("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts.strictBrackets === true) throw new SyntaxError(syntaxError2("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts.strictBrackets === true) throw new SyntaxError(syntaxError2("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      };
      parse2.fastpaths = (input, options) => {
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        input = REPLACEMENTS[input] || input;
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(opts.windows);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star = opts.bash === true ? ".*?" : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        const globstar = (opts2) => {
          if (opts2.noglobstar === true) return star;
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create = (str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
              return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
              return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
              return nodot + globstar(opts);
            case "**/*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default: {
              const match = /^(.*?)\.(\w+)$/.exec(str);
              if (!match) return;
              const source2 = create(match[1]);
              if (!source2) return;
              return source2 + DOT_LITERAL + match[2];
            }
          }
        };
        const output = utils.removePrefix(input, state);
        let source = create(output);
        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module.exports = parse2;
    }
  });

  // node_modules/picomatch-browser/lib/picomatch.js
  var require_picomatch = __commonJS({
    "node_modules/picomatch-browser/lib/picomatch.js"(exports, module) {
      "use strict";
      var scan = require_scan();
      var parse2 = require_parse();
      var utils = require_utils();
      var constants = require_constants();
      var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
      var picomatch2 = (glob, options, returnState = false) => {
        if (Array.isArray(glob)) {
          const fns = glob.map((input) => picomatch2(input, options, returnState));
          const arrayMatcher = (str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2) return state2;
            }
            return false;
          };
          return arrayMatcher;
        }
        const isState = isObject2(glob) && glob.tokens && glob.input;
        if (glob === "" || typeof glob !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts = options || {};
        const posix2 = opts.windows;
        const regex = isState ? picomatch2.compileRe(glob, options) : picomatch2.makeRe(glob, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored2 = () => false;
        if (opts.ignore) {
          const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
          isIgnored2 = picomatch2(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false) => {
          const { isMatch, match, output } = picomatch2.test(input, regex, options, { glob, posix: posix2 });
          const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
          if (typeof opts.onResult === "function") {
            opts.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored2(input)) {
            if (typeof opts.onIgnore === "function") {
              opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts.onMatch === "function") {
            opts.onMatch(result);
          }
          return returnObject ? result : true;
        };
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      };
      picomatch2.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts = options || {};
        const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
        let match = input === glob;
        let output = match && format ? format(input) : input;
        if (match === false) {
          output = format ? format(input) : input;
          match = output === glob;
        }
        if (match === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match = picomatch2.matchBase(input, regex, options, posix2);
          } else {
            match = regex.exec(output);
          }
        }
        return { isMatch: Boolean(match), match, output };
      };
      picomatch2.matchBase = (input, glob, options) => {
        const regex = glob instanceof RegExp ? glob : picomatch2.makeRe(glob, options);
        return regex.test(utils.basename(input));
      };
      picomatch2.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
      picomatch2.parse = (pattern, options) => {
        if (Array.isArray(pattern)) return pattern.map((p2) => picomatch2.parse(p2, options));
        return parse2(pattern, { ...options, fastpaths: false });
      };
      picomatch2.scan = (input, options) => scan(input, options);
      picomatch2.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return parsed.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? "" : "^";
        const append = opts.contains ? "" : "$";
        let source = `${prepend}(?:${parsed.output})${append}`;
        if (parsed && parsed.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch2.toRegex(source, options);
        if (returnState === true) {
          regex.state = parsed;
        }
        return regex;
      };
      picomatch2.makeRe = (input, options, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        const opts = options || {};
        let parsed = { negated: false, fastpaths: true };
        let prefix = "";
        let output;
        if (input.startsWith("./")) {
          input = input.slice(2);
          prefix = parsed.prefix = "./";
        }
        if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          output = parse2.fastpaths(input, options);
        }
        if (output === void 0) {
          parsed = parse2(input, options);
          parsed.prefix = prefix + (parsed.prefix || "");
        } else {
          parsed.output = output;
        }
        return picomatch2.compileRe(parsed, options, returnOutput, returnState);
      };
      picomatch2.toRegex = (source, options) => {
        try {
          const opts = options || {};
          return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
        } catch (err) {
          if (options && options.debug === true) throw err;
          return /$^/;
        }
      };
      picomatch2.constants = constants;
      module.exports = picomatch2;
    }
  });

  // node_modules/picomatch-browser/index.js
  var require_picomatch_browser = __commonJS({
    "node_modules/picomatch-browser/index.js"(exports, module) {
      "use strict";
      module.exports = require_picomatch();
    }
  });

  // node_modules/prettier/standalone.mjs
  var standalone_exports = {};
  __export(standalone_exports, {
    __debug: () => li,
    check: () => ci,
    default: () => Hn,
    doc: () => wu,
    format: () => Jn,
    formatWithCursor: () => zn,
    getSupportInfo: () => fi,
    util: () => Pu,
    version: () => Mn
  });
  function Ut(e, t2, u) {
    return ku.diff(e, t2, u);
  }
  function Yu(e) {
    let t2 = e.indexOf(Wt);
    return t2 !== -1 ? e.charAt(t2 + 1) === Je ? Lu : Ru : fo;
  }
  function Se(e) {
    return e === Ru ? Wt : e === Lu ? Mu : lo;
  }
  function $t(e, t2) {
    let u = po.get(t2);
    return e.match(u)?.length ?? 0;
  }
  function ju(e) {
    return oe(0, e, Fo, Je);
  }
  function mo(e) {
    return this[e < 0 ? this.length + e : e];
  }
  function Uu(e) {
    let t2 = e.length;
    for (; t2 > 0 && (e[t2 - 1] === "\r" || e[t2 - 1] === `
`); ) t2--;
    return t2 < e.length ? e.slice(0, t2) : e;
  }
  function Co(e) {
    if (typeof e == "string") return G;
    if (Array.isArray(e)) return j;
    if (!e) return;
    let { type: t2 } = e;
    if (He.has(t2)) return t2;
  }
  function go(e) {
    let t2 = e === null ? "null" : typeof e;
    if (t2 !== "string" && t2 !== "object") return `Unexpected doc '${t2}', 
Expected it to be 'string' or 'object'.`;
    if (H(e)) throw new Error("doc is valid.");
    let u = Object.prototype.toString.call(e);
    if (u !== "[object Object]") return `Unexpected doc '${u}'.`;
    let r = ho([...He].map((o) => `'${o}'`));
    return `Unexpected doc.type '${e.type}'.
Expected it to be ${r}.`;
  }
  function yo(e, t2, u, r) {
    let o = [e];
    for (; o.length > 0; ) {
      let n = o.pop();
      if (n === Wu) {
        u(o.pop());
        continue;
      }
      u && o.push(n, Wu);
      let a = H(n);
      if (!a) throw new Z(n);
      if (t2?.(n) !== false) switch (a) {
        case j:
        case w: {
          let s = a === j ? n : n.parts;
          for (let i = s.length, D = i - 1; D >= 0; --D) o.push(s[D]);
          break;
        }
        case B:
          o.push(n.flatContents, n.breakContents);
          break;
        case x:
          if (r && n.expandedStates) for (let s = n.expandedStates.length, i = s - 1; i >= 0; --i) o.push(n.expandedStates[i]);
          else o.push(n.contents);
          break;
        case k:
        case I:
        case R:
        case O:
        case L:
          o.push(n.contents);
          break;
        case G:
        case U:
        case v:
        case M:
        case _:
        case T:
          break;
        default:
          throw new Z(n);
      }
    }
  }
  function Pe(e, t2) {
    if (typeof e == "string") return t2(e);
    let u = /* @__PURE__ */ new Map();
    return r(e);
    function r(n) {
      if (u.has(n)) return u.get(n);
      let a = o(n);
      return u.set(n, a), a;
    }
    function o(n) {
      switch (H(n)) {
        case j:
          return t2(n.map(r));
        case w:
          return t2({ ...n, parts: n.parts.map(r) });
        case B:
          return t2({ ...n, breakContents: r(n.breakContents), flatContents: r(n.flatContents) });
        case x: {
          let { expandedStates: a, contents: s } = n;
          return a ? (a = a.map(r), s = a[0]) : s = r(s), t2({ ...n, contents: s, expandedStates: a });
        }
        case k:
        case I:
        case R:
        case O:
        case L:
          return t2({ ...n, contents: r(n.contents) });
        case G:
        case U:
        case v:
        case M:
        case _:
        case T:
          return t2(n);
        default:
          throw new Z(n);
      }
    }
  }
  function Xe(e, t2, u) {
    let r = u, o = false;
    function n(a) {
      if (o) return false;
      let s = t2(a);
      s !== void 0 && (o = true, r = s);
    }
    return we(e, n), r;
  }
  function bo(e) {
    if (e.type === x && e.break || e.type === _ && e.hard || e.type === T) return true;
  }
  function Ku(e) {
    return Xe(e, bo, false);
  }
  function $u(e) {
    if (e.length > 0) {
      let t2 = b(0, e, -1);
      !t2.expandedStates && !t2.break && (t2.break = "propagated");
    }
    return null;
  }
  function Gu(e) {
    let t2 = /* @__PURE__ */ new Set(), u = [];
    function r(n) {
      if (n.type === T && $u(u), n.type === x) {
        if (u.push(n), t2.has(n)) return false;
        t2.add(n);
      }
    }
    function o(n) {
      n.type === x && u.pop().break && $u(u);
    }
    we(e, r, o, true);
  }
  function Ao(e) {
    return e.type === _ && !e.hard ? e.soft ? "" : " " : e.type === B ? e.flatContents : e;
  }
  function zu(e) {
    return Pe(e, Ao);
  }
  function Vu(e) {
    for (e = [...e]; e.length >= 2 && b(0, e, -2).type === _ && b(0, e, -1).type === T; ) e.length -= 2;
    if (e.length > 0) {
      let t2 = Oe(b(0, e, -1));
      e[e.length - 1] = t2;
    }
    return e;
  }
  function Oe(e) {
    switch (H(e)) {
      case I:
      case R:
      case x:
      case L:
      case O: {
        let t2 = Oe(e.contents);
        return { ...e, contents: t2 };
      }
      case B:
        return { ...e, breakContents: Oe(e.breakContents), flatContents: Oe(e.flatContents) };
      case w:
        return { ...e, parts: Vu(e.parts) };
      case j:
        return Vu(e);
      case G:
        return Uu(e);
      case k:
      case U:
      case v:
      case M:
      case _:
      case T:
        break;
      default:
        throw new Z(e);
    }
    return e;
  }
  function qe(e) {
    return Oe(xo(e));
  }
  function _o(e) {
    switch (H(e)) {
      case w:
        if (e.parts.every((t2) => t2 === "")) return "";
        break;
      case x:
        if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
        if (e.contents.type === x && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
      case k:
      case I:
      case R:
      case L:
        if (!e.contents) return "";
        break;
      case B:
        if (!e.flatContents && !e.breakContents) return "";
        break;
      case j: {
        let t2 = [];
        for (let u of e) {
          if (!u) continue;
          let [r, ...o] = Array.isArray(u) ? u : [u];
          typeof r == "string" && typeof b(0, t2, -1) == "string" ? t2[t2.length - 1] += r : t2.push(r), t2.push(...o);
        }
        return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : t2;
      }
      case G:
      case U:
      case v:
      case M:
      case _:
      case O:
      case T:
        break;
      default:
        throw new Z(e);
    }
    return e;
  }
  function xo(e) {
    return Pe(e, (t2) => _o(t2));
  }
  function Ju(e, t2 = Qe) {
    return Pe(e, (u) => typeof u == "string" ? Ie(t2, u.split(`
`)) : u);
  }
  function Bo(e) {
    if (e.type === _) return true;
  }
  function Hu(e) {
    return Xe(e, Bo, false);
  }
  function Ee(e, t2) {
    return e.type === O ? { ...e, contents: t2(e.contents) } : t2(e);
  }
  function ae(e) {
    return N(e), { type: I, contents: e };
  }
  function De(e, t2) {
    return qu(e), N(t2), { type: k, contents: t2, n: e };
  }
  function Qu(e) {
    return De(Number.NEGATIVE_INFINITY, e);
  }
  function et(e) {
    return De({ type: "root" }, e);
  }
  function Zu(e) {
    return De(-1, e);
  }
  function tt(e, t2, u) {
    N(e);
    let r = e;
    if (t2 > 0) {
      for (let o = 0; o < Math.floor(t2 / u); ++o) r = ae(r);
      r = De(t2 % u, r), r = De(Number.NEGATIVE_INFINITY, r);
    }
    return r;
  }
  function er(e) {
    return Xu(e), { type: w, parts: e };
  }
  function Kt(e, t2 = {}) {
    return N(e), Ze(t2.expandedStates, true), { type: x, id: t2.id, contents: e, break: !!t2.shouldBreak, expandedStates: t2.expandedStates };
  }
  function tr(e, t2) {
    return Kt(e[0], { ...t2, expandedStates: e });
  }
  function ur(e, t2 = "", u = {}) {
    return N(e), t2 !== "" && N(t2), { type: B, breakContents: e, flatContents: t2, groupId: u.groupId };
  }
  function rr(e, t2) {
    return N(e), { type: R, contents: e, groupId: t2.groupId, negate: t2.negate };
  }
  function Ie(e, t2) {
    N(e), Ze(t2);
    let u = [];
    for (let r = 0; r < t2.length; r++) r !== 0 && u.push(e), u.push(t2[r]);
    return u;
  }
  function nr(e, t2) {
    return N(t2), e ? { type: O, label: e, contents: t2 } : t2;
  }
  function ve(e) {
    return N(e), { type: L, contents: e };
  }
  function te(e) {
    if (!e) return "";
    if (Array.isArray(e)) {
      let t2 = [];
      for (let u of e) if (Array.isArray(u)) t2.push(...te(u));
      else {
        let r = te(u);
        r !== "" && t2.push(r);
      }
      return t2;
    }
    return e.type === B ? { ...e, breakContents: te(e.breakContents), flatContents: te(e.flatContents) } : e.type === x ? { ...e, contents: te(e.contents), expandedStates: e.expandedStates?.map(te) } : e.type === w ? { type: "fill", parts: e.parts.map(te) } : e.contents ? { ...e, contents: te(e.contents) } : e;
  }
  function sr(e) {
    let t2 = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ new Set();
    return r(te(e));
    function r(n, a, s) {
      if (typeof n == "string") return JSON.stringify(n);
      if (Array.isArray(n)) {
        let i = n.map(r).filter(Boolean);
        return i.length === 1 ? i[0] : `[${i.join(", ")}]`;
      }
      if (n.type === _) {
        let i = s?.[a + 1]?.type === T;
        return n.literal ? i ? "literalline" : "literallineWithoutBreakParent" : n.hard ? i ? "hardline" : "hardlineWithoutBreakParent" : n.soft ? "softline" : "line";
      }
      if (n.type === T) return s?.[a - 1]?.type === _ && s[a - 1].hard ? void 0 : "breakParent";
      if (n.type === v) return "trim";
      if (n.type === I) return "indent(" + r(n.contents) + ")";
      if (n.type === k) return n.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + r(n.contents) + ")" : n.n < 0 ? "dedent(" + r(n.contents) + ")" : n.n.type === "root" ? "markAsRoot(" + r(n.contents) + ")" : "align(" + JSON.stringify(n.n) + ", " + r(n.contents) + ")";
      if (n.type === B) return "ifBreak(" + r(n.breakContents) + (n.flatContents ? ", " + r(n.flatContents) : "") + (n.groupId ? (n.flatContents ? "" : ', ""') + `, { groupId: ${o(n.groupId)} }` : "") + ")";
      if (n.type === R) {
        let i = [];
        n.negate && i.push("negate: true"), n.groupId && i.push(`groupId: ${o(n.groupId)}`);
        let D = i.length > 0 ? `, { ${i.join(", ")} }` : "";
        return `indentIfBreak(${r(n.contents)}${D})`;
      }
      if (n.type === x) {
        let i = [];
        n.break && n.break !== "propagated" && i.push("shouldBreak: true"), n.id && i.push(`id: ${o(n.id)}`);
        let D = i.length > 0 ? `, { ${i.join(", ")} }` : "";
        return n.expandedStates ? `conditionalGroup([${n.expandedStates.map((f) => r(f)).join(",")}]${D})` : `group(${r(n.contents)}${D})`;
      }
      if (n.type === w) return `fill([${n.parts.map((i) => r(i)).join(", ")}])`;
      if (n.type === L) return "lineSuffix(" + r(n.contents) + ")";
      if (n.type === M) return "lineSuffixBoundary";
      if (n.type === O) return `label(${JSON.stringify(n.label)}, ${r(n.contents)})`;
      if (n.type === U) return "cursor";
      throw new Error("Unknown doc type " + n.type);
    }
    function o(n) {
      if (typeof n != "symbol") return JSON.stringify(String(n));
      if (n in t2) return t2[n];
      let a = n.description || "symbol";
      for (let s = 0; ; s++) {
        let i = a + (s > 0 ? ` #${s}` : "");
        if (!u.has(i)) return u.add(i), t2[n] = `Symbol.for(${JSON.stringify(i)})`;
      }
    }
  }
  function zt(e) {
    return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
  }
  function Jt(e) {
    return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e >= 94192 && e <= 94198 || e >= 94208 && e <= 101589 || e >= 101631 && e <= 101662 || e >= 101760 && e <= 101874 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128728 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129674 || e >= 129678 && e <= 129734 || e === 129736 || e >= 129741 && e <= 129756 || e >= 129759 && e <= 129770 || e >= 129775 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
  }
  function So(e) {
    if (!e) return 0;
    if (!To.test(e)) return e.length;
    e = e.replace(Dr(), (u) => No.has(u) ? " " : "  ");
    let t2 = 0;
    for (let u of e) {
      let r = u.codePointAt(0);
      r <= 31 || r >= 127 && r <= 159 || r >= 768 && r <= 879 || r >= 65024 && r <= 65039 || (t2 += zt(r) || Jt(r) ? 2 : 1);
    }
    return t2;
  }
  function fr(e, t2, u) {
    let r = t2.type === 1 ? e.queue.slice(0, -1) : [...e.queue, t2], o = "", n = 0, a = 0, s = 0;
    for (let p2 of r) switch (p2.type) {
      case 0:
        f(), u.useTabs ? i(1) : D(u.tabWidth);
        break;
      case 3: {
        let { string: F } = p2;
        f(), o += F, n += F.length;
        break;
      }
      case 2: {
        let { width: F } = p2;
        a += 1, s += F;
        break;
      }
      default:
        throw new Error(`Unexpected indent comment '${p2.type}'.`);
    }
    return d(), { ...e, value: o, length: n, queue: r };
    function i(p2) {
      o += "	".repeat(p2), n += u.tabWidth * p2;
    }
    function D(p2) {
      o += " ".repeat(p2), n += p2;
    }
    function f() {
      u.useTabs ? l() : d();
    }
    function l() {
      a > 0 && i(a), c();
    }
    function d() {
      s > 0 && D(s), c();
    }
    function c() {
      a = 0, s = 0;
    }
  }
  function lr(e, t2, u) {
    if (!t2) return e;
    if (t2.type === "root") return { ...e, root: e };
    if (t2 === Number.NEGATIVE_INFINITY) return e.root;
    let r;
    return typeof t2 == "number" ? t2 < 0 ? r = Oo : r = { type: 2, width: t2 } : r = { type: 3, string: t2 }, fr(e, r, u);
  }
  function dr(e, t2) {
    return fr(e, wo, t2);
  }
  function Po(e) {
    let t2 = 0;
    for (let u = e.length - 1; u >= 0; u--) {
      let r = e[u];
      if (r === " " || r === "	") t2++;
      else break;
    }
    return t2;
  }
  function Xt(e) {
    let t2 = Po(e);
    return { text: t2 === 0 ? e : e.slice(0, e.length - t2), count: t2 };
  }
  function rt(e, t2, u, r, o, n) {
    if (u === Number.POSITIVE_INFINITY) return true;
    let a = t2.length, s = false, i = [e], D = "";
    for (; u >= 0; ) {
      if (i.length === 0) {
        if (a === 0) return true;
        i.push(t2[--a]);
        continue;
      }
      let { mode: f, doc: l } = i.pop(), d = H(l);
      switch (d) {
        case G:
          l && (s && (D += " ", u -= 1, s = false), D += l, u -= Re(l));
          break;
        case j:
        case w: {
          let c = d === j ? l : l.parts, p2 = l[qt] ?? 0;
          for (let F = c.length - 1; F >= p2; F--) i.push({ mode: f, doc: c[F] });
          break;
        }
        case I:
        case k:
        case R:
        case O:
          i.push({ mode: f, doc: l.contents });
          break;
        case v: {
          let { text: c, count: p2 } = Xt(D);
          D = c, u += p2;
          break;
        }
        case x: {
          if (n && l.break) return false;
          let c = l.break ? W : f, p2 = l.expandedStates && c === W ? b(0, l.expandedStates, -1) : l.contents;
          i.push({ mode: c, doc: p2 });
          break;
        }
        case B: {
          let p2 = (l.groupId ? o[l.groupId] || q : f) === W ? l.breakContents : l.flatContents;
          p2 && i.push({ mode: f, doc: p2 });
          break;
        }
        case _:
          if (f === W || l.hard) return true;
          l.soft || (s = true);
          break;
        case L:
          r = true;
          break;
        case M:
          if (r) return false;
          break;
      }
    }
    return false;
  }
  function Ce(e, t2) {
    let u = /* @__PURE__ */ Object.create(null), r = t2.printWidth, o = Se(t2.endOfLine), n = 0, a = [{ indent: Ht, mode: W, doc: e }], s = "", i = false, D = [], f = [], l = [], d = [], c = 0;
    for (Gu(e); a.length > 0; ) {
      let { indent: m, mode: h, doc: E } = a.pop();
      switch (H(E)) {
        case G: {
          let g = o !== `
` ? oe(0, E, `
`, o) : E;
          g && (s += g, a.length > 0 && (n += Re(g)));
          break;
        }
        case j:
          for (let g = E.length - 1; g >= 0; g--) a.push({ indent: m, mode: h, doc: E[g] });
          break;
        case U:
          if (f.length >= 2) throw new Error("There are too many 'cursor' in doc.");
          f.push(c + s.length);
          break;
        case I:
          a.push({ indent: dr(m, t2), mode: h, doc: E.contents });
          break;
        case k:
          a.push({ indent: lr(m, E.n, t2), mode: h, doc: E.contents });
          break;
        case v:
          y();
          break;
        case x:
          switch (h) {
            case q:
              if (!i) {
                a.push({ indent: m, mode: E.break ? W : q, doc: E.contents });
                break;
              }
            case W: {
              i = false;
              let g = { indent: m, mode: q, doc: E.contents }, A = r - n, J = D.length > 0;
              if (!E.break && rt(g, a, A, J, u)) a.push(g);
              else if (E.expandedStates) {
                let Q = b(0, E.expandedStates, -1);
                if (E.break) {
                  a.push({ indent: m, mode: W, doc: Q });
                  break;
                } else for (let re = 1; re < E.expandedStates.length + 1; re++) if (re >= E.expandedStates.length) {
                  a.push({ indent: m, mode: W, doc: Q });
                  break;
                } else {
                  let Te = E.expandedStates[re], ne = { indent: m, mode: q, doc: Te };
                  if (rt(ne, a, A, J, u)) {
                    a.push(ne);
                    break;
                  }
                }
              } else a.push({ indent: m, mode: W, doc: E.contents });
              break;
            }
          }
          E.id && (u[E.id] = b(0, a, -1).mode);
          break;
        case w: {
          let g = r - n, A = E[qt] ?? 0, { parts: J } = E, Q = J.length - A;
          if (Q === 0) break;
          let re = J[A + 0], Te = J[A + 1], ne = { indent: m, mode: q, doc: re }, vt = { indent: m, mode: W, doc: re }, Rt = rt(ne, [], g, D.length > 0, u, true);
          if (Q === 1) {
            Rt ? a.push(ne) : a.push(vt);
            break;
          }
          let Iu = { indent: m, mode: q, doc: Te }, Lt = { indent: m, mode: W, doc: Te };
          if (Q === 2) {
            Rt ? a.push(Iu, ne) : a.push(Lt, vt);
            break;
          }
          let Xn = J[A + 2], qn = { indent: m, mode: h, doc: { ...E, [qt]: A + 2 } }, Qn = rt({ indent: m, mode: q, doc: [re, Te, Xn] }, [], g, D.length > 0, u, true);
          a.push(qn), Qn ? a.push(Iu, ne) : Rt ? a.push(Lt, ne) : a.push(Lt, vt);
          break;
        }
        case B:
        case R: {
          let g = E.groupId ? u[E.groupId] : h;
          if (g === W) {
            let A = E.type === B ? E.breakContents : E.negate ? E.contents : ae(E.contents);
            A && a.push({ indent: m, mode: h, doc: A });
          }
          if (g === q) {
            let A = E.type === B ? E.flatContents : E.negate ? ae(E.contents) : E.contents;
            A && a.push({ indent: m, mode: h, doc: A });
          }
          break;
        }
        case L:
          D.push({ indent: m, mode: h, doc: E.contents });
          break;
        case M:
          D.length > 0 && a.push({ indent: m, mode: h, doc: ke });
          break;
        case _:
          switch (h) {
            case q:
              if (E.hard) i = true;
              else {
                E.soft || (s += " ", n += 1);
                break;
              }
            case W:
              if (D.length > 0) {
                a.push({ indent: m, mode: h, doc: E }, ...D.reverse()), D.length = 0;
                break;
              }
              E.literal ? (s += o, n = 0, m.root && (m.root.value && (s += m.root.value), n = m.root.length)) : (y(), s += o + m.value, n = m.length);
              break;
          }
          break;
        case O:
          a.push({ indent: m, mode: h, doc: E.contents });
          break;
        case T:
          break;
        default:
          throw new Z(E);
      }
      a.length === 0 && D.length > 0 && (a.push(...D.reverse()), D.length = 0);
    }
    let p2 = l.join("") + s, F = [...d, ...f];
    if (F.length !== 2) return { formatted: p2 };
    let C = F[0];
    return { formatted: p2, cursorNodeStart: C, cursorNodeText: p2.slice(C, b(0, F, -1)) };
    function y() {
      let { text: m, count: h } = Xt(s);
      m && (l.push(m), c += m.length), s = "", n -= h, f.length > 0 && (d.push(...f.map((E) => Math.min(E, c))), f.length = 0);
    }
  }
  function Io(e, t2, u = 0) {
    let r = 0;
    for (let o = u; o < e.length; ++o) e[o] === "	" ? r = r + t2 - r % t2 : r++;
    return r;
  }
  function ko(e) {
    return e !== null && typeof e == "object";
  }
  function ye(e) {
    return (t2, u, r) => {
      let o = !!r?.backwards;
      if (u === false) return false;
      let { length: n } = t2, a = u;
      for (; a >= 0 && a < n; ) {
        let s = t2.charAt(a);
        if (e instanceof RegExp) {
          if (!e.test(s)) return a;
        } else if (!e.includes(s)) return a;
        o ? a-- : a++;
      }
      return a === -1 || a === n ? a : false;
    };
  }
  function vo(e, t2, u) {
    let r = !!u?.backwards;
    if (t2 === false) return false;
    let o = e.charAt(t2);
    if (r) {
      if (e.charAt(t2 - 1) === "\r" && o === `
`) return t2 - 2;
      if (mr(o)) return t2 - 1;
    } else {
      if (o === "\r" && e.charAt(t2 + 1) === `
`) return t2 + 2;
      if (mr(o)) return t2 + 1;
    }
    return t2;
  }
  function Ro(e, t2, u = {}) {
    let r = Y(e, u.backwards ? t2 - 1 : t2, u), o = K(e, r, u);
    return r !== o;
  }
  function Lo(e) {
    return Array.isArray(e) && e.length > 0;
  }
  function* be(e, t2) {
    let { getVisitorKeys: u, filter: r = () => true } = t2, o = (n) => ge(n) && r(n);
    for (let n of u(e)) {
      let a = e[n];
      if (Array.isArray(a)) for (let s of a) o(s) && (yield s);
      else o(a) && (yield a);
    }
  }
  function* Cr(e, t2) {
    let u = [e];
    for (let r = 0; r < u.length; r++) {
      let o = u[r];
      for (let n of be(o, t2)) yield n, u.push(n);
    }
  }
  function hr(e, t2) {
    return be(e, t2).next().done;
  }
  function gr(e, t2, u) {
    let { cache: r } = u;
    if (r.has(e)) return r.get(e);
    let { filter: o } = u;
    if (!o) return [];
    let n, a = (u.getChildren?.(e, u) ?? [...be(e, { getVisitorKeys: u.getVisitorKeys })]).flatMap((D) => (n ?? (n = [e, ...t2]), o(D, n) ? [D] : gr(D, n, u))), { locStart: s, locEnd: i } = u;
    return a.sort((D, f) => s(D) - s(f) || i(D) - i(f)), r.set(e, a), a;
  }
  function Mo(e) {
    let t2 = e.type || e.kind || "(unknown type)", u = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
    return u.length > 20 && (u = u.slice(0, 19) + "\u2026"), t2 + (u ? " " + u : "");
  }
  function Zt(e, t2) {
    (e.comments ?? (e.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = Mo(e);
  }
  function fe(e, t2) {
    t2.leading = true, t2.trailing = false, Zt(e, t2);
  }
  function ue(e, t2, u) {
    t2.leading = false, t2.trailing = false, u && (t2.marker = u), Zt(e, t2);
  }
  function le(e, t2) {
    t2.leading = false, t2.trailing = true, Zt(e, t2);
  }
  function br(e, t2, u, r, o = []) {
    let { locStart: n, locEnd: a } = u, s = n(t2), i = a(t2), D = at(e, o, { cache: uu, locStart: n, locEnd: a, getVisitorKeys: u.getVisitorKeys, filter: u.printer.canAttachComment, getChildren: u.printer.getCommentChildNodes }), f, l, d = 0, c = D.length;
    for (; d < c; ) {
      let p2 = d + c >> 1, F = D[p2], C = n(F), y = a(F);
      if (C <= s && i <= y) return br(F, t2, u, F, [F, ...o]);
      if (y <= s) {
        f = F, d = p2 + 1;
        continue;
      }
      if (i <= C) {
        l = F, c = p2;
        continue;
      }
      throw new Error("Comment location overlaps with node location");
    }
    if (r?.type === "TemplateLiteral") {
      let { quasis: p2 } = r, F = tu(p2, t2, u);
      f && tu(p2, f, u) !== F && (f = null), l && tu(p2, l, u) !== F && (l = null);
    }
    return { enclosingNode: r, precedingNode: f, followingNode: l };
  }
  function Ar(e, t2) {
    let { comments: u } = e;
    if (delete e.comments, !Er(u) || !t2.printer.canAttachComment) return;
    let r = [], { printer: { features: { experimental_avoidAstMutation: o }, handleComments: n = {} }, originalText: a } = t2, { ownLine: s = eu, endOfLine: i = eu, remaining: D = eu } = n, f = u.map((l, d) => ({ ...br(e, l, t2), comment: l, text: a, options: t2, ast: e, isLastComment: u.length - 1 === d }));
    for (let [l, d] of f.entries()) {
      let { comment: c, precedingNode: p2, enclosingNode: F, followingNode: C, text: y, options: m, ast: h, isLastComment: E } = d, g;
      if (o ? g = [d] : (c.enclosingNode = F, c.precedingNode = p2, c.followingNode = C, g = [c, y, m, h, E]), Yo(y, m, f, l)) c.placement = "ownLine", s(...g) || (C ? fe(C, c) : p2 ? le(p2, c) : F ? ue(F, c) : ue(h, c));
      else if (jo(y, m, f, l)) c.placement = "endOfLine", i(...g) || (p2 ? le(p2, c) : C ? fe(C, c) : F ? ue(F, c) : ue(h, c));
      else if (c.placement = "remaining", !D(...g)) if (p2 && C) {
        let A = r.length;
        A > 0 && r[A - 1].followingNode !== C && yr(r, m), r.push(d);
      } else p2 ? le(p2, c) : C ? fe(C, c) : F ? ue(F, c) : ue(h, c);
    }
    if (yr(r, t2), !o) for (let l of u) delete l.precedingNode, delete l.enclosingNode, delete l.followingNode;
  }
  function Yo(e, t2, u, r) {
    let { comment: o, precedingNode: n } = u[r], { locStart: a, locEnd: s } = t2, i = a(o);
    if (n) for (let D = r - 1; D >= 0; D--) {
      let { comment: f, precedingNode: l } = u[D];
      if (l !== n || !_r(e.slice(s(f), i))) break;
      i = a(f);
    }
    return z(e, i, { backwards: true });
  }
  function jo(e, t2, u, r) {
    let { comment: o, followingNode: n } = u[r], { locStart: a, locEnd: s } = t2, i = s(o);
    if (n) for (let D = r + 1; D < u.length; D++) {
      let { comment: f, followingNode: l } = u[D];
      if (l !== n || !_r(e.slice(i, a(f)))) break;
      i = s(f);
    }
    return z(e, i);
  }
  function yr(e, t2) {
    let u = e.length;
    if (u === 0) return;
    let { precedingNode: r, followingNode: o } = e[0], n = t2.locStart(o), a;
    for (a = u; a > 0; --a) {
      let { comment: s, precedingNode: i, followingNode: D } = e[a - 1];
      P(i, r), P(D, o);
      let f = t2.originalText.slice(t2.locEnd(s), n);
      if (t2.printer.isGap?.(f, t2) ?? /^[\s(]*$/u.test(f)) n = t2.locStart(s);
      else break;
    }
    for (let [s, { comment: i }] of e.entries()) s < a ? le(r, i) : fe(o, i);
    for (let s of [r, o]) s.comments && s.comments.length > 1 && s.comments.sort((i, D) => t2.locStart(i) - t2.locStart(D));
    e.length = 0;
  }
  function tu(e, t2, u) {
    let r = u.locStart(t2) - 1;
    for (let o = 1; o < e.length; ++o) if (r < u.locStart(e[o])) return o - 1;
    return 0;
  }
  function Uo(e, t2) {
    let u = t2 - 1;
    u = Y(e, u, { backwards: true }), u = K(e, u, { backwards: true }), u = Y(e, u, { backwards: true });
    let r = K(e, u, { backwards: true });
    return u !== r;
  }
  function xr(e, t2) {
    let u = e.node;
    return u.printed = true, t2.printer.printComment(e, t2);
  }
  function Wo(e, t2) {
    let u = e.node, r = [xr(e, t2)], { printer: o, originalText: n, locStart: a, locEnd: s } = t2;
    if (o.isBlockComment?.(u)) {
      let f = z(n, s(u)) ? z(n, a(u), { backwards: true }) ? V : ut : " ";
      r.push(f);
    } else r.push(V);
    let D = K(n, Y(n, s(u)));
    return D !== false && z(n, D) && r.push(V), r;
  }
  function $o(e, t2, u) {
    let r = e.node, o = xr(e, t2), { printer: n, originalText: a, locStart: s } = t2, i = n.isBlockComment?.(r);
    if (u?.hasLineSuffix && !u?.isBlock || z(a, s(r), { backwards: true })) {
      let D = Le(a, s(r));
      return { doc: ve([V, D ? V : "", o]), isBlock: i, hasLineSuffix: true };
    }
    return !i || u?.hasLineSuffix ? { doc: [ve([" ", o]), ce], isBlock: i, hasLineSuffix: true } : { doc: [" ", o], isBlock: i, hasLineSuffix: false };
  }
  function Vo(e, t2) {
    let u = e.node;
    if (!u) return {};
    let r = t2[Symbol.for("printedComments")];
    if ((u.comments || []).filter((i) => !r.has(i)).length === 0) return { leading: "", trailing: "" };
    let n = [], a = [], s;
    return e.each(() => {
      let i = e.node;
      if (r?.has(i)) return;
      let { leading: D, trailing: f } = i;
      D ? n.push(Wo(e, t2)) : f && (s = $o(e, t2, s), a.push(s.doc));
    }, "comments"), { leading: n, trailing: a };
  }
  function Br(e, t2, u) {
    let { leading: r, trailing: o } = Vo(e, u);
    return !r && !o ? t2 : Ee(t2, (n) => [r, n, o]);
  }
  function Tr(e) {
    let { [Symbol.for("comments")]: t2, [Symbol.for("printedComments")]: u } = e;
    for (let r of t2) {
      if (!r.printed && !u.has(r)) throw new Error('Comment "' + r.value.trim() + '" was not printed. Please report this error!');
      delete r.printed;
    }
  }
  function it({ plugins: e = [], showDeprecated: t2 = false } = {}) {
    let u = e.flatMap((o) => o.languages ?? []), r = [];
    for (let o of Go(Object.assign({}, ...e.map(({ options: n }) => n), Sr))) !t2 && o.deprecated || (Array.isArray(o.choices) && (t2 || (o.choices = o.choices.filter((n) => !n.deprecated)), o.name === "parser" && (o.choices = [...o.choices, ...Ko(o.choices, u, e)])), o.pluginDefaults = Object.fromEntries(e.filter((n) => n.defaultOptions?.[o.name] !== void 0).map((n) => [n.name, n.defaultOptions[o.name]])), r.push(o));
    return { languages: u, options: r };
  }
  function* Ko(e, t2, u) {
    let r = new Set(e.map((o) => o.value));
    for (let o of t2) if (o.parsers) {
      for (let n of o.parsers) if (!r.has(n)) {
        r.add(n);
        let a = u.find((i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, n)), s = o.name;
        a?.name && (s += ` (plugin: ${a.name})`), yield { value: n, description: s };
      }
    }
  }
  function Go(e) {
    let t2 = [];
    for (let [u, r] of Object.entries(e)) {
      let o = { name: u, ...r };
      Array.isArray(o.default) && (o.default = b(0, o.default, -1).value), t2.push(o);
    }
    return t2;
  }
  function Ho() {
    let e = globalThis, t2 = e.Deno?.build?.os;
    return typeof t2 == "string" ? t2 === "windows" : e.navigator?.platform?.startsWith("Win") ?? e.process?.platform?.startsWith("win") ?? false;
  }
  function Or(e) {
    if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
    return e;
  }
  function qo(e) {
    return e = Or(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
  }
  function Qo(e) {
    e = Or(e);
    let t2 = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    return e.hostname !== "" && (t2 = `\\\\${e.hostname}${t2}`), t2;
  }
  function ru(e) {
    return Xo ? Qo(e) : qo(e);
  }
  function kr(e, t2) {
    if (!t2) return;
    let u = Pr(t2).toLowerCase();
    return e.find(({ filenames: r }) => r?.some((o) => o.toLowerCase() === u)) ?? e.find(({ extensions: r }) => r?.some((o) => u.endsWith(o)));
  }
  function Zo(e, t2) {
    if (t2) return e.find(({ name: u }) => u.toLowerCase() === t2) ?? e.find(({ aliases: u }) => u?.includes(t2)) ?? e.find(({ extensions: u }) => u?.includes(`.${t2}`));
  }
  function vr(e, t2) {
    if (t2) {
      if (Ir(t2)) try {
        t2 = ru(t2);
      } catch {
        return;
      }
      if (typeof t2 == "string") return e.find(({ isSupported: u }) => u?.({ filepath: t2 }));
    }
  }
  function ta(e, t2) {
    let u = wr(0, e.plugins).flatMap((o) => o.languages ?? []);
    return (Zo(u, t2.language) ?? kr(u, t2.physicalFile) ?? kr(u, t2.file) ?? vr(u, t2.physicalFile) ?? vr(u, t2.file) ?? ea?.(u, t2.physicalFile))?.parsers[0];
  }
  function Mr(e, t2, u, r) {
    return [`Invalid ${$.red(r.key(e))} value.`, `Expected ${$.blue(u)},`, `but received ${t2 === Dt ? $.gray("nothing") : $.red(r.value(t2))}.`].join(" ");
  }
  function jr({ text: e, list: t2 }, u) {
    let r = [];
    return e && r.push(`- ${$.blue(e)}`), t2 && r.push([`- ${$.blue(t2.title)}:`].concat(t2.values.map((o) => jr(o, u - Lr.length).replace(/^|\n/g, `$&${Lr}`))).join(`
`)), Ur(r, u);
  }
  function Ur(e, t2) {
    if (e.length === 1) return e[0];
    let [u, r] = e, [o, n] = e.map((a) => a.split(`
`, 1)[0].length);
    return o > t2 && o > n ? r : u;
  }
  function ct(e, t2, u) {
    if (e === t2) return 0;
    let r = u?.maxDistance, o = e;
    e.length > t2.length && (e = t2, t2 = o);
    let n = e.length, a = t2.length;
    for (; n > 0 && e.charCodeAt(~-n) === t2.charCodeAt(~-a); ) n--, a--;
    let s = 0;
    for (; s < n && e.charCodeAt(s) === t2.charCodeAt(s); ) s++;
    if (n -= s, a -= s, r !== void 0 && a - n > r) return r;
    if (n === 0) return r !== void 0 && a > r ? r : a;
    let i, D, f, l, d = 0, c = 0;
    for (; d < n; ) au[d] = e.charCodeAt(s + d), _e[d] = ++d;
    for (; c < a; ) {
      for (i = t2.charCodeAt(s + c), f = c++, D = c, d = 0; d < n; d++) l = i === au[d] ? f : f + 1, f = _e[d], D = _e[d] = f > D ? l > D ? D + 1 : l : l > f ? f + 1 : l;
      if (r !== void 0) {
        let p2 = D;
        for (d = 0; d < n; d++) _e[d] < p2 && (p2 = _e[d]);
        if (p2 > r) return r;
      }
    }
    return _e.length = n, au.length = n, r !== void 0 && D > r ? r : D;
  }
  function Wr(e, t2, u) {
    if (!Array.isArray(t2) || t2.length === 0) return;
    let r = u?.maxDistance, o = e.length;
    for (let i of t2) if (i === e) return i;
    if (r === 0) return;
    let n, a = Number.POSITIVE_INFINITY, s = /* @__PURE__ */ new Set();
    for (let i of t2) {
      if (s.has(i)) continue;
      s.add(i);
      let D = Math.abs(i.length - o);
      if (D >= a || r !== void 0 && D > r) continue;
      let f = Number.isFinite(a) ? r === void 0 ? a : Math.min(a, r) : r, l = f === void 0 ? ct(e, i) : ct(e, i, { maxDistance: f });
      if (r !== void 0 && l > r) continue;
      let d = l;
      if (f !== void 0 && l === f && f === r && (d = ct(e, i)), d < a && (a = d, n = i, a === 0)) break;
    }
    if (!(r !== void 0 && a > r)) return n;
  }
  function ra(e, t2) {
    let u = new e(t2), r = Object.create(u);
    for (let o of ua) o in t2 && (r[o] = na(t2[o], u, S.prototype[o].length));
    return r;
  }
  function na(e, t2, u) {
    return typeof e == "function" ? (...r) => e(...r.slice(0, u - 1), t2, ...r.slice(u - 1)) : () => e;
  }
  function $r({ from: e, to: t2 }) {
    return { from: [e], to: t2 };
  }
  function Kr(e, t2) {
    let u = /* @__PURE__ */ Object.create(null);
    for (let r of e) {
      let o = r[t2];
      if (u[o]) throw new Error(`Duplicate ${t2} ${JSON.stringify(o)}`);
      u[o] = r;
    }
    return u;
  }
  function Gr(e, t2) {
    let u = /* @__PURE__ */ new Map();
    for (let r of e) {
      let o = r[t2];
      if (u.has(o)) throw new Error(`Duplicate ${t2} ${JSON.stringify(o)}`);
      u.set(o, r);
    }
    return u;
  }
  function zr() {
    let e = /* @__PURE__ */ Object.create(null);
    return (t2) => {
      let u = JSON.stringify(t2);
      return e[u] ? true : (e[u] = true, false);
    };
  }
  function Jr(e, t2) {
    let u = [], r = [];
    for (let o of e) t2(o) ? u.push(o) : r.push(o);
    return [u, r];
  }
  function Hr(e) {
    return e === Math.floor(e);
  }
  function Xr(e, t2) {
    if (e === t2) return 0;
    let u = typeof e, r = typeof t2, o = ["undefined", "object", "boolean", "number", "string"];
    return u !== r ? o.indexOf(u) - o.indexOf(r) : u !== "string" ? Number(e) - Number(t2) : e.localeCompare(t2);
  }
  function qr(e) {
    return (...t2) => {
      let u = e(...t2);
      return typeof u == "string" ? new Error(u) : u;
    };
  }
  function iu(e) {
    return e === void 0 ? {} : e;
  }
  function su(e) {
    if (typeof e == "string") return { text: e };
    let { text: t2, list: u } = e;
    return oa((t2 || u) !== void 0, "Unexpected `expected` result, there should be at least one field."), u ? { text: t2, list: { title: u.title, values: u.values.map(su) } } : { text: t2 };
  }
  function Du(e, t2) {
    return e === true ? true : e === false ? { value: t2 } : e;
  }
  function cu(e, t2, u = false) {
    return e === false ? false : e === true ? u ? true : [{ value: t2 }] : "value" in e ? [e] : e.length === 0 ? false : e;
  }
  function Vr(e, t2) {
    return typeof e == "string" || "key" in e ? { from: t2, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t2, to: e.to };
  }
  function mt(e, t2) {
    return e === void 0 ? [] : Array.isArray(e) ? e.map((u) => Vr(u, t2)) : [Vr(e, t2)];
  }
  function fu(e, t2) {
    let u = mt(typeof e == "object" && "redirect" in e ? e.redirect : e, t2);
    return u.length === 0 ? { remain: t2, redirect: u } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: u } : { redirect: u };
  }
  function oa(e, t2) {
    if (!e) throw new Error(t2);
  }
  function ia(e, t2, { logger: u = false, isCLI: r = false, passThrough: o = false, FlagSchema: n, descriptor: a } = {}) {
    if (r) {
      if (!n) throw new Error("'FlagSchema' option is required.");
      if (!a) throw new Error("'descriptor' option is required.");
    } else a = ie;
    let s = o ? Array.isArray(o) ? (d, c) => o.includes(d) ? { [d]: c } : void 0 : (d, c) => ({ [d]: c }) : (d, c, p2) => {
      let { _: F, ...C } = p2.schemas;
      return ft(d, c, { ...p2, schemas: C });
    }, i = sa(t2, { isCLI: r, FlagSchema: n }), D = new gt(i, { logger: u, unknown: s, descriptor: a }), f = u !== false;
    f && lu && (D._hasDeprecationWarned = lu);
    let l = D.normalize(e);
    return f && (lu = D._hasDeprecationWarned), l;
  }
  function sa(e, { isCLI: t2, FlagSchema: u }) {
    let r = [];
    t2 && r.push(dt.create({ name: "_" }));
    for (let o of e) r.push(Da(o, { isCLI: t2, optionInfos: e, FlagSchema: u })), o.alias && t2 && r.push(lt.create({ name: o.alias, sourceName: o.name }));
    return r;
  }
  function Da(e, { isCLI: t2, optionInfos: u, FlagSchema: r }) {
    let { name: o } = e, n = { name: o }, a, s = {};
    switch (e.type) {
      case "int":
        a = ht, t2 && (n.preprocess = Number);
        break;
      case "string":
        a = je;
        break;
      case "choice":
        a = Et, n.choices = e.choices.map((i) => i?.redirect ? { ...i, redirect: { to: { key: e.name, value: i.redirect } } } : i);
        break;
      case "boolean":
        a = Ft;
        break;
      case "flag":
        a = r, n.flags = u.flatMap((i) => [i.alias, i.description && i.name, i.oppositeDescription && `no-${i.name}`].filter(Boolean));
        break;
      case "path":
        a = je;
        break;
      default:
        throw new Error(`Unexpected type ${e.type}`);
    }
    if (e.exception ? n.validate = (i, D, f) => e.exception(i) || D.validate(i, f) : n.validate = (i, D, f) => i === void 0 || D.validate(i, f), e.redirect && (s.redirect = (i) => i ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t2 && !e.array) {
      let i = n.preprocess || ((D) => D);
      n.preprocess = (D, f, l) => f.preprocess(i(Array.isArray(D) ? b(0, D, -1) : D), l);
    }
    return e.array ? pt.create({ ...t2 ? { preprocess: (i) => Array.isArray(i) ? i : [i] } : {}, ...s, valueSchema: a.create(n) }) : a.create({ ...n, ...s });
  }
  function la(e) {
    return !!e?.[rn];
  }
  async function Fu(e, t2, u, r) {
    let { node: o } = u, { language: n } = o;
    if (!nn.has(n)) return;
    let a = o.value.trim(), s;
    if (a) {
      let i = n === "yaml" ? n : st(r, { language: n });
      if (!i) return;
      s = a ? await e(a, { parser: i }) : "";
    } else s = a;
    return et([o.startDelimiter, o.explicitLanguage ?? "", V, s, s ? V : "", o.endDelimiter]);
  }
  function da(e, t2) {
    return Ue({ node: e }) && (delete t2.end, delete t2.raw, delete t2.value), t2;
  }
  function pa({ node: e }) {
    return e.raw;
  }
  function ma(e, t2) {
    let u = e ? (r) => e(r, on) : Fa;
    return t2 ? new Proxy(u, { apply: (r, o, n) => de(n[0]) ? pu : Reflect.apply(r, o, n) }) : u;
  }
  function gu(e, t2) {
    if (!t2) throw new Error("parserName is required.");
    let u = du(0, e, (o) => o.parsers && Object.prototype.hasOwnProperty.call(o.parsers, t2));
    if (u) return u;
    let r = `Couldn't resolve parser "${t2}".`;
    throw r += " Plugins must be explicitly added to the standalone bundle.", new Me(r);
  }
  function an(e, t2) {
    if (!t2) throw new Error("astFormat is required.");
    let u = du(0, e, (o) => o.printers && Object.prototype.hasOwnProperty.call(o.printers, t2));
    if (u) return u;
    let r = `Couldn't find plugin for AST format "${t2}".`;
    throw r += " Plugins must be explicitly added to the standalone bundle.", new Me(r);
  }
  function We({ plugins: e, parser: t2 }) {
    let u = gu(e, t2);
    return yu(u, t2);
  }
  function yu(e, t2) {
    let u = e.parsers[t2];
    return typeof u == "function" ? u() : u;
  }
  async function sn(e, t2) {
    let u = e.printers[t2], r = typeof u == "function" ? await u() : u;
    return Ea(r);
  }
  function Ea(e) {
    if (hu.has(e)) return hu.get(e);
    let { features: t2, getVisitorKeys: u, embed: r, massageAstNode: o, print: n, ...a } = e;
    t2 = ya(t2);
    let s = t2.experimental_frontMatterSupport;
    u = Cu(u, s.massageAstNode || s.embed || s.print);
    let i = o;
    o && s.massageAstNode && (i = new Proxy(o, { apply(d, c, p2) {
      return mu(...p2), Reflect.apply(d, c, p2);
    } }));
    let D = r;
    if (r) {
      let d;
      D = new Proxy(r, { get(c, p2, F) {
        return p2 === "getVisitorKeys" ? (d ?? (d = r.getVisitorKeys ? Cu(r.getVisitorKeys, s.massageAstNode || s.embed) : u), d) : Reflect.get(c, p2, F);
      }, apply: (c, p2, F) => s.embed && Ue(...F) ? Fu : Reflect.apply(c, p2, F) });
    }
    let f = n;
    s.print && (f = new Proxy(n, { apply(d, c, p2) {
      let [F] = p2;
      return de(F.node) ? Eu(F) : Reflect.apply(d, c, p2);
    } }));
    let l = { features: t2, getVisitorKeys: u, embed: D, massageAstNode: i, print: f, ...a };
    return hu.set(e, l), l;
  }
  function ga(e) {
    return { ...ha, ...e };
  }
  function ya(e) {
    return { experimental_avoidAstMutation: false, ...e, experimental_frontMatterSupport: ga(e?.experimental_frontMatterSupport) };
  }
  async function ba(e, t2 = {}) {
    let u = { ...e };
    if (!u.parser) if (u.filepath) {
      if (u.parser = st(u, { physicalFile: u.filepath }), !u.parser) throw new Ye(`No parser could be inferred for file "${u.filepath}".`);
    } else throw new Ye("No parser and no file path given, couldn't infer a parser.");
    let r = it({ plugins: e.plugins, showDeprecated: true }).options, o = { ...Dn, ...Object.fromEntries(r.filter((l) => l.default !== void 0).map((l) => [l.name, l.default])) }, n = gu(u.plugins, u.parser), a = await yu(n, u.parser);
    u.astFormat = a.astFormat, u.locEnd = a.locEnd, u.locStart = a.locStart;
    let s = n.printers?.[a.astFormat] ? n : an(u.plugins, a.astFormat), i = await sn(s, a.astFormat);
    u.printer = i, u.getVisitorKeys = i.getVisitorKeys;
    let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, l]) => l !== void 0)) : {}, f = { ...o, ...D };
    for (let [l, d] of Object.entries(f)) (u[l] === null || u[l] === void 0) && (u[l] = d);
    return u.parser === "json" && (u.trailingComma = "none"), un(u, r, { passThrough: Object.keys(Dn), ...t2 });
  }
  function mn(e) {
    return { keyword: e.cyan, capitalized: e.yellow, jsxIdentifier: e.yellow, punctuator: e.yellow, number: e.magenta, string: e.green, regex: e.magenta, comment: e.gray, invalid: It(It(e.white, e.bgRed), e.bold), gutter: e.gray, marker: It(e.red, e.bold), message: It(e.red, e.bold), reset: e.reset };
  }
  function _a2() {
    return new Proxy({}, { get: () => (e) => e });
  }
  function xa(e, t2, u) {
    let r = Object.assign({ column: 0, line: -1 }, e.start), o = Object.assign({}, r, e.end), { linesAbove: n = 2, linesBelow: a = 3 } = u || {}, s = r.line, i = r.column, D = o.line, f = o.column, l = Math.max(s - (n + 1), 0), d = Math.min(t2.length, D + a);
    s === -1 && (l = 0), D === -1 && (d = t2.length);
    let c = D - s, p2 = {};
    if (c) for (let F = 0; F <= c; F++) {
      let C = F + s;
      if (!i) p2[C] = true;
      else if (F === 0) {
        let y = t2[C - 1].length;
        p2[C] = [i, y - i + 1];
      } else if (F === c) p2[C] = [0, f];
      else {
        let y = t2[C - F].length;
        p2[C] = [0, y];
      }
    }
    else i === f ? i ? p2[s] = [i, 0] : p2[s] = true : p2[s] = [i, f - i];
    return { start: l, end: d, markerLines: p2 };
  }
  function En(e, t2, u = {}) {
    let o = _a2(false), n = e.split(Fn), { start: a, end: s, markerLines: i } = xa(t2, n, u), D = t2.start && typeof t2.start.column == "number", f = String(s).length, d = e.split(Fn, s).slice(a, s).map((c, p2) => {
      let F = a + 1 + p2, y = ` ${` ${F}`.slice(-f)} |`, m = i[F], h = !i[F + 1];
      if (m) {
        let E = "";
        if (Array.isArray(m)) {
          let g = c.slice(0, Math.max(m[0] - 1, 0)).replace(/[^\t]/g, " "), A = m[1] || 1;
          E = [`
 `, o.gutter(y.replace(/\d/g, " ")), " ", g, o.marker("^").repeat(A)].join(""), h && u.message && (E += " " + o.message(u.message));
        }
        return [o.marker(">"), o.gutter(y), c.length > 0 ? ` ${c}` : "", E].join("");
      } else return ` ${o.gutter(y)}${c.length > 0 ? ` ${c}` : ""}`;
    }).join(`
`);
    return u.message && !D && (d = `${" ".repeat(f + 1)}${u.message}
${d}`), d;
  }
  async function Ba(e, t2) {
    let u = await We(t2), r = u.preprocess ? await u.preprocess(e, t2) : e;
    t2.originalText = r;
    let o;
    try {
      o = await u.parse(r, t2, t2);
    } catch (n) {
      Ta(n, e);
    }
    return { text: r, ast: o };
  }
  function Ta(e, t2) {
    let { loc: u } = e;
    if (u) {
      let r = En(t2, u, { highlightCode: true });
      throw e.message += `
` + r, e.codeFrame = r, e;
    }
    throw e;
  }
  async function Cn(e, t2, u, r, o) {
    if (u.embeddedLanguageFormatting !== "auto") return;
    let { printer: n } = u, { embed: a } = n;
    if (!a) return;
    if (a.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
    let { hasPrettierIgnore: s } = n, { getVisitorKeys: i } = a, D = [];
    d();
    let f = e.stack;
    for (let { print: c, node: p2, pathStack: F } of D) try {
      e.stack = F;
      let C = await c(l, t2, e, u);
      C && o.set(p2, C);
    } catch (C) {
      if (globalThis.PRETTIER_DEBUG) throw C;
    }
    e.stack = f;
    function l(c, p2) {
      return Na(c, p2, u, r);
    }
    function d() {
      let { node: c } = e;
      if (c === null || typeof c != "object" || s?.(e)) return;
      for (let F of i(c)) Array.isArray(c[F]) ? e.each(d, F) : e.call(d, F);
      let p2 = a(e, u);
      if (p2) {
        if (typeof p2 == "function") {
          D.push({ print: p2, node: c, pathStack: [...e.stack] });
          return;
        }
        o.set(c, p2);
      }
    }
  }
  async function Na(e, t2, u, r) {
    let o = await se({ ...u, ...t2, parentParser: u.parser, originalText: e, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: true }), { ast: n } = await Fe(e, o), a = await r(n, o);
    return qe(a);
  }
  function Sa(e, t2, u, r) {
    let { originalText: o, [Symbol.for("comments")]: n, locStart: a, locEnd: s, [Symbol.for("printedComments")]: i } = t2, { node: D } = e, f = a(D), l = s(D);
    for (let c of n) a(c) >= f && s(c) <= l && i.add(c);
    let { printPrettierIgnored: d } = t2.printer;
    return d ? d(e, t2, u, r) : o.slice(f, l);
  }
  async function Ge(e, t2) {
    ({ ast: e } = await xu(e, t2));
    let u = /* @__PURE__ */ new Map(), r = new pr(e), o = Nr(t2), n = /* @__PURE__ */ new Map();
    await Cn(r, s, t2, Ge, n);
    let a = await gn(r, t2, s, void 0, n);
    if (Tr(t2), t2.cursorOffset >= 0) {
      if (t2.nodeAfterCursor && !t2.nodeBeforeCursor) return [ee, a];
      if (t2.nodeBeforeCursor && !t2.nodeAfterCursor) return [a, ee];
    }
    return a;
    function s(D, f) {
      return D === void 0 || D === r ? i(f) : Array.isArray(D) ? r.call(() => i(f), ...D) : r.call(() => i(f), D);
    }
    function i(D) {
      o(r);
      let f = r.node;
      if (f == null) return "";
      let l = ge(f) && D === void 0;
      if (l && u.has(f)) return u.get(f);
      let d = gn(r, t2, s, D, n);
      return l && u.set(f, d), d;
    }
  }
  function gn(e, t2, u, r, o) {
    let { node: n } = e, { printer: a } = t2, s;
    switch (a.hasPrettierIgnore?.(e) ? s = hn(e, t2, u, r) : o.has(n) ? s = o.get(n) : s = a.print(e, t2, u, r), n) {
      case t2.cursorNode:
        s = Ee(s, (i) => [ee, i, ee]);
        break;
      case t2.nodeBeforeCursor:
        s = Ee(s, (i) => [i, ee]);
        break;
      case t2.nodeAfterCursor:
        s = Ee(s, (i) => [ee, i]);
        break;
    }
    return a.printComment && !a.willPrintOwnComments?.(e, t2) && (s = Br(e, s, t2)), s;
  }
  async function xu(e, t2) {
    let u = e.comments ?? [];
    t2[Symbol.for("comments")] = u, t2[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Ar(e, t2);
    let { printer: { preprocess: r } } = t2;
    return e = r ? await r(e, t2) : e, { ast: e, comments: u };
  }
  function wa(e, t2) {
    let { cursorOffset: u, locStart: r, locEnd: o, getVisitorKeys: n } = t2, a = (c) => r(c) <= u && o(c) >= u, s = e, i = [e];
    for (let c of Cr(e, { getVisitorKeys: n, filter: a })) i.push(c), s = c;
    if (hr(s, { getVisitorKeys: n })) return { cursorNode: s };
    let D, f, l = -1, d = Number.POSITIVE_INFINITY;
    for (; i.length > 0 && (D === void 0 || f === void 0); ) {
      s = i.pop();
      let c = D !== void 0, p2 = f !== void 0;
      for (let F of be(s, { getVisitorKeys: n })) {
        if (!c) {
          let C = o(F);
          C <= u && C > l && (D = F, l = C);
        }
        if (!p2) {
          let C = r(F);
          C >= u && C < d && (f = F, d = C);
        }
      }
    }
    return { nodeBeforeCursor: D, nodeAfterCursor: f };
  }
  function Oa(e, t2) {
    let { printer: u } = t2, r = u.massageAstNode;
    if (!r) return e;
    let { getVisitorKeys: o } = u, { ignoredProperties: n } = r;
    return a(e);
    function a(s, i) {
      if (!ge(s)) return s;
      if (Array.isArray(s)) return s.map((d) => a(d, i)).filter(Boolean);
      let D = {}, f = new Set(o(s));
      for (let d in s) !Object.prototype.hasOwnProperty.call(s, d) || n?.has(d) || (f.has(d) ? D[d] = a(s[d], s) : D[d] = s[d]);
      let l = r(s, D, i);
      if (l !== null) return l ?? D;
    }
  }
  function va(e, t2) {
    return t2 = new Set(t2), e.find((u) => xn.has(u.type) && t2.has(u));
  }
  function An(e) {
    let t2 = bn(0, e, (u) => u.type !== "Program" && u.type !== "File");
    return t2 === -1 ? e : e.slice(0, t2 + 1);
  }
  function Ra(e, t2, { locStart: u, locEnd: r }) {
    let [o, ...n] = e, [a, ...s] = t2;
    if (o === a) return [o, a];
    let i = u(o);
    for (let f of An(s)) if (u(f) >= i) a = f;
    else break;
    let D = r(a);
    for (let f of An(n)) {
      if (r(f) <= D) o = f;
      else break;
      if (o === a) break;
    }
    return [o, a];
  }
  function Tu(e, t2, u, r, o = [], n) {
    let { locStart: a, locEnd: s } = u, i = a(e), D = s(e);
    if (t2 > D || t2 < i || n === "rangeEnd" && t2 === i || n === "rangeStart" && t2 === D) return;
    let f = [e, ...o], l = at(e, f, { cache: uu, locStart: a, locEnd: s, getVisitorKeys: u.getVisitorKeys, filter: u.printer.canAttachComment, getChildren: u.printer.getCommentChildNodes });
    for (let d of l) {
      let c = Tu(d, t2, u, r, f, n);
      if (c) return c;
    }
    if (r(e, o[0])) return f;
  }
  function La(e, t2) {
    return t2 !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
  }
  function _n(e, t2, u) {
    if (!t2) return false;
    switch (e.parser) {
      case "flow":
      case "hermes":
      case "babel":
      case "babel-flow":
      case "babel-ts":
      case "typescript":
      case "acorn":
      case "espree":
      case "meriyah":
      case "oxc":
      case "oxc-ts":
      case "__babel_estree":
        return La(t2.type, u?.type);
      case "json":
      case "json5":
      case "jsonc":
      case "json-stringify":
        return xn.has(t2.type);
      case "graphql":
        return Ma.has(t2.kind);
      case "vue":
        return t2.tag !== "root";
    }
    return false;
  }
  function Bn(e, t2, u) {
    let { rangeStart: r, rangeEnd: o, locStart: n, locEnd: a } = t2;
    P(o > r);
    let s = e.slice(r, o).search(/\S/u), i = s === -1;
    if (!i) for (r += s; o > r && !/\S/u.test(e[o - 1]); --o) ;
    let D = Tu(u, r, t2, (c, p2) => _n(t2, c, p2), [], "rangeStart");
    if (!D) return;
    let f = i ? D : Tu(u, o, t2, (c) => _n(t2, c), [], "rangeEnd");
    if (!f) return;
    let l, d;
    if (ka(t2)) {
      let c = va(D, f);
      l = c, d = c;
    } else [l, d] = Ra(D, f, t2);
    return [Math.min(n(l), n(d)), Math.max(a(l), a(d))];
  }
  async function On(e, t2, u = 0) {
    if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
    let { ast: r, text: o } = await Fe(e, t2);
    t2.cursorOffset >= 0 && (t2 = { ...t2, ...Bu(r, t2) });
    let n = await Ge(r, t2, u);
    u > 0 && (n = tt([V, n], u, t2.tabWidth));
    let a = Ce(n, t2);
    if (u > 0) {
      let i = a.formatted.trim();
      a.cursorNodeStart !== void 0 && (a.cursorNodeStart -= a.formatted.indexOf(i), a.cursorNodeStart < 0 && (a.cursorNodeStart = 0, a.cursorNodeText = a.cursorNodeText.trimStart()), a.cursorNodeStart + a.cursorNodeText.length > i.length && (a.cursorNodeText = a.cursorNodeText.trimEnd())), a.formatted = i + Se(t2.endOfLine);
    }
    let s = t2[Symbol.for("comments")];
    if (t2.cursorOffset >= 0) {
      let i, D, f, l;
      if ((t2.cursorNode || t2.nodeBeforeCursor || t2.nodeAfterCursor) && a.cursorNodeText) if (f = a.cursorNodeStart, l = a.cursorNodeText, t2.cursorNode) i = t2.locStart(t2.cursorNode), D = o.slice(i, t2.locEnd(t2.cursorNode));
      else {
        if (!t2.nodeBeforeCursor && !t2.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
        i = t2.nodeBeforeCursor ? t2.locEnd(t2.nodeBeforeCursor) : 0;
        let y = t2.nodeAfterCursor ? t2.locStart(t2.nodeAfterCursor) : o.length;
        D = o.slice(i, y);
      }
      else i = 0, D = o, f = 0, l = a.formatted;
      let d = t2.cursorOffset - i;
      if (D === l) return { formatted: a.formatted, cursorOffset: f + d, comments: s };
      let c = D.split("");
      c.splice(d, 0, Tn);
      let p2 = l.split(""), F = Ut(c, p2), C = f;
      for (let y of F) if (y.removed) {
        if (y.value.includes(Tn)) break;
      } else C += y.count;
      return { formatted: a.formatted, cursorOffset: C, comments: s };
    }
    return { formatted: a.formatted, cursorOffset: -1, comments: s };
  }
  async function Ya(e, t2) {
    let { ast: u, text: r } = await Fe(e, t2), [o, n] = Bn(r, t2, u) ?? [0, 0], a = r.slice(o, n), s = Math.min(o, r.lastIndexOf(`
`, o) + 1), i = r.slice(s, o).match(/^\s*/u)[0], D = he(i, t2.tabWidth), f = await On(a, { ...t2, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t2.cursorOffset > o && t2.cursorOffset <= n ? t2.cursorOffset - o : -1, endOfLine: "lf" }, D), l = f.formatted.trimEnd(), { cursorOffset: d } = t2;
    d > n ? d += l.length - a.length : f.cursorOffset >= 0 && (d = f.cursorOffset + o);
    let c = r.slice(0, o) + l + r.slice(n);
    if (t2.endOfLine !== "lf") {
      let p2 = Se(t2.endOfLine);
      d >= 0 && p2 === `\r
` && (d += $t(c.slice(0, d), `
`)), c = oe(0, c, `
`, p2);
    }
    return { formatted: c, cursorOffset: d, comments: f.comments };
  }
  function Nu(e, t2, u) {
    return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e.length ? u : t2;
  }
  function Nn(e, t2) {
    let { cursorOffset: u, rangeStart: r, rangeEnd: o } = t2;
    return u = Nu(e, u, -1), r = Nu(e, r, 0), o = Nu(e, o, e.length), { ...t2, cursorOffset: u, rangeStart: r, rangeEnd: o };
  }
  function Pn(e, t2) {
    let { cursorOffset: u, rangeStart: r, rangeEnd: o, endOfLine: n } = Nn(e, t2), a = e.charAt(0) === wn;
    if (a && (e = e.slice(1), u--, r--, o--), n === "auto" && (n = Yu(e)), e.includes("\r")) {
      let s = (i) => $t(e.slice(0, Math.max(i, 0)), `\r
`);
      u -= s(u), r -= s(r), o -= s(o), e = ju(e);
    }
    return { hasBOM: a, text: e, options: Nn(e, { ...t2, cursorOffset: u, rangeStart: r, rangeEnd: o, endOfLine: n }) };
  }
  async function Sn(e, t2) {
    let u = await We(t2);
    return !u.hasPragma || u.hasPragma(e);
  }
  async function ja(e, t2) {
    return (await We(t2)).hasIgnorePragma?.(e);
  }
  async function Su(e, t2) {
    let { hasBOM: u, text: r, options: o } = Pn(e, await se(t2));
    if (o.rangeStart >= o.rangeEnd && r !== "" || o.requirePragma && !await Sn(r, o) || o.checkIgnorePragma && await ja(r, o)) return { formatted: e, cursorOffset: t2.cursorOffset, comments: [] };
    let n;
    return o.rangeStart > 0 || o.rangeEnd < r.length ? n = await Ya(r, o) : (!o.requirePragma && o.insertPragma && o.printer.insertPragma && !await Sn(r, o) && (r = o.printer.insertPragma(r)), n = await On(r, o)), u && (n.formatted = wn + n.formatted, n.cursorOffset >= 0 && n.cursorOffset++), n;
  }
  async function In(e, t2, u) {
    let { text: r, options: o } = Pn(e, await se(t2)), n = await Fe(r, o);
    return u && (u.preprocessForPrint && (n.ast = await xu(n.ast, o)), u.massage && (n.ast = yn(n.ast, o))), n;
  }
  async function kn(e, t2) {
    t2 = await se(t2);
    let u = await Ge(e, t2);
    return Ce(u, t2);
  }
  async function vn(e, t2) {
    let u = sr(e), { formatted: r } = await Su(u, { ...t2, parser: "__js_expression" });
    return r;
  }
  async function Rn(e, t2) {
    t2 = await se(t2);
    let { ast: u } = await Fe(e, t2);
    return t2.cursorOffset >= 0 && (t2 = { ...t2, ...Bu(u, t2) }), Ge(u, t2);
  }
  async function Ln(e, t2) {
    return Ce(e, await se(t2));
  }
  function Ka(e, t2) {
    if (t2 === false) return false;
    if (e.charAt(t2) === "/" && e.charAt(t2 + 1) === "*") {
      for (let u = t2 + 2; u < e.length; ++u) if (e.charAt(u) === "*" && e.charAt(u + 1) === "/") return u + 2;
    }
    return t2;
  }
  function Ga(e, t2) {
    return t2 === false ? false : e.charAt(t2) === "/" && e.charAt(t2 + 1) === "/" ? ot(e, t2) : t2;
  }
  function za(e, t2) {
    let u = null, r = t2;
    for (; r !== u; ) u = r, r = Y(e, r), r = xe(e, r), r = Be(e, r), r = K(e, r);
    return r;
  }
  function Ja(e, t2) {
    let u = null, r = t2;
    for (; r !== u; ) u = r, r = nt(e, r), r = xe(e, r), r = Y(e, r);
    return r = Be(e, r), r = K(e, r), r !== false && z(e, r);
  }
  function Ha(e, t2) {
    let u = e.lastIndexOf(`
`);
    return u === -1 ? 0 : he(e.slice(u + 1).match(/^[\t ]*/u)[0], t2);
  }
  function Ou(e) {
    if (typeof e != "string") throw new TypeError("Expected a string");
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  function Xa(e, t2) {
    let u = e.matchAll(new RegExp(`(?:${Ou(t2)})+`, "gu"));
    return u.reduce || (u = [...u]), u.reduce((r, [o]) => Math.max(r, o.length), 0) / t2.length;
  }
  function qa(e, t2) {
    let u = ze(e, t2);
    return u === false ? "" : e.charAt(u);
  }
  function ei(e, t2) {
    let { preferred: u, alternate: r } = t2 === true || t2 === "'" ? Qa : Za, { length: o } = e, n = 0, a = 0;
    for (let s = 0; s < o; s++) {
      let i = e.charCodeAt(s);
      i === u.codePoint ? n++ : i === r.codePoint && a++;
    }
    return (n > a ? r : u).character;
  }
  function ti(e, t2, u) {
    for (let r = t2; r < u; ++r) if (e.charAt(r) === `
`) return true;
    return false;
  }
  function ui(e, t2, u = {}) {
    return Y(e, u.backwards ? t2 - 1 : t2, u) !== t2;
  }
  function ri(e, t2, u) {
    return ze(e, u(t2));
  }
  function ni(e, t2) {
    return arguments.length === 2 || typeof t2 == "number" ? ze(e, t2) : ri(...arguments);
  }
  function oi(e, t2, u) {
    return Le(e, u(t2));
  }
  function ai(e, t2) {
    return arguments.length === 2 || typeof t2 == "number" ? Le(e, t2) : oi(...arguments);
  }
  function ii(e, t2, u) {
    return kt(e, u(t2));
  }
  function si(e, t2, u) {
    let r = t2 === '"' ? "'" : '"', n = oe(0, e, /\\(.)|(["'])/gsu, (a, s, i) => s === r ? s : i === t2 ? "\\" + i : i || (u && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
    return t2 + n + t2;
  }
  function Di(e, t2) {
    return arguments.length === 2 || typeof t2 == "number" ? kt(e, t2) : ii(...arguments);
  }
  function me(e, t2 = 1) {
    return async (...u) => {
      let r = u[t2] ?? {}, o = r.plugins ?? [];
      return u[t2] = { ...r, plugins: Array.isArray(o) ? o : Object.values(o) }, e(...u);
    };
  }
  async function Jn(e, t2) {
    let { formatted: u } = await zn(e, { ...t2, cursorOffset: -1 });
    return u;
  }
  async function ci(e, t2) {
    return await Jn(e, t2) === e;
  }
  var Zn, Mt, eo, to, uo, ro, no, Yt, oo, ao, dn, Hn, X, io, so, oe, Ne, jt, ku, Do, P, Ru, Lu, co, fo, Wt, Mu, Je, lo, po, Fo, Eo, b, G, j, U, I, k, v, x, w, B, R, L, M, _, O, T, He, H, ho, Vt, Z, Wu, we, N, Ze, Xu, qu, ce, ee, ut, or, ke, V, Gt, Qe, ar, ir, Dr, cr, To, No, Re, wo, Oo, Ht, W, q, qt, he, Qt, pr, ge, Fr, Y, nt, ot, mr, K, z, Er, at, uu, eu, _r, Le, Nr, Me, Ye, Sr, zo, Jo, wr, Xo, Pr, Ir, ea, st, ie, nu, $, ou, Rr, Dt, Ae, Lr, Yr, _e, au, ft, ua, S, lt, dt, pt, Ft, Et, Ct, ht, je, Qr, Zr, en, tn, gt, lu, un, ca, fa, du, rn, pu, de, nn, Ue, mu, Eu, on, Fa, Cu, hu, q0, Ca, ha, Dn, se, pf, Au, pn, af, sf, _u, Df, cf, ff, It, hf, gf, Fn, Fe, hn, Bu, yn, Pa, Ia, bn, ka, xn, Ma, wn, Tn, wu, Wa, $a, Va, Mn, Pu, xe, Be, ze, kt, Yn, jn, Un, Wn, $n, Qa, Za, Vn, Kn, Gn, zn, fi, li;
  var init_standalone = __esm({
    "node_modules/prettier/standalone.mjs"() {
      Zn = Object.create;
      Mt = Object.defineProperty;
      eo = Object.getOwnPropertyDescriptor;
      to = Object.getOwnPropertyNames;
      uo = Object.getPrototypeOf;
      ro = Object.prototype.hasOwnProperty;
      no = (e, t2) => () => (t2 || e((t2 = { exports: {} }).exports, t2), t2.exports);
      Yt = (e, t2) => {
        for (var u in t2) Mt(e, u, { get: t2[u], enumerable: true });
      };
      oo = (e, t2, u, r) => {
        if (t2 && typeof t2 == "object" || typeof t2 == "function") for (let o of to(t2)) !ro.call(e, o) && o !== u && Mt(e, o, { get: () => t2[o], enumerable: !(r = eo(t2, o)) || r.enumerable });
        return e;
      };
      ao = (e, t2, u) => (u = e != null ? Zn(uo(e)) : {}, oo(t2 || !e || !e.__esModule ? Mt(u, "default", { value: e, enumerable: true }) : u, e));
      dn = no((of, ln) => {
        var yt, bt, At, _t, xt, $e, bu, Ke, Bt, cn, Tt, Ve, Nt, St, wt, pe, fn, Ot, Pt, Aa;
        Nt = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
        Ve = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
        yt = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
        wt = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
        Tt = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
        pe = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
        Pt = /[\t\v\f\ufeff\p{Zs}]+/yu;
        Ke = /\r?\n|[\r\u2028\u2029]/y;
        Bt = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
        St = /\/\/.*/y;
        At = /[<>.:={}]|\/(?![\/*])/y;
        bt = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
        _t = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
        xt = /[^<>{}]+/y;
        Ot = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
        fn = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
        $e = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
        bu = /^(?:return|throw|yield)$/;
        cn = RegExp(Ke.source);
        ln.exports = Aa = function* (e, { jsx: t2 = false } = {}) {
          var u, r, o, n, a, s, i, D, f, l, d, c, p2, F;
          for ({ length: s } = e, n = 0, a = "", F = [{ tag: "JS" }], u = [], d = 0, c = false; n < s; ) {
            switch (D = F[F.length - 1], D.tag) {
              case "JS":
              case "JSNonExpressionParen":
              case "InterpolationInTemplate":
              case "InterpolationInJSX":
                if (e[n] === "/" && (Ot.test(a) || $e.test(a)) && (Nt.lastIndex = n, i = Nt.exec(e))) {
                  n = Nt.lastIndex, a = i[0], c = true, yield { type: "RegularExpressionLiteral", value: i[0], closed: i[1] !== void 0 && i[1] !== "\\" };
                  continue;
                }
                if (Ve.lastIndex = n, i = Ve.exec(e)) {
                  switch (p2 = i[0], f = Ve.lastIndex, l = p2, p2) {
                    case "(":
                      a === "?NonExpressionParenKeyword" && F.push({ tag: "JSNonExpressionParen", nesting: d }), d++, c = false;
                      break;
                    case ")":
                      d--, c = true, D.tag === "JSNonExpressionParen" && d === D.nesting && (F.pop(), l = "?NonExpressionParenEnd", c = false);
                      break;
                    case "{":
                      Ve.lastIndex = 0, o = !fn.test(a) && (Ot.test(a) || $e.test(a)), u.push(o), c = false;
                      break;
                    case "}":
                      switch (D.tag) {
                        case "InterpolationInTemplate":
                          if (u.length === D.nesting) {
                            pe.lastIndex = n, i = pe.exec(e), n = pe.lastIndex, a = i[0], i[1] === "${" ? (a = "?InterpolationInTemplate", c = false, yield { type: "TemplateMiddle", value: i[0] }) : (F.pop(), c = true, yield { type: "TemplateTail", value: i[0], closed: i[1] === "`" });
                            continue;
                          }
                          break;
                        case "InterpolationInJSX":
                          if (u.length === D.nesting) {
                            F.pop(), n += 1, a = "}", yield { type: "JSXPunctuator", value: "}" };
                            continue;
                          }
                      }
                      c = u.pop(), l = c ? "?ExpressionBraceEnd" : "}";
                      break;
                    case "]":
                      c = true;
                      break;
                    case "++":
                    case "--":
                      l = c ? "?PostfixIncDec" : "?UnaryIncDec";
                      break;
                    case "<":
                      if (t2 && (Ot.test(a) || $e.test(a))) {
                        F.push({ tag: "JSXTag" }), n += 1, a = "<", yield { type: "JSXPunctuator", value: p2 };
                        continue;
                      }
                      c = false;
                      break;
                    default:
                      c = false;
                  }
                  n = f, a = l, yield { type: "Punctuator", value: p2 };
                  continue;
                }
                if (yt.lastIndex = n, i = yt.exec(e)) {
                  switch (n = yt.lastIndex, l = i[0], i[0]) {
                    case "for":
                    case "if":
                    case "while":
                    case "with":
                      a !== "." && a !== "?." && (l = "?NonExpressionParenKeyword");
                  }
                  a = l, c = !$e.test(i[0]), yield { type: i[1] === "#" ? "PrivateIdentifier" : "IdentifierName", value: i[0] };
                  continue;
                }
                if (wt.lastIndex = n, i = wt.exec(e)) {
                  n = wt.lastIndex, a = i[0], c = true, yield { type: "StringLiteral", value: i[0], closed: i[2] !== void 0 };
                  continue;
                }
                if (Tt.lastIndex = n, i = Tt.exec(e)) {
                  n = Tt.lastIndex, a = i[0], c = true, yield { type: "NumericLiteral", value: i[0] };
                  continue;
                }
                if (pe.lastIndex = n, i = pe.exec(e)) {
                  n = pe.lastIndex, a = i[0], i[1] === "${" ? (a = "?InterpolationInTemplate", F.push({ tag: "InterpolationInTemplate", nesting: u.length }), c = false, yield { type: "TemplateHead", value: i[0] }) : (c = true, yield { type: "NoSubstitutionTemplate", value: i[0], closed: i[1] === "`" });
                  continue;
                }
                break;
              case "JSXTag":
              case "JSXTagEnd":
                if (At.lastIndex = n, i = At.exec(e)) {
                  switch (n = At.lastIndex, l = i[0], i[0]) {
                    case "<":
                      F.push({ tag: "JSXTag" });
                      break;
                    case ">":
                      F.pop(), a === "/" || D.tag === "JSXTagEnd" ? (l = "?JSX", c = true) : F.push({ tag: "JSXChildren" });
                      break;
                    case "{":
                      F.push({ tag: "InterpolationInJSX", nesting: u.length }), l = "?InterpolationInJSX", c = false;
                      break;
                    case "/":
                      a === "<" && (F.pop(), F[F.length - 1].tag === "JSXChildren" && F.pop(), F.push({ tag: "JSXTagEnd" }));
                  }
                  a = l, yield { type: "JSXPunctuator", value: i[0] };
                  continue;
                }
                if (bt.lastIndex = n, i = bt.exec(e)) {
                  n = bt.lastIndex, a = i[0], yield { type: "JSXIdentifier", value: i[0] };
                  continue;
                }
                if (_t.lastIndex = n, i = _t.exec(e)) {
                  n = _t.lastIndex, a = i[0], yield { type: "JSXString", value: i[0], closed: i[2] !== void 0 };
                  continue;
                }
                break;
              case "JSXChildren":
                if (xt.lastIndex = n, i = xt.exec(e)) {
                  n = xt.lastIndex, a = i[0], yield { type: "JSXText", value: i[0] };
                  continue;
                }
                switch (e[n]) {
                  case "<":
                    F.push({ tag: "JSXTag" }), n++, a = "<", yield { type: "JSXPunctuator", value: "<" };
                    continue;
                  case "{":
                    F.push({ tag: "InterpolationInJSX", nesting: u.length }), n++, a = "?InterpolationInJSX", c = false, yield { type: "JSXPunctuator", value: "{" };
                    continue;
                }
            }
            if (Pt.lastIndex = n, i = Pt.exec(e)) {
              n = Pt.lastIndex, yield { type: "WhiteSpace", value: i[0] };
              continue;
            }
            if (Ke.lastIndex = n, i = Ke.exec(e)) {
              n = Ke.lastIndex, c = false, bu.test(a) && (a = "?NoLineTerminatorHere"), yield { type: "LineTerminatorSequence", value: i[0] };
              continue;
            }
            if (Bt.lastIndex = n, i = Bt.exec(e)) {
              n = Bt.lastIndex, cn.test(i[0]) && (c = false, bu.test(a) && (a = "?NoLineTerminatorHere")), yield { type: "MultiLineComment", value: i[0], closed: i[1] !== void 0 };
              continue;
            }
            if (St.lastIndex = n, i = St.exec(e)) {
              n = St.lastIndex, c = false, yield { type: "SingleLineComment", value: i[0] };
              continue;
            }
            r = String.fromCodePoint(e.codePointAt(n)), n += r.length, a = r, c = false, yield { type: D.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid", value: r };
          }
        };
      });
      Hn = {};
      Yt(Hn, { __debug: () => li, check: () => ci, doc: () => wu, format: () => Jn, formatWithCursor: () => zn, getSupportInfo: () => fi, util: () => Pu, version: () => Mn });
      X = (e, t2) => (u, r, ...o) => u | 1 && r == null ? void 0 : (t2.call(r) ?? r[e]).apply(r, o);
      io = String.prototype.replaceAll ?? function(e, t2) {
        return e.global ? this.replace(e, t2) : this.split(e).join(t2);
      };
      so = X("replaceAll", function() {
        if (typeof this == "string") return io;
      });
      oe = so;
      Ne = class {
        diff(t2, u, r = {}) {
          let o;
          typeof r == "function" ? (o = r, r = {}) : "callback" in r && (o = r.callback);
          let n = this.castInput(t2, r), a = this.castInput(u, r), s = this.removeEmpty(this.tokenize(n, r)), i = this.removeEmpty(this.tokenize(a, r));
          return this.diffWithOptionsObj(s, i, r, o);
        }
        diffWithOptionsObj(t2, u, r, o) {
          var n;
          let a = (m) => {
            if (m = this.postProcess(m, r), o) {
              setTimeout(function() {
                o(m);
              }, 0);
              return;
            } else return m;
          }, s = u.length, i = t2.length, D = 1, f = s + i;
          r.maxEditLength != null && (f = Math.min(f, r.maxEditLength));
          let l = (n = r.timeout) !== null && n !== void 0 ? n : 1 / 0, d = Date.now() + l, c = [{ oldPos: -1, lastComponent: void 0 }], p2 = this.extractCommon(c[0], u, t2, 0, r);
          if (c[0].oldPos + 1 >= i && p2 + 1 >= s) return a(this.buildValues(c[0].lastComponent, u, t2));
          let F = -1 / 0, C = 1 / 0, y = () => {
            for (let m = Math.max(F, -D); m <= Math.min(C, D); m += 2) {
              let h, E = c[m - 1], g = c[m + 1];
              E && (c[m - 1] = void 0);
              let A = false;
              if (g) {
                let Q = g.oldPos - m;
                A = g && 0 <= Q && Q < s;
              }
              let J = E && E.oldPos + 1 < i;
              if (!A && !J) {
                c[m] = void 0;
                continue;
              }
              if (!J || A && E.oldPos < g.oldPos ? h = this.addToPath(g, true, false, 0, r) : h = this.addToPath(E, false, true, 1, r), p2 = this.extractCommon(h, u, t2, m, r), h.oldPos + 1 >= i && p2 + 1 >= s) return a(this.buildValues(h.lastComponent, u, t2)) || true;
              c[m] = h, h.oldPos + 1 >= i && (C = Math.min(C, m - 1)), p2 + 1 >= s && (F = Math.max(F, m + 1));
            }
            D++;
          };
          if (o) (function m() {
            setTimeout(function() {
              if (D > f || Date.now() > d) return o(void 0);
              y() || m();
            }, 0);
          })();
          else for (; D <= f && Date.now() <= d; ) {
            let m = y();
            if (m) return m;
          }
        }
        addToPath(t2, u, r, o, n) {
          let a = t2.lastComponent;
          return a && !n.oneChangePerToken && a.added === u && a.removed === r ? { oldPos: t2.oldPos + o, lastComponent: { count: a.count + 1, added: u, removed: r, previousComponent: a.previousComponent } } : { oldPos: t2.oldPos + o, lastComponent: { count: 1, added: u, removed: r, previousComponent: a } };
        }
        extractCommon(t2, u, r, o, n) {
          let a = u.length, s = r.length, i = t2.oldPos, D = i - o, f = 0;
          for (; D + 1 < a && i + 1 < s && this.equals(r[i + 1], u[D + 1], n); ) D++, i++, f++, n.oneChangePerToken && (t2.lastComponent = { count: 1, previousComponent: t2.lastComponent, added: false, removed: false });
          return f && !n.oneChangePerToken && (t2.lastComponent = { count: f, previousComponent: t2.lastComponent, added: false, removed: false }), t2.oldPos = i, D;
        }
        equals(t2, u, r) {
          return r.comparator ? r.comparator(t2, u) : t2 === u || !!r.ignoreCase && t2.toLowerCase() === u.toLowerCase();
        }
        removeEmpty(t2) {
          let u = [];
          for (let r = 0; r < t2.length; r++) t2[r] && u.push(t2[r]);
          return u;
        }
        castInput(t2, u) {
          return t2;
        }
        tokenize(t2, u) {
          return Array.from(t2);
        }
        join(t2) {
          return t2.join("");
        }
        postProcess(t2, u) {
          return t2;
        }
        get useLongestToken() {
          return false;
        }
        buildValues(t2, u, r) {
          let o = [], n;
          for (; t2; ) o.push(t2), n = t2.previousComponent, delete t2.previousComponent, t2 = n;
          o.reverse();
          let a = o.length, s = 0, i = 0, D = 0;
          for (; s < a; s++) {
            let f = o[s];
            if (f.removed) f.value = this.join(r.slice(D, D + f.count)), D += f.count;
            else {
              if (!f.added && this.useLongestToken) {
                let l = u.slice(i, i + f.count);
                l = l.map(function(d, c) {
                  let p2 = r[D + c];
                  return p2.length > d.length ? p2 : d;
                }), f.value = this.join(l);
              } else f.value = this.join(u.slice(i, i + f.count));
              i += f.count, f.added || (D += f.count);
            }
          }
          return o;
        }
      };
      jt = class extends Ne {
        tokenize(t2) {
          return t2.slice();
        }
        join(t2) {
          return t2;
        }
        removeEmpty(t2) {
          return t2;
        }
      };
      ku = new jt();
      Do = () => {
      };
      P = Do;
      Ru = "cr";
      Lu = "crlf";
      co = "lf";
      fo = co;
      Wt = "\r";
      Mu = `\r
`;
      Je = `
`;
      lo = Je;
      po = /* @__PURE__ */ new Map([[Je, /\n/gu], [Wt, /\r/gu], [Mu, /\r\n/gu]]);
      Fo = /\r\n?/gu;
      Eo = X("at", function() {
        if (Array.isArray(this) || typeof this == "string") return mo;
      });
      b = Eo;
      G = "string";
      j = "array";
      U = "cursor";
      I = "indent";
      k = "align";
      v = "trim";
      x = "group";
      w = "fill";
      B = "if-break";
      R = "indent-if-break";
      L = "line-suffix";
      M = "line-suffix-boundary";
      _ = "line";
      O = "label";
      T = "break-parent";
      He = /* @__PURE__ */ new Set([U, I, k, v, x, w, B, R, L, M, _, O, T]);
      H = Co;
      ho = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
      Vt = class extends Error {
        name = "InvalidDocError";
        constructor(t2) {
          super(go(t2)), this.doc = t2;
        }
      };
      Z = Vt;
      Wu = {};
      we = yo;
      N = P;
      Ze = P;
      Xu = P;
      qu = P;
      ce = { type: T };
      ee = { type: U };
      ut = { type: _ };
      or = { type: _, soft: true };
      ke = { type: _, hard: true };
      V = [ke, ce];
      Gt = { type: _, hard: true, literal: true };
      Qe = [Gt, ce];
      ar = { type: M };
      ir = { type: v };
      Dr = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
      cr = "\xA9\xAE\u203C\u2049\u2122\u2139\u2194\u2195\u2196\u2197\u2198\u2199\u21A9\u21AA\u2328\u23CF\u23F1\u23F2\u23F8\u23F9\u23FA\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600\u2601\u2602\u2603\u2604\u260E\u2611\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638\u2639\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694\u2695\u2696\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F1\u26F7\u26F8\u26F9\u2702\u2708\u2709\u270C\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u2764\u27A1\u2934\u2935\u2B05\u2B06\u2B07";
      To = /[^\x20-\x7F]/u;
      No = new Set(cr);
      Re = So;
      wo = { type: 0 };
      Oo = { type: 1 };
      Ht = { value: "", length: 0, queue: [], get root() {
        return Ht;
      } };
      W = Symbol("MODE_BREAK");
      q = Symbol("MODE_FLAT");
      qt = Symbol("DOC_FILL_PRINTED_LENGTH");
      he = Io;
      Qt = class {
        constructor(t2) {
          this.stack = [t2];
        }
        get key() {
          let { stack: t2, siblings: u } = this;
          return b(0, t2, u === null ? -2 : -4) ?? null;
        }
        get index() {
          return this.siblings === null ? null : b(0, this.stack, -2);
        }
        get node() {
          return b(0, this.stack, -1);
        }
        get parent() {
          return this.getNode(1);
        }
        get grandparent() {
          return this.getNode(2);
        }
        get isInArray() {
          return this.siblings !== null;
        }
        get siblings() {
          let { stack: t2 } = this, u = b(0, t2, -3);
          return Array.isArray(u) ? u : null;
        }
        get next() {
          let { siblings: t2 } = this;
          return t2 === null ? null : t2[this.index + 1];
        }
        get previous() {
          let { siblings: t2 } = this;
          return t2 === null ? null : t2[this.index - 1];
        }
        get isFirst() {
          return this.index === 0;
        }
        get isLast() {
          let { siblings: t2, index: u } = this;
          return t2 !== null && u === t2.length - 1;
        }
        get isRoot() {
          return this.stack.length === 1;
        }
        get root() {
          return this.stack[0];
        }
        get ancestors() {
          return [...this.#e()];
        }
        getName() {
          let { stack: t2 } = this, { length: u } = t2;
          return u > 1 ? b(0, t2, -2) : null;
        }
        getValue() {
          return b(0, this.stack, -1);
        }
        getNode(t2 = 0) {
          let u = this.#t(t2);
          return u === -1 ? null : this.stack[u];
        }
        getParentNode(t2 = 0) {
          return this.getNode(t2 + 1);
        }
        #t(t2) {
          let { stack: u } = this;
          for (let r = u.length - 1; r >= 0; r -= 2) if (!Array.isArray(u[r]) && --t2 < 0) return r;
          return -1;
        }
        call(t2, ...u) {
          let { stack: r } = this, { length: o } = r, n = b(0, r, -1);
          for (let a of u) n = n?.[a], r.push(a, n);
          try {
            return t2(this);
          } finally {
            r.length = o;
          }
        }
        callParent(t2, u = 0) {
          let r = this.#t(u + 1), o = this.stack.splice(r + 1);
          try {
            return t2(this);
          } finally {
            this.stack.push(...o);
          }
        }
        each(t2, ...u) {
          let { stack: r } = this, { length: o } = r, n = b(0, r, -1);
          for (let a of u) n = n[a], r.push(a, n);
          try {
            for (let a = 0; a < n.length; ++a) r.push(a, n[a]), t2(this, a, n), r.length -= 2;
          } finally {
            r.length = o;
          }
        }
        map(t2, ...u) {
          let r = [];
          return this.each((o, n, a) => {
            r[n] = t2(o, n, a);
          }, ...u), r;
        }
        match(...t2) {
          let u = this.stack.length - 1, r = null, o = this.stack[u--];
          for (let n of t2) {
            if (o === void 0) return false;
            let a = null;
            if (typeof r == "number" && (a = r, r = this.stack[u--], o = this.stack[u--]), n && !n(o, r, a)) return false;
            r = this.stack[u--], o = this.stack[u--];
          }
          return true;
        }
        findAncestor(t2) {
          for (let u of this.#e()) if (t2(u)) return u;
        }
        hasAncestor(t2) {
          for (let u of this.#e()) if (t2(u)) return true;
          return false;
        }
        *#e() {
          let { stack: t2 } = this;
          for (let u = t2.length - 3; u >= 0; u -= 2) {
            let r = t2[u];
            Array.isArray(r) || (yield r);
          }
        }
      };
      pr = Qt;
      ge = ko;
      Fr = ye(/\s/u);
      Y = ye(" 	");
      nt = ye(",; 	");
      ot = ye(/[^\n\r]/u);
      mr = (e) => e === `
` || e === "\r" || e === "\u2028" || e === "\u2029";
      K = vo;
      z = Ro;
      Er = Lo;
      at = gr;
      uu = /* @__PURE__ */ new WeakMap();
      eu = () => false;
      _r = (e) => !/[\S\n\u2028\u2029]/u.test(e);
      Le = Uo;
      Nr = () => P;
      Me = class extends Error {
        name = "ConfigError";
      };
      Ye = class extends Error {
        name = "UndefinedParserError";
      };
      Sr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
      zo = Array.prototype.toReversed ?? function() {
        return [...this].reverse();
      };
      Jo = X("toReversed", function() {
        if (Array.isArray(this)) return zo;
      });
      wr = Jo;
      Xo = Ho();
      Pr = (e) => String(e).split(/[/\\]/u).pop();
      Ir = (e) => String(e).startsWith("file:");
      ea = void 0;
      st = ta;
      ie = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
        if (e === null || typeof e != "object") return JSON.stringify(e);
        if (Array.isArray(e)) return `[${e.map((u) => ie.value(u)).join(", ")}]`;
        let t2 = Object.keys(e);
        return t2.length === 0 ? "{}" : `{ ${t2.map((u) => `${ie.key(u)}: ${ie.value(e[u])}`).join(", ")} }`;
      }, pair: ({ key: e, value: t2 }) => ie.value({ [e]: t2 }) };
      nu = new Proxy(String, { get: () => nu });
      $ = nu;
      ou = () => nu;
      Rr = (e, t2, { descriptor: u }) => {
        let r = [`${$.yellow(typeof e == "string" ? u.key(e) : u.pair(e))} is deprecated`];
        return t2 && r.push(`we now treat it as ${$.blue(typeof t2 == "string" ? u.key(t2) : u.pair(t2))}`), r.join("; ") + ".";
      };
      Dt = Symbol.for("vnopts.VALUE_NOT_EXIST");
      Ae = Symbol.for("vnopts.VALUE_UNCHANGED");
      Lr = " ".repeat(2);
      Yr = (e, t2, u) => {
        let { text: r, list: o } = u.normalizeExpectedResult(u.schemas[e].expected(u)), n = [];
        return r && n.push(Mr(e, t2, r, u.descriptor)), o && n.push([Mr(e, t2, o.title, u.descriptor)].concat(o.values.map((a) => jr(a, u.loggerPrintWidth))).join(`
`)), Ur(n, u.loggerPrintWidth);
      };
      _e = [];
      au = [];
      ft = (e, t2, { descriptor: u, logger: r, schemas: o }) => {
        let n = [`Ignored unknown option ${$.yellow(u.pair({ key: e, value: t2 }))}.`], a = Wr(e, Object.keys(o), { maxDistance: 3 });
        a && n.push(`Did you mean ${$.blue(u.key(a))}?`), r.warn(n.join(" "));
      };
      ua = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
      S = class {
        static create(t2) {
          return ra(this, t2);
        }
        constructor(t2) {
          this.name = t2.name;
        }
        default(t2) {
        }
        expected(t2) {
          return "nothing";
        }
        validate(t2, u) {
          return false;
        }
        deprecated(t2, u) {
          return false;
        }
        forward(t2, u) {
        }
        redirect(t2, u) {
        }
        overlap(t2, u, r) {
          return t2;
        }
        preprocess(t2, u) {
          return t2;
        }
        postprocess(t2, u) {
          return Ae;
        }
      };
      lt = class extends S {
        constructor(t2) {
          super(t2), this._sourceName = t2.sourceName;
        }
        expected(t2) {
          return t2.schemas[this._sourceName].expected(t2);
        }
        validate(t2, u) {
          return u.schemas[this._sourceName].validate(t2, u);
        }
        redirect(t2, u) {
          return this._sourceName;
        }
      };
      dt = class extends S {
        expected() {
          return "anything";
        }
        validate() {
          return true;
        }
      };
      pt = class extends S {
        constructor({ valueSchema: t2, name: u = t2.name, ...r }) {
          super({ ...r, name: u }), this._valueSchema = t2;
        }
        expected(t2) {
          let { text: u, list: r } = t2.normalizeExpectedResult(this._valueSchema.expected(t2));
          return { text: u && `an array of ${u}`, list: r && { title: "an array of the following values", values: [{ list: r }] } };
        }
        validate(t2, u) {
          if (!Array.isArray(t2)) return false;
          let r = [];
          for (let o of t2) {
            let n = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
            n !== true && r.push(n.value);
          }
          return r.length === 0 ? true : { value: r };
        }
        deprecated(t2, u) {
          let r = [];
          for (let o of t2) {
            let n = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
            n !== false && r.push(...n.map(({ value: a }) => ({ value: [a] })));
          }
          return r;
        }
        forward(t2, u) {
          let r = [];
          for (let o of t2) {
            let n = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
            r.push(...n.map($r));
          }
          return r;
        }
        redirect(t2, u) {
          let r = [], o = [];
          for (let n of t2) {
            let a = u.normalizeRedirectResult(this._valueSchema.redirect(n, u), n);
            "remain" in a && r.push(a.remain), o.push(...a.redirect.map($r));
          }
          return r.length === 0 ? { redirect: o } : { redirect: o, remain: r };
        }
        overlap(t2, u) {
          return t2.concat(u);
        }
      };
      Ft = class extends S {
        expected() {
          return "true or false";
        }
        validate(t2) {
          return typeof t2 == "boolean";
        }
      };
      Et = class extends S {
        constructor(t2) {
          super(t2), this._choices = Gr(t2.choices.map((u) => u && typeof u == "object" ? u : { value: u }), "value");
        }
        expected({ descriptor: t2 }) {
          let u = Array.from(this._choices.keys()).map((a) => this._choices.get(a)).filter(({ hidden: a }) => !a).map((a) => a.value).sort(Xr).map(t2.value), r = u.slice(0, -2), o = u.slice(-2);
          return { text: r.concat(o.join(" or ")).join(", "), list: { title: "one of the following values", values: u } };
        }
        validate(t2) {
          return this._choices.has(t2);
        }
        deprecated(t2) {
          let u = this._choices.get(t2);
          return u && u.deprecated ? { value: t2 } : false;
        }
        forward(t2) {
          let u = this._choices.get(t2);
          return u ? u.forward : void 0;
        }
        redirect(t2) {
          let u = this._choices.get(t2);
          return u ? u.redirect : void 0;
        }
      };
      Ct = class extends S {
        expected() {
          return "a number";
        }
        validate(t2, u) {
          return typeof t2 == "number";
        }
      };
      ht = class extends Ct {
        expected() {
          return "an integer";
        }
        validate(t2, u) {
          return u.normalizeValidateResult(super.validate(t2, u), t2) === true && Hr(t2);
        }
      };
      je = class extends S {
        expected() {
          return "a string";
        }
        validate(t2) {
          return typeof t2 == "string";
        }
      };
      Qr = ie;
      Zr = ft;
      en = Yr;
      tn = Rr;
      gt = class {
        constructor(t2, u) {
          let { logger: r = console, loggerPrintWidth: o = 80, descriptor: n = Qr, unknown: a = Zr, invalid: s = en, deprecated: i = tn, missing: D = () => false, required: f = () => false, preprocess: l = (c) => c, postprocess: d = () => Ae } = u || {};
          this._utils = { descriptor: n, logger: r || { warn: () => {
          } }, loggerPrintWidth: o, schemas: Kr(t2, "name"), normalizeDefaultResult: iu, normalizeExpectedResult: su, normalizeDeprecatedResult: cu, normalizeForwardResult: mt, normalizeRedirectResult: fu, normalizeValidateResult: Du }, this._unknownHandler = a, this._invalidHandler = qr(s), this._deprecatedHandler = i, this._identifyMissing = (c, p2) => !(c in p2) || D(c, p2), this._identifyRequired = f, this._preprocess = l, this._postprocess = d, this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = zr();
        }
        normalize(t2) {
          let u = {}, o = [this._preprocess(t2, this._utils)], n = () => {
            for (; o.length !== 0; ) {
              let a = o.shift(), s = this._applyNormalization(a, u);
              o.push(...s);
            }
          };
          n();
          for (let a of Object.keys(this._utils.schemas)) {
            let s = this._utils.schemas[a];
            if (!(a in u)) {
              let i = iu(s.default(this._utils));
              "value" in i && o.push({ [a]: i.value });
            }
          }
          n();
          for (let a of Object.keys(this._utils.schemas)) {
            if (!(a in u)) continue;
            let s = this._utils.schemas[a], i = u[a], D = s.postprocess(i, this._utils);
            D !== Ae && (this._applyValidation(D, a, s), u[a] = D);
          }
          return this._applyPostprocess(u), this._applyRequiredCheck(u), u;
        }
        _applyNormalization(t2, u) {
          let r = [], { knownKeys: o, unknownKeys: n } = this._partitionOptionKeys(t2);
          for (let a of o) {
            let s = this._utils.schemas[a], i = s.preprocess(t2[a], this._utils);
            this._applyValidation(i, a, s);
            let D = ({ from: c, to: p2 }) => {
              r.push(typeof p2 == "string" ? { [p2]: c } : { [p2.key]: p2.value });
            }, f = ({ value: c, redirectTo: p2 }) => {
              let F = cu(s.deprecated(c, this._utils), i, true);
              if (F !== false) if (F === true) this._hasDeprecationWarned(a) || this._utils.logger.warn(this._deprecatedHandler(a, p2, this._utils));
              else for (let { value: C } of F) {
                let y = { key: a, value: C };
                if (!this._hasDeprecationWarned(y)) {
                  let m = typeof p2 == "string" ? { key: p2, value: C } : p2;
                  this._utils.logger.warn(this._deprecatedHandler(y, m, this._utils));
                }
              }
            };
            mt(s.forward(i, this._utils), i).forEach(D);
            let d = fu(s.redirect(i, this._utils), i);
            if (d.redirect.forEach(D), "remain" in d) {
              let c = d.remain;
              u[a] = a in u ? s.overlap(u[a], c, this._utils) : c, f({ value: c });
            }
            for (let { from: c, to: p2 } of d.redirect) f({ value: c, redirectTo: p2 });
          }
          for (let a of n) {
            let s = t2[a];
            this._applyUnknownHandler(a, s, u, (i, D) => {
              r.push({ [i]: D });
            });
          }
          return r;
        }
        _applyRequiredCheck(t2) {
          for (let u of Object.keys(this._utils.schemas)) if (this._identifyMissing(u, t2) && this._identifyRequired(u)) throw this._invalidHandler(u, Dt, this._utils);
        }
        _partitionOptionKeys(t2) {
          let [u, r] = Jr(Object.keys(t2).filter((o) => !this._identifyMissing(o, t2)), (o) => o in this._utils.schemas);
          return { knownKeys: u, unknownKeys: r };
        }
        _applyValidation(t2, u, r) {
          let o = Du(r.validate(t2, this._utils), t2);
          if (o !== true) throw this._invalidHandler(u, o.value, this._utils);
        }
        _applyUnknownHandler(t2, u, r, o) {
          let n = this._unknownHandler(t2, u, this._utils);
          if (n) for (let a of Object.keys(n)) {
            if (this._identifyMissing(a, n)) continue;
            let s = n[a];
            a in this._utils.schemas ? o(a, s) : r[a] = s;
          }
        }
        _applyPostprocess(t2) {
          let u = this._postprocess(t2, this._utils);
          if (u !== Ae) {
            if (u.delete) for (let r of u.delete) delete t2[r];
            if (u.override) {
              let { knownKeys: r, unknownKeys: o } = this._partitionOptionKeys(u.override);
              for (let n of r) {
                let a = u.override[n];
                this._applyValidation(a, n, this._utils.schemas[n]), t2[n] = a;
              }
              for (let n of o) {
                let a = u.override[n];
                this._applyUnknownHandler(n, a, t2, (s, i) => {
                  let D = this._utils.schemas[s];
                  this._applyValidation(i, s, D), t2[s] = i;
                });
              }
            }
          }
        }
      };
      un = ia;
      ca = Array.prototype.findLast ?? function(e) {
        for (let t2 = this.length - 1; t2 >= 0; t2--) {
          let u = this[t2];
          if (e(u, t2, this)) return u;
        }
      };
      fa = X("findLast", function() {
        if (Array.isArray(this)) return ca;
      });
      du = fa;
      rn = Symbol.for("PRETTIER_IS_FRONT_MATTER");
      pu = [];
      de = la;
      nn = /* @__PURE__ */ new Set(["yaml", "toml"]);
      Ue = ({ node: e }) => de(e) && nn.has(e.language);
      mu = da;
      Eu = pa;
      on = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
      Fa = (e) => Object.keys(e).filter((t2) => !on.has(t2));
      Cu = ma;
      hu = /* @__PURE__ */ new WeakMap();
      q0 = Symbol("PRINTER_NORMALIZED_MARK");
      Ca = ["clean", "embed", "print"];
      ha = Object.fromEntries(Ca.map((e) => [e, false]));
      Dn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null, getVisitorKeys: null };
      se = ba;
      pf = ao(dn(), 1);
      Au = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      pn = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
      af = new RegExp("[" + Au + "]");
      sf = new RegExp("[" + Au + pn + "]");
      Au = pn = null;
      _u = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] };
      Df = new Set(_u.keyword);
      cf = new Set(_u.strict);
      ff = new Set(_u.strictBind);
      It = (e, t2) => (u) => e(t2(u));
      hf = mn(ou(true));
      gf = mn(ou(false));
      Fn = /\r\n|[\n\r\u2028\u2029]/;
      Fe = Ba;
      hn = Sa;
      Bu = wa;
      yn = Oa;
      Pa = Array.prototype.findLastIndex ?? function(e) {
        for (let t2 = this.length - 1; t2 >= 0; t2--) {
          let u = this[t2];
          if (e(u, t2, this)) return t2;
        }
        return -1;
      };
      Ia = X("findLastIndex", function() {
        if (Array.isArray(this)) return Pa;
      });
      bn = Ia;
      ka = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
      xn = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
      Ma = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
      wn = "\uFEFF";
      Tn = Symbol("cursor");
      wu = {};
      Yt(wu, { builders: () => Wa, printer: () => $a, utils: () => Va });
      Wa = { join: Ie, line: ut, softline: or, hardline: V, literalline: Qe, group: Kt, conditionalGroup: tr, fill: er, lineSuffix: ve, lineSuffixBoundary: ar, cursor: ee, breakParent: ce, ifBreak: ur, trim: ir, indent: ae, indentIfBreak: rr, align: De, addAlignmentToDoc: tt, markAsRoot: et, dedentToRoot: Qu, dedent: Zu, hardlineWithoutBreakParent: ke, literallineWithoutBreakParent: Gt, label: nr, concat: (e) => e };
      $a = { printDocToString: Ce };
      Va = { willBreak: Ku, traverseDoc: we, findInDoc: Xe, mapDoc: Pe, removeLines: zu, stripTrailingHardline: qe, replaceEndOfLine: Ju, canBreak: Hu };
      Mn = "3.7.4";
      Pu = {};
      Yt(Pu, { addDanglingComment: () => ue, addLeadingComment: () => fe, addTrailingComment: () => le, getAlignmentSize: () => he, getIndentSize: () => Yn, getMaxContinuousCount: () => jn, getNextNonSpaceNonCommentCharacter: () => Un, getNextNonSpaceNonCommentCharacterIndex: () => ni, getPreferredQuote: () => Vn, getStringWidth: () => Re, hasNewline: () => z, hasNewlineInRange: () => Kn, hasSpaces: () => Gn, isNextLineEmpty: () => Di, isNextLineEmptyAfterIndex: () => kt, isPreviousLineEmpty: () => ai, makeString: () => si, skip: () => ye, skipEverythingButNewLine: () => ot, skipInlineComment: () => xe, skipNewline: () => K, skipSpaces: () => Y, skipToLineEnd: () => nt, skipTrailingComment: () => Be, skipWhitespace: () => Fr });
      xe = Ka;
      Be = Ga;
      ze = za;
      kt = Ja;
      Yn = Ha;
      jn = Xa;
      Un = qa;
      Wn = Object.freeze({ character: "'", codePoint: 39 });
      $n = Object.freeze({ character: '"', codePoint: 34 });
      Qa = Object.freeze({ preferred: Wn, alternate: $n });
      Za = Object.freeze({ preferred: $n, alternate: Wn });
      Vn = ei;
      Kn = ti;
      Gn = ui;
      zn = me(Su);
      fi = me(it, 0);
      li = { parse: me(In), formatAST: me(kn), formatDoc: me(vn), printToDoc: me(Rn), printDocToString: me(Ln) };
    }
  });

  // node_modules/prettier/plugins/graphql.js
  var require_graphql = __commonJS({
    "node_modules/prettier/plugins/graphql.js"(exports, module) {
      (function(f) {
        function e() {
          var i = f();
          return i.default || i;
        }
        if (typeof exports == "object" && typeof module == "object") module.exports = e();
        else if (typeof define == "function" && define.amd) define(e);
        else {
          var t2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          t2.prettierPlugins = t2.prettierPlugins || {}, t2.prettierPlugins.graphql = e();
        }
      })(function() {
        "use strict";
        var ie2 = Object.defineProperty;
        var pt2 = Object.getOwnPropertyDescriptor;
        var lt2 = Object.getOwnPropertyNames;
        var ft2 = Object.prototype.hasOwnProperty;
        var me2 = (e, t2) => {
          for (var n in t2) ie2(e, n, { get: t2[n], enumerable: true });
        }, ht2 = (e, t2, n, i) => {
          if (t2 && typeof t2 == "object" || typeof t2 == "function") for (let r of lt2(t2)) !ft2.call(e, r) && r !== n && ie2(e, r, { get: () => t2[r], enumerable: !(i = pt2(t2, r)) || i.enumerable });
          return e;
        };
        var dt2 = (e) => ht2(ie2({}, "__esModule", { value: true }), e);
        var cn = {};
        me2(cn, { languages: () => je2, options: () => Xe2, parsers: () => de2, printers: () => an2 });
        var Ee2 = (e, t2) => (n, i, ...r) => n | 1 && i == null ? void 0 : (t2.call(i) ?? i[e]).apply(i, r);
        var mt2 = String.prototype.replaceAll ?? function(e, t2) {
          return e.global ? this.replace(e, t2) : this.split(e).join(t2);
        }, Et2 = Ee2("replaceAll", function() {
          if (typeof this == "string") return mt2;
        }), U2 = Et2;
        var Tt = () => {
        }, se2 = Tt;
        var Te = "indent";
        var Ne2 = "group";
        var xe2 = "if-break";
        var G2 = "line";
        var _e2 = "break-parent";
        var S2 = se2, Y2 = se2;
        function x2(e) {
          return S2(e), { type: Te, contents: e };
        }
        var ye2 = { type: _e2 };
        function y(e, t2 = {}) {
          return S2(e), Y2(t2.expandedStates, true), { type: Ne2, id: t2.id, contents: e, break: !!t2.shouldBreak, expandedStates: t2.expandedStates };
        }
        function I2(e, t2 = "", n = {}) {
          return S2(e), t2 !== "" && S2(t2), { type: xe2, breakContents: e, flatContents: t2, groupId: n.groupId };
        }
        function E(e, t2) {
          S2(e), Y2(t2);
          let n = [];
          for (let i = 0; i < t2.length; i++) i !== 0 && n.push(e), n.push(t2[i]);
          return n;
        }
        var k2 = { type: G2 }, l = { type: G2, soft: true }, Nt = { type: G2, hard: true }, f = [Nt, ye2];
        function j2(e) {
          return (t2, n, i) => {
            let r = !!i?.backwards;
            if (n === false) return false;
            let { length: s } = t2, a = n;
            for (; a >= 0 && a < s; ) {
              let u = t2.charAt(a);
              if (e instanceof RegExp) {
                if (!e.test(u)) return a;
              } else if (!e.includes(u)) return a;
              r ? a-- : a++;
            }
            return a === -1 || a === s ? a : false;
          };
        }
        var Ln2 = j2(/\s/u), $2 = j2(" 	"), Ae2 = j2(",; 	"), Oe2 = j2(/[^\n\r]/u);
        var Ie2 = (e) => e === `
` || e === "\r" || e === "\u2028" || e === "\u2029";
        function xt(e, t2, n) {
          let i = !!n?.backwards;
          if (t2 === false) return false;
          let r = e.charAt(t2);
          if (i) {
            if (e.charAt(t2 - 1) === "\r" && r === `
`) return t2 - 2;
            if (Ie2(r)) return t2 - 1;
          } else {
            if (r === "\r" && e.charAt(t2 + 1) === `
`) return t2 + 2;
            if (Ie2(r)) return t2 + 1;
          }
          return t2;
        }
        var X2 = xt;
        function _t(e, t2, n = {}) {
          let i = $2(e, n.backwards ? t2 - 1 : t2, n), r = X2(e, i, n);
          return i !== r;
        }
        var De2 = _t;
        function yt(e, t2) {
          if (t2 === false) return false;
          if (e.charAt(t2) === "/" && e.charAt(t2 + 1) === "*") {
            for (let n = t2 + 2; n < e.length; ++n) if (e.charAt(n) === "*" && e.charAt(n + 1) === "/") return n + 2;
          }
          return t2;
        }
        var ge2 = yt;
        function At(e, t2) {
          return t2 === false ? false : e.charAt(t2) === "/" && e.charAt(t2 + 1) === "/" ? Oe2(e, t2) : t2;
        }
        var Se2 = At;
        function Ot(e, t2) {
          let n = null, i = t2;
          for (; i !== n; ) n = i, i = Ae2(e, i), i = ge2(e, i), i = $2(e, i);
          return i = Se2(e, i), i = X2(e, i), i !== false && De2(e, i);
        }
        var ke2 = Ot;
        function It2(e) {
          return Array.isArray(e) && e.length > 0;
        }
        var oe2 = It2;
        var ae2 = class extends Error {
          name = "UnexpectedNodeError";
          constructor(t2, n, i = "type") {
            super(`Unexpected ${n} node ${i}: ${JSON.stringify(t2[i])}.`), this.node = t2;
          }
        }, Ce2 = ae2;
        var P2 = null;
        function w2(e) {
          if (P2 !== null && typeof P2.property) {
            let t2 = P2;
            return P2 = w2.prototype = null, t2;
          }
          return P2 = w2.prototype = e ?? /* @__PURE__ */ Object.create(null), new w2();
        }
        var Dt2 = 10;
        for (let e = 0; e <= Dt2; e++) w2();
        function ce2(e) {
          return w2(e);
        }
        function gt2(e, t2 = "type") {
          ce2(e);
          function n(i) {
            let r = i[t2], s = e[r];
            if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${r}'.`), { node: i });
            return s;
          }
          return n;
        }
        var Re2 = gt2;
        var H2 = class {
          constructor(t2, n, i) {
            this.start = t2.start, this.end = n.end, this.startToken = t2, this.endToken = n, this.source = i;
          }
          get [Symbol.toStringTag]() {
            return "Location";
          }
          toJSON() {
            return { start: this.start, end: this.end };
          }
        }, F = class {
          constructor(t2, n, i, r, s, a) {
            this.kind = t2, this.start = n, this.end = i, this.line = r, this.column = s, this.value = a, this.prev = null, this.next = null;
          }
          get [Symbol.toStringTag]() {
            return "Token";
          }
          toJSON() {
            return { kind: this.kind, value: this.value, line: this.line, column: this.column };
          }
        }, ue2 = { Name: [], Document: ["definitions"], OperationDefinition: ["description", "name", "variableDefinitions", "directives", "selectionSet"], VariableDefinition: ["description", "variable", "type", "defaultValue", "directives"], Variable: ["name"], SelectionSet: ["selections"], Field: ["alias", "name", "arguments", "directives", "selectionSet"], Argument: ["name", "value"], FragmentSpread: ["name", "directives"], InlineFragment: ["typeCondition", "directives", "selectionSet"], FragmentDefinition: ["description", "name", "variableDefinitions", "typeCondition", "directives", "selectionSet"], IntValue: [], FloatValue: [], StringValue: [], BooleanValue: [], NullValue: [], EnumValue: [], ListValue: ["values"], ObjectValue: ["fields"], ObjectField: ["name", "value"], Directive: ["name", "arguments"], NamedType: ["name"], ListType: ["type"], NonNullType: ["type"], SchemaDefinition: ["description", "directives", "operationTypes"], OperationTypeDefinition: ["type"], ScalarTypeDefinition: ["description", "name", "directives"], ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"], FieldDefinition: ["description", "name", "arguments", "type", "directives"], InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"], InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"], UnionTypeDefinition: ["description", "name", "directives", "types"], EnumTypeDefinition: ["description", "name", "directives", "values"], EnumValueDefinition: ["description", "name", "directives"], InputObjectTypeDefinition: ["description", "name", "directives", "fields"], DirectiveDefinition: ["description", "name", "arguments", "locations"], SchemaExtension: ["directives", "operationTypes"], ScalarTypeExtension: ["name", "directives"], ObjectTypeExtension: ["name", "interfaces", "directives", "fields"], InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"], UnionTypeExtension: ["name", "directives", "types"], EnumTypeExtension: ["name", "directives", "values"], InputObjectTypeExtension: ["name", "directives", "fields"], TypeCoordinate: ["name"], MemberCoordinate: ["name", "memberName"], ArgumentCoordinate: ["name", "fieldName", "argumentName"], DirectiveCoordinate: ["name"], DirectiveArgumentCoordinate: ["name", "argumentName"] }, Zn2 = new Set(Object.keys(ue2));
        var C;
        (function(e) {
          e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
        })(C || (C = {}));
        var ve2 = { ...ue2 };
        for (let e of ["ArgumentCoordinate", "DirectiveArgumentCoordinate", "DirectiveCoordinate", "MemberCoordinate", "TypeCoordinate"]) delete ve2[e];
        var be2 = ve2;
        var St = Re2(be2, "kind"), Le2 = St;
        var J = (e) => e.loc.start, q2 = (e) => e.loc.end;
        var Pe2 = "format", we2 = /^\s*#[^\S\n]*@(?:noformat|noprettier)\s*(?:\n|$)/u, Fe2 = /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/u;
        var Me2 = (e) => Fe2.test(e), Ve = (e) => we2.test(e), Be2 = (e) => `# @${Pe2}

${e}`;
        function kt2(e, t2, n) {
          let { node: i } = e;
          if (!i.description) return "";
          let r = [n("description")];
          return i.kind === "InputValueDefinition" && !i.description.block ? r.push(k2) : r.push(f), r;
        }
        var A = kt2;
        function Ct2(e, t2, n) {
          let { node: i } = e;
          switch (i.kind) {
            case "Document":
              return [...E(f, g(e, t2, n, "definitions")), f];
            case "OperationDefinition": {
              let r = t2.originalText[J(i)] !== "{", s = !!i.name;
              return [A(e, t2, n), r ? i.operation : "", r && s ? [" ", n("name")] : "", r && !s && oe2(i.variableDefinitions) ? " " : "", Ue2(e, n), _2(e, n, i), !r && !s ? "" : " ", n("selectionSet")];
            }
            case "FragmentDefinition":
              return [A(e, t2, n), "fragment ", n("name"), Ue2(e, n), " on ", n("typeCondition"), _2(e, n, i), " ", n("selectionSet")];
            case "SelectionSet":
              return ["{", x2([f, E(f, g(e, t2, n, "selections"))]), f, "}"];
            case "Field":
              return y([i.alias ? [n("alias"), ": "] : "", n("name"), i.arguments.length > 0 ? y(["(", x2([l, E([I2("", ", "), l], g(e, t2, n, "arguments"))]), l, ")"]) : "", _2(e, n, i), i.selectionSet ? " " : "", n("selectionSet")]);
            case "Name":
              return i.value;
            case "StringValue":
              if (i.block) {
                let r = U2(0, i.value, '"""', '\\"""').split(`
`);
                return r.length === 1 && (r[0] = r[0].trim()), r.every((s) => s === "") && (r.length = 0), E(f, ['"""', ...r, '"""']);
              }
              return ['"', U2(0, U2(0, i.value, /["\\]/gu, "\\$&"), `
`, "\\n"), '"'];
            case "IntValue":
            case "FloatValue":
            case "EnumValue":
              return i.value;
            case "BooleanValue":
              return i.value ? "true" : "false";
            case "NullValue":
              return "null";
            case "Variable":
              return ["$", n("name")];
            case "ListValue":
              return y(["[", x2([l, E([I2("", ", "), l], e.map(n, "values"))]), l, "]"]);
            case "ObjectValue": {
              let r = t2.bracketSpacing && i.fields.length > 0 ? " " : "";
              return y(["{", r, x2([l, E([I2("", ", "), l], e.map(n, "fields"))]), l, I2("", r), "}"]);
            }
            case "ObjectField":
            case "Argument":
              return [n("name"), ": ", n("value")];
            case "Directive":
              return ["@", n("name"), i.arguments.length > 0 ? y(["(", x2([l, E([I2("", ", "), l], g(e, t2, n, "arguments"))]), l, ")"]) : ""];
            case "NamedType":
              return n("name");
            case "VariableDefinition":
              return [A(e, t2, n), n("variable"), ": ", n("type"), i.defaultValue ? [" = ", n("defaultValue")] : "", _2(e, n, i)];
            case "ObjectTypeExtension":
            case "ObjectTypeDefinition":
            case "InputObjectTypeExtension":
            case "InputObjectTypeDefinition":
            case "InterfaceTypeExtension":
            case "InterfaceTypeDefinition": {
              let { kind: r } = i, s = [];
              return r.endsWith("TypeDefinition") ? s.push(A(e, t2, n)) : s.push("extend "), r.startsWith("ObjectType") ? s.push("type") : r.startsWith("InputObjectType") ? s.push("input") : s.push("interface"), s.push(" ", n("name")), !r.startsWith("InputObjectType") && i.interfaces.length > 0 && s.push(" implements ", ...bt(e, t2, n)), s.push(_2(e, n, i)), i.fields.length > 0 && s.push([" {", x2([f, E(f, g(e, t2, n, "fields"))]), f, "}"]), s;
            }
            case "FieldDefinition":
              return [A(e, t2, n), n("name"), i.arguments.length > 0 ? y(["(", x2([l, E([I2("", ", "), l], g(e, t2, n, "arguments"))]), l, ")"]) : "", ": ", n("type"), _2(e, n, i)];
            case "DirectiveDefinition":
              return [A(e, t2, n), "directive ", "@", n("name"), i.arguments.length > 0 ? y(["(", x2([l, E([I2("", ", "), l], g(e, t2, n, "arguments"))]), l, ")"]) : "", i.repeatable ? " repeatable" : "", " on ", ...E(" | ", e.map(n, "locations"))];
            case "EnumTypeExtension":
            case "EnumTypeDefinition":
              return [A(e, t2, n), i.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n("name"), _2(e, n, i), i.values.length > 0 ? [" {", x2([f, E(f, g(e, t2, n, "values"))]), f, "}"] : ""];
            case "EnumValueDefinition":
              return [A(e, t2, n), n("name"), _2(e, n, i)];
            case "InputValueDefinition":
              return [A(e, t2, n), n("name"), ": ", n("type"), i.defaultValue ? [" = ", n("defaultValue")] : "", _2(e, n, i)];
            case "SchemaExtension":
              return ["extend schema", _2(e, n, i), ...i.operationTypes.length > 0 ? [" {", x2([f, E(f, g(e, t2, n, "operationTypes"))]), f, "}"] : []];
            case "SchemaDefinition":
              return [A(e, t2, n), "schema", _2(e, n, i), " {", i.operationTypes.length > 0 ? x2([f, E(f, g(e, t2, n, "operationTypes"))]) : "", f, "}"];
            case "OperationTypeDefinition":
              return [i.operation, ": ", n("type")];
            case "FragmentSpread":
              return ["...", n("name"), _2(e, n, i)];
            case "InlineFragment":
              return ["...", i.typeCondition ? [" on ", n("typeCondition")] : "", _2(e, n, i), " ", n("selectionSet")];
            case "UnionTypeExtension":
            case "UnionTypeDefinition":
              return y([A(e, t2, n), y([i.kind === "UnionTypeExtension" ? "extend " : "", "union ", n("name"), _2(e, n, i), i.types.length > 0 ? [" =", I2("", " "), x2([I2([k2, "| "]), E([k2, "| "], e.map(n, "types"))])] : ""])]);
            case "ScalarTypeExtension":
            case "ScalarTypeDefinition":
              return [A(e, t2, n), i.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n("name"), _2(e, n, i)];
            case "NonNullType":
              return [n("type"), "!"];
            case "ListType":
              return ["[", n("type"), "]"];
            default:
              throw new Ce2(i, "Graphql", "kind");
          }
        }
        function _2(e, t2, n) {
          if (n.directives.length === 0) return "";
          let i = E(k2, e.map(t2, "directives"));
          return n.kind === "FragmentDefinition" || n.kind === "OperationDefinition" ? y([k2, i]) : [" ", y(x2([l, i]))];
        }
        function g(e, t2, n, i) {
          return e.map(({ isLast: r, node: s }) => {
            let a = n();
            return !r && ke2(t2.originalText, q2(s)) ? [a, f] : a;
          }, i);
        }
        function Rt(e) {
          return e.kind !== "Comment";
        }
        function vt({ node: e }) {
          if (e.kind === "Comment") return "#" + e.value.trimEnd();
          throw new Error("Not a comment: " + JSON.stringify(e));
        }
        function bt(e, t2, n) {
          let { node: i } = e, r = [], { interfaces: s } = i, a = e.map(n, "interfaces");
          for (let u = 0; u < s.length; u++) {
            let p2 = s[u];
            r.push(a[u]);
            let T2 = s[u + 1];
            if (T2) {
              let D = t2.originalText.slice(p2.loc.end, T2.loc.start).includes("#");
              r.push(" &", D ? k2 : " ");
            }
          }
          return r;
        }
        function Ue2(e, t2) {
          let { node: n } = e;
          return oe2(n.variableDefinitions) ? y(["(", x2([l, E([I2("", ", "), l], e.map(t2, "variableDefinitions"))]), l, ")"]) : "";
        }
        function Ge2(e, t2) {
          e.kind === "StringValue" && e.block && !e.value.includes(`
`) && (t2.value = e.value.trim());
        }
        Ge2.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
        function Lt(e) {
          let { node: t2 } = e;
          return t2?.comments?.some((n) => n.value.trim() === "prettier-ignore");
        }
        var Pt = { print: Ct2, massageAstNode: Ge2, hasPrettierIgnore: Lt, insertPragma: Be2, printComment: vt, canAttachComment: Rt, getVisitorKeys: Le2 }, Ye2 = Pt;
        var je2 = [{ name: "GraphQL", type: "data", aceMode: "graphqlschema", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", parsers: ["graphql"], vscodeLanguageIds: ["graphql"], linguistLanguageId: 139 }];
        var $e = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        var wt = { bracketSpacing: $e.bracketSpacing }, Xe2 = wt;
        var de2 = {};
        me2(de2, { graphql: () => on2 });
        function He2(e) {
          return typeof e == "object" && e !== null;
        }
        function Je2(e, t2) {
          if (!!!e) throw new Error(t2 ?? "Unexpected invariant triggered.");
        }
        var Ft2 = /\r\n|[\n\r]/g;
        function M2(e, t2) {
          let n = 0, i = 1;
          for (let r of e.body.matchAll(Ft2)) {
            if (typeof r.index == "number" || Je2(false), r.index >= t2) break;
            n = r.index + r[0].length, i += 1;
          }
          return { line: i, column: t2 + 1 - n };
        }
        function Qe2(e) {
          return pe(e.source, M2(e.source, e.start));
        }
        function pe(e, t2) {
          let n = e.locationOffset.column - 1, i = "".padStart(n) + e.body, r = t2.line - 1, s = e.locationOffset.line - 1, a = t2.line + s, u = t2.line === 1 ? n : 0, p2 = t2.column + u, T2 = `${e.name}:${a}:${p2}
`, d = i.split(/\r\n|[\n\r]/g), D = d[r];
          if (D.length > 120) {
            let O2 = Math.floor(p2 / 80), re = p2 % 80, N2 = [];
            for (let v2 = 0; v2 < D.length; v2 += 80) N2.push(D.slice(v2, v2 + 80));
            return T2 + qe2([[`${a} |`, N2[0]], ...N2.slice(1, O2 + 1).map((v2) => ["|", v2]), ["|", "^".padStart(re)], ["|", N2[O2 + 1]]]);
          }
          return T2 + qe2([[`${a - 1} |`, d[r - 1]], [`${a} |`, D], ["|", "^".padStart(p2)], [`${a + 1} |`, d[r + 1]]]);
        }
        function qe2(e) {
          let t2 = e.filter(([i, r]) => r !== void 0), n = Math.max(...t2.map(([i]) => i.length));
          return t2.map(([i, r]) => i.padStart(n) + (r ? " " + r : "")).join(`
`);
        }
        function Mt2(e) {
          let t2 = e[0];
          return t2 == null || "kind" in t2 || "length" in t2 ? { nodes: t2, source: e[1], positions: e[2], path: e[3], originalError: e[4], extensions: e[5] } : t2;
        }
        var Q = class e extends Error {
          constructor(t2, ...n) {
            var i, r, s;
            let { nodes: a, source: u, positions: p2, path: T2, originalError: d, extensions: D } = Mt2(n);
            super(t2), this.name = "GraphQLError", this.path = T2 ?? void 0, this.originalError = d ?? void 0, this.nodes = We2(Array.isArray(a) ? a : a ? [a] : void 0);
            let O2 = We2((i = this.nodes) === null || i === void 0 ? void 0 : i.map((N2) => N2.loc).filter((N2) => N2 != null));
            this.source = u ?? (O2 == null || (r = O2[0]) === null || r === void 0 ? void 0 : r.source), this.positions = p2 ?? O2?.map((N2) => N2.start), this.locations = p2 && u ? p2.map((N2) => M2(u, N2)) : O2?.map((N2) => M2(N2.source, N2.start));
            let re = He2(d?.extensions) ? d?.extensions : void 0;
            this.extensions = (s = D ?? re) !== null && s !== void 0 ? s : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, { message: { writable: true, enumerable: true }, name: { enumerable: false }, nodes: { enumerable: false }, source: { enumerable: false }, positions: { enumerable: false }, originalError: { enumerable: false } }), d != null && d.stack ? Object.defineProperty(this, "stack", { value: d.stack, writable: true, configurable: true }) : Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, "stack", { value: Error().stack, writable: true, configurable: true });
          }
          get [Symbol.toStringTag]() {
            return "GraphQLError";
          }
          toString() {
            let t2 = this.message;
            if (this.nodes) for (let n of this.nodes) n.loc && (t2 += `

` + Qe2(n.loc));
            else if (this.source && this.locations) for (let n of this.locations) t2 += `

` + pe(this.source, n);
            return t2;
          }
          toJSON() {
            let t2 = { message: this.message };
            return this.locations != null && (t2.locations = this.locations), this.path != null && (t2.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t2.extensions = this.extensions), t2;
          }
        };
        function We2(e) {
          return e === void 0 || e.length === 0 ? void 0 : e;
        }
        function h(e, t2, n) {
          return new Q(`Syntax Error: ${n}`, { source: e, positions: [t2] });
        }
        var W2;
        (function(e) {
          e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
        })(W2 || (W2 = {}));
        var c;
        (function(e) {
          e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension", e.TYPE_COORDINATE = "TypeCoordinate", e.MEMBER_COORDINATE = "MemberCoordinate", e.ARGUMENT_COORDINATE = "ArgumentCoordinate", e.DIRECTIVE_COORDINATE = "DirectiveCoordinate", e.DIRECTIVE_ARGUMENT_COORDINATE = "DirectiveArgumentCoordinate";
        })(c || (c = {}));
        function ze2(e) {
          return e === 9 || e === 32;
        }
        function b2(e) {
          return e >= 48 && e <= 57;
        }
        function Ke(e) {
          return e >= 97 && e <= 122 || e >= 65 && e <= 90;
        }
        function le2(e) {
          return Ke(e) || e === 95;
        }
        function Ze2(e) {
          return Ke(e) || b2(e) || e === 95;
        }
        function et2(e) {
          var t2;
          let n = Number.MAX_SAFE_INTEGER, i = null, r = -1;
          for (let a = 0; a < e.length; ++a) {
            var s;
            let u = e[a], p2 = Vt2(u);
            p2 !== u.length && (i = (s = i) !== null && s !== void 0 ? s : a, r = a, a !== 0 && p2 < n && (n = p2));
          }
          return e.map((a, u) => u === 0 ? a : a.slice(n)).slice((t2 = i) !== null && t2 !== void 0 ? t2 : 0, r + 1);
        }
        function Vt2(e) {
          let t2 = 0;
          for (; t2 < e.length && ze2(e.charCodeAt(t2)); ) ++t2;
          return t2;
        }
        var o;
        (function(e) {
          e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.DOT = ".", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
        })(o || (o = {}));
        var z2 = class {
          constructor(t2) {
            let n = new F(o.SOF, 0, 0, 0, 0);
            this.source = t2, this.lastToken = n, this.token = n, this.line = 1, this.lineStart = 0;
          }
          get [Symbol.toStringTag]() {
            return "Lexer";
          }
          advance() {
            return this.lastToken = this.token, this.token = this.lookahead();
          }
          lookahead() {
            let t2 = this.token;
            if (t2.kind !== o.EOF) do
              if (t2.next) t2 = t2.next;
              else {
                let n = Bt(this, t2.end);
                t2.next = n, n.prev = t2, t2 = n;
              }
            while (t2.kind === o.COMMENT);
            return t2;
          }
        };
        function nt2(e) {
          return e === o.BANG || e === o.DOLLAR || e === o.AMP || e === o.PAREN_L || e === o.PAREN_R || e === o.DOT || e === o.SPREAD || e === o.COLON || e === o.EQUALS || e === o.AT || e === o.BRACKET_L || e === o.BRACKET_R || e === o.BRACE_L || e === o.PIPE || e === o.BRACE_R;
        }
        function L2(e) {
          return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
        }
        function K2(e, t2) {
          return rt2(e.charCodeAt(t2)) && it2(e.charCodeAt(t2 + 1));
        }
        function rt2(e) {
          return e >= 55296 && e <= 56319;
        }
        function it2(e) {
          return e >= 56320 && e <= 57343;
        }
        function R2(e, t2) {
          let n = e.source.body.codePointAt(t2);
          if (n === void 0) return o.EOF;
          if (n >= 32 && n <= 126) {
            let i = String.fromCodePoint(n);
            return i === '"' ? `'"'` : `"${i}"`;
          }
          return "U+" + n.toString(16).toUpperCase().padStart(4, "0");
        }
        function m(e, t2, n, i, r) {
          let s = e.line, a = 1 + n - e.lineStart;
          return new F(t2, n, i, s, a, r);
        }
        function Bt(e, t2) {
          let n = e.source.body, i = n.length, r = t2;
          for (; r < i; ) {
            let s = n.charCodeAt(r);
            switch (s) {
              case 65279:
              case 9:
              case 32:
              case 44:
                ++r;
                continue;
              case 10:
                ++r, ++e.line, e.lineStart = r;
                continue;
              case 13:
                n.charCodeAt(r + 1) === 10 ? r += 2 : ++r, ++e.line, e.lineStart = r;
                continue;
              case 35:
                return Ut2(e, r);
              case 33:
                return m(e, o.BANG, r, r + 1);
              case 36:
                return m(e, o.DOLLAR, r, r + 1);
              case 38:
                return m(e, o.AMP, r, r + 1);
              case 40:
                return m(e, o.PAREN_L, r, r + 1);
              case 41:
                return m(e, o.PAREN_R, r, r + 1);
              case 46:
                if (n.charCodeAt(r + 1) === 46 && n.charCodeAt(r + 2) === 46) return m(e, o.SPREAD, r, r + 3);
                break;
              case 58:
                return m(e, o.COLON, r, r + 1);
              case 61:
                return m(e, o.EQUALS, r, r + 1);
              case 64:
                return m(e, o.AT, r, r + 1);
              case 91:
                return m(e, o.BRACKET_L, r, r + 1);
              case 93:
                return m(e, o.BRACKET_R, r, r + 1);
              case 123:
                return m(e, o.BRACE_L, r, r + 1);
              case 124:
                return m(e, o.PIPE, r, r + 1);
              case 125:
                return m(e, o.BRACE_R, r, r + 1);
              case 34:
                return n.charCodeAt(r + 1) === 34 && n.charCodeAt(r + 2) === 34 ? Ht2(e, r) : Yt2(e, r);
            }
            if (b2(s) || s === 45) return Gt2(e, r, s);
            if (le2(s)) return Jt2(e, r);
            throw h(e.source, r, s === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : L2(s) || K2(n, r) ? `Unexpected character: ${R2(e, r)}.` : `Invalid character: ${R2(e, r)}.`);
          }
          return m(e, o.EOF, i, i);
        }
        function Ut2(e, t2) {
          let n = e.source.body, i = n.length, r = t2 + 1;
          for (; r < i; ) {
            let s = n.charCodeAt(r);
            if (s === 10 || s === 13) break;
            if (L2(s)) ++r;
            else if (K2(n, r)) r += 2;
            else break;
          }
          return m(e, o.COMMENT, t2, r, n.slice(t2 + 1, r));
        }
        function Gt2(e, t2, n) {
          let i = e.source.body, r = t2, s = n, a = false;
          if (s === 45 && (s = i.charCodeAt(++r)), s === 48) {
            if (s = i.charCodeAt(++r), b2(s)) throw h(e.source, r, `Invalid number, unexpected digit after 0: ${R2(e, r)}.`);
          } else r = fe2(e, r, s), s = i.charCodeAt(r);
          if (s === 46 && (a = true, s = i.charCodeAt(++r), r = fe2(e, r, s), s = i.charCodeAt(r)), (s === 69 || s === 101) && (a = true, s = i.charCodeAt(++r), (s === 43 || s === 45) && (s = i.charCodeAt(++r)), r = fe2(e, r, s), s = i.charCodeAt(r)), s === 46 || le2(s)) throw h(e.source, r, `Invalid number, expected digit but got: ${R2(e, r)}.`);
          return m(e, a ? o.FLOAT : o.INT, t2, r, i.slice(t2, r));
        }
        function fe2(e, t2, n) {
          if (!b2(n)) throw h(e.source, t2, `Invalid number, expected digit but got: ${R2(e, t2)}.`);
          let i = e.source.body, r = t2 + 1;
          for (; b2(i.charCodeAt(r)); ) ++r;
          return r;
        }
        function Yt2(e, t2) {
          let n = e.source.body, i = n.length, r = t2 + 1, s = r, a = "";
          for (; r < i; ) {
            let u = n.charCodeAt(r);
            if (u === 34) return a += n.slice(s, r), m(e, o.STRING, t2, r + 1, a);
            if (u === 92) {
              a += n.slice(s, r);
              let p2 = n.charCodeAt(r + 1) === 117 ? n.charCodeAt(r + 2) === 123 ? jt2(e, r) : $t2(e, r) : Xt2(e, r);
              a += p2.value, r += p2.size, s = r;
              continue;
            }
            if (u === 10 || u === 13) break;
            if (L2(u)) ++r;
            else if (K2(n, r)) r += 2;
            else throw h(e.source, r, `Invalid character within String: ${R2(e, r)}.`);
          }
          throw h(e.source, r, "Unterminated string.");
        }
        function jt2(e, t2) {
          let n = e.source.body, i = 0, r = 3;
          for (; r < 12; ) {
            let s = n.charCodeAt(t2 + r++);
            if (s === 125) {
              if (r < 5 || !L2(i)) break;
              return { value: String.fromCodePoint(i), size: r };
            }
            if (i = i << 4 | V2(s), i < 0) break;
          }
          throw h(e.source, t2, `Invalid Unicode escape sequence: "${n.slice(t2, t2 + r)}".`);
        }
        function $t2(e, t2) {
          let n = e.source.body, i = tt2(n, t2 + 2);
          if (L2(i)) return { value: String.fromCodePoint(i), size: 6 };
          if (rt2(i) && n.charCodeAt(t2 + 6) === 92 && n.charCodeAt(t2 + 7) === 117) {
            let r = tt2(n, t2 + 8);
            if (it2(r)) return { value: String.fromCodePoint(i, r), size: 12 };
          }
          throw h(e.source, t2, `Invalid Unicode escape sequence: "${n.slice(t2, t2 + 6)}".`);
        }
        function tt2(e, t2) {
          return V2(e.charCodeAt(t2)) << 12 | V2(e.charCodeAt(t2 + 1)) << 8 | V2(e.charCodeAt(t2 + 2)) << 4 | V2(e.charCodeAt(t2 + 3));
        }
        function V2(e) {
          return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
        }
        function Xt2(e, t2) {
          let n = e.source.body;
          switch (n.charCodeAt(t2 + 1)) {
            case 34:
              return { value: '"', size: 2 };
            case 92:
              return { value: "\\", size: 2 };
            case 47:
              return { value: "/", size: 2 };
            case 98:
              return { value: "\b", size: 2 };
            case 102:
              return { value: "\f", size: 2 };
            case 110:
              return { value: `
`, size: 2 };
            case 114:
              return { value: "\r", size: 2 };
            case 116:
              return { value: "	", size: 2 };
          }
          throw h(e.source, t2, `Invalid character escape sequence: "${n.slice(t2, t2 + 2)}".`);
        }
        function Ht2(e, t2) {
          let n = e.source.body, i = n.length, r = e.lineStart, s = t2 + 3, a = s, u = "", p2 = [];
          for (; s < i; ) {
            let T2 = n.charCodeAt(s);
            if (T2 === 34 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34) {
              u += n.slice(a, s), p2.push(u);
              let d = m(e, o.BLOCK_STRING, t2, s + 3, et2(p2).join(`
`));
              return e.line += p2.length - 1, e.lineStart = r, d;
            }
            if (T2 === 92 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34 && n.charCodeAt(s + 3) === 34) {
              u += n.slice(a, s), a = s + 1, s += 4;
              continue;
            }
            if (T2 === 10 || T2 === 13) {
              u += n.slice(a, s), p2.push(u), T2 === 13 && n.charCodeAt(s + 1) === 10 ? s += 2 : ++s, u = "", a = s, r = s;
              continue;
            }
            if (L2(T2)) ++s;
            else if (K2(n, s)) s += 2;
            else throw h(e.source, s, `Invalid character within String: ${R2(e, s)}.`);
          }
          throw h(e.source, s, "Unterminated string.");
        }
        function Jt2(e, t2) {
          let n = e.source.body, i = n.length, r = t2 + 1;
          for (; r < i; ) {
            let s = n.charCodeAt(r);
            if (Ze2(s)) ++r;
            else break;
          }
          return m(e, o.NAME, t2, r, n.slice(t2, r));
        }
        function Z2(e, t2) {
          if (!!!e) throw new Error(t2);
        }
        function ee2(e) {
          return te2(e, []);
        }
        function te2(e, t2) {
          switch (typeof e) {
            case "string":
              return JSON.stringify(e);
            case "function":
              return e.name ? `[function ${e.name}]` : "[function]";
            case "object":
              return qt2(e, t2);
            default:
              return String(e);
          }
        }
        function qt2(e, t2) {
          if (e === null) return "null";
          if (t2.includes(e)) return "[Circular]";
          let n = [...t2, e];
          if (Qt2(e)) {
            let i = e.toJSON();
            if (i !== e) return typeof i == "string" ? i : te2(i, n);
          } else if (Array.isArray(e)) return zt2(e, n);
          return Wt2(e, n);
        }
        function Qt2(e) {
          return typeof e.toJSON == "function";
        }
        function Wt2(e, t2) {
          let n = Object.entries(e);
          return n.length === 0 ? "{}" : t2.length > 2 ? "[" + Kt2(e) + "]" : "{ " + n.map(([r, s]) => r + ": " + te2(s, t2)).join(", ") + " }";
        }
        function zt2(e, t2) {
          if (e.length === 0) return "[]";
          if (t2.length > 2) return "[Array]";
          let n = Math.min(10, e.length), i = e.length - n, r = [];
          for (let s = 0; s < n; ++s) r.push(te2(e[s], t2));
          return i === 1 ? r.push("... 1 more item") : i > 1 && r.push(`... ${i} more items`), "[" + r.join(", ") + "]";
        }
        function Kt2(e) {
          let t2 = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
          if (t2 === "Object" && typeof e.constructor == "function") {
            let n = e.constructor.name;
            if (typeof n == "string" && n !== "") return n;
          }
          return t2;
        }
        var Zt2 = globalThis.process && true, st2 = Zt2 ? function(t2, n) {
          return t2 instanceof n;
        } : function(t2, n) {
          if (t2 instanceof n) return true;
          if (typeof t2 == "object" && t2 !== null) {
            var i;
            let r = n.prototype[Symbol.toStringTag], s = Symbol.toStringTag in t2 ? t2[Symbol.toStringTag] : (i = t2.constructor) === null || i === void 0 ? void 0 : i.name;
            if (r === s) {
              let a = ee2(t2);
              throw new Error(`Cannot use ${r} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
            }
          }
          return false;
        };
        var B2 = class {
          constructor(t2, n = "GraphQL request", i = { line: 1, column: 1 }) {
            typeof t2 == "string" || Z2(false, `Body must be a string. Received: ${ee2(t2)}.`), this.body = t2, this.name = n, this.locationOffset = i, this.locationOffset.line > 0 || Z2(false, "line in locationOffset is 1-indexed and must be positive."), this.locationOffset.column > 0 || Z2(false, "column in locationOffset is 1-indexed and must be positive.");
          }
          get [Symbol.toStringTag]() {
            return "Source";
          }
        };
        function ot2(e) {
          return st2(e, B2);
        }
        function at2(e, t2) {
          let n = new he2(e, t2), i = n.parseDocument();
          return Object.defineProperty(i, "tokenCount", { enumerable: false, value: n.tokenCount }), i;
        }
        var he2 = class {
          constructor(t2, n = {}) {
            let { lexer: i, ...r } = n;
            if (i) this._lexer = i;
            else {
              let s = ot2(t2) ? t2 : new B2(t2);
              this._lexer = new z2(s);
            }
            this._options = r, this._tokenCounter = 0;
          }
          get tokenCount() {
            return this._tokenCounter;
          }
          parseName() {
            let t2 = this.expectToken(o.NAME);
            return this.node(t2, { kind: c.NAME, value: t2.value });
          }
          parseDocument() {
            return this.node(this._lexer.token, { kind: c.DOCUMENT, definitions: this.many(o.SOF, this.parseDefinition, o.EOF) });
          }
          parseDefinition() {
            if (this.peek(o.BRACE_L)) return this.parseOperationDefinition();
            let t2 = this.peekDescription(), n = t2 ? this._lexer.lookahead() : this._lexer.token;
            if (t2 && n.kind === o.BRACE_L) throw h(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are not supported on shorthand queries.");
            if (n.kind === o.NAME) {
              switch (n.value) {
                case "schema":
                  return this.parseSchemaDefinition();
                case "scalar":
                  return this.parseScalarTypeDefinition();
                case "type":
                  return this.parseObjectTypeDefinition();
                case "interface":
                  return this.parseInterfaceTypeDefinition();
                case "union":
                  return this.parseUnionTypeDefinition();
                case "enum":
                  return this.parseEnumTypeDefinition();
                case "input":
                  return this.parseInputObjectTypeDefinition();
                case "directive":
                  return this.parseDirectiveDefinition();
              }
              switch (n.value) {
                case "query":
                case "mutation":
                case "subscription":
                  return this.parseOperationDefinition();
                case "fragment":
                  return this.parseFragmentDefinition();
              }
              if (t2) throw h(this._lexer.source, this._lexer.token.start, "Unexpected description, only GraphQL definitions support descriptions.");
              switch (n.value) {
                case "extend":
                  return this.parseTypeSystemExtension();
              }
            }
            throw this.unexpected(n);
          }
          parseOperationDefinition() {
            let t2 = this._lexer.token;
            if (this.peek(o.BRACE_L)) return this.node(t2, { kind: c.OPERATION_DEFINITION, operation: C.QUERY, description: void 0, name: void 0, variableDefinitions: [], directives: [], selectionSet: this.parseSelectionSet() });
            let n = this.parseDescription(), i = this.parseOperationType(), r;
            return this.peek(o.NAME) && (r = this.parseName()), this.node(t2, { kind: c.OPERATION_DEFINITION, operation: i, description: n, name: r, variableDefinitions: this.parseVariableDefinitions(), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet() });
          }
          parseOperationType() {
            let t2 = this.expectToken(o.NAME);
            switch (t2.value) {
              case "query":
                return C.QUERY;
              case "mutation":
                return C.MUTATION;
              case "subscription":
                return C.SUBSCRIPTION;
            }
            throw this.unexpected(t2);
          }
          parseVariableDefinitions() {
            return this.optionalMany(o.PAREN_L, this.parseVariableDefinition, o.PAREN_R);
          }
          parseVariableDefinition() {
            return this.node(this._lexer.token, { kind: c.VARIABLE_DEFINITION, description: this.parseDescription(), variable: this.parseVariable(), type: (this.expectToken(o.COLON), this.parseTypeReference()), defaultValue: this.expectOptionalToken(o.EQUALS) ? this.parseConstValueLiteral() : void 0, directives: this.parseConstDirectives() });
          }
          parseVariable() {
            let t2 = this._lexer.token;
            return this.expectToken(o.DOLLAR), this.node(t2, { kind: c.VARIABLE, name: this.parseName() });
          }
          parseSelectionSet() {
            return this.node(this._lexer.token, { kind: c.SELECTION_SET, selections: this.many(o.BRACE_L, this.parseSelection, o.BRACE_R) });
          }
          parseSelection() {
            return this.peek(o.SPREAD) ? this.parseFragment() : this.parseField();
          }
          parseField() {
            let t2 = this._lexer.token, n = this.parseName(), i, r;
            return this.expectOptionalToken(o.COLON) ? (i = n, r = this.parseName()) : r = n, this.node(t2, { kind: c.FIELD, alias: i, name: r, arguments: this.parseArguments(false), directives: this.parseDirectives(false), selectionSet: this.peek(o.BRACE_L) ? this.parseSelectionSet() : void 0 });
          }
          parseArguments(t2) {
            let n = t2 ? this.parseConstArgument : this.parseArgument;
            return this.optionalMany(o.PAREN_L, n, o.PAREN_R);
          }
          parseArgument(t2 = false) {
            let n = this._lexer.token, i = this.parseName();
            return this.expectToken(o.COLON), this.node(n, { kind: c.ARGUMENT, name: i, value: this.parseValueLiteral(t2) });
          }
          parseConstArgument() {
            return this.parseArgument(true);
          }
          parseFragment() {
            let t2 = this._lexer.token;
            this.expectToken(o.SPREAD);
            let n = this.expectOptionalKeyword("on");
            return !n && this.peek(o.NAME) ? this.node(t2, { kind: c.FRAGMENT_SPREAD, name: this.parseFragmentName(), directives: this.parseDirectives(false) }) : this.node(t2, { kind: c.INLINE_FRAGMENT, typeCondition: n ? this.parseNamedType() : void 0, directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet() });
          }
          parseFragmentDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === true ? this.node(t2, { kind: c.FRAGMENT_DEFINITION, description: n, name: this.parseFragmentName(), variableDefinitions: this.parseVariableDefinitions(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet() }) : this.node(t2, { kind: c.FRAGMENT_DEFINITION, description: n, name: this.parseFragmentName(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet() });
          }
          parseFragmentName() {
            if (this._lexer.token.value === "on") throw this.unexpected();
            return this.parseName();
          }
          parseValueLiteral(t2) {
            let n = this._lexer.token;
            switch (n.kind) {
              case o.BRACKET_L:
                return this.parseList(t2);
              case o.BRACE_L:
                return this.parseObject(t2);
              case o.INT:
                return this.advanceLexer(), this.node(n, { kind: c.INT, value: n.value });
              case o.FLOAT:
                return this.advanceLexer(), this.node(n, { kind: c.FLOAT, value: n.value });
              case o.STRING:
              case o.BLOCK_STRING:
                return this.parseStringLiteral();
              case o.NAME:
                switch (this.advanceLexer(), n.value) {
                  case "true":
                    return this.node(n, { kind: c.BOOLEAN, value: true });
                  case "false":
                    return this.node(n, { kind: c.BOOLEAN, value: false });
                  case "null":
                    return this.node(n, { kind: c.NULL });
                  default:
                    return this.node(n, { kind: c.ENUM, value: n.value });
                }
              case o.DOLLAR:
                if (t2) if (this.expectToken(o.DOLLAR), this._lexer.token.kind === o.NAME) {
                  let i = this._lexer.token.value;
                  throw h(this._lexer.source, n.start, `Unexpected variable "$${i}" in constant value.`);
                } else throw this.unexpected(n);
                return this.parseVariable();
              default:
                throw this.unexpected();
            }
          }
          parseConstValueLiteral() {
            return this.parseValueLiteral(true);
          }
          parseStringLiteral() {
            let t2 = this._lexer.token;
            return this.advanceLexer(), this.node(t2, { kind: c.STRING, value: t2.value, block: t2.kind === o.BLOCK_STRING });
          }
          parseList(t2) {
            let n = () => this.parseValueLiteral(t2);
            return this.node(this._lexer.token, { kind: c.LIST, values: this.any(o.BRACKET_L, n, o.BRACKET_R) });
          }
          parseObject(t2) {
            let n = () => this.parseObjectField(t2);
            return this.node(this._lexer.token, { kind: c.OBJECT, fields: this.any(o.BRACE_L, n, o.BRACE_R) });
          }
          parseObjectField(t2) {
            let n = this._lexer.token, i = this.parseName();
            return this.expectToken(o.COLON), this.node(n, { kind: c.OBJECT_FIELD, name: i, value: this.parseValueLiteral(t2) });
          }
          parseDirectives(t2) {
            let n = [];
            for (; this.peek(o.AT); ) n.push(this.parseDirective(t2));
            return n;
          }
          parseConstDirectives() {
            return this.parseDirectives(true);
          }
          parseDirective(t2) {
            let n = this._lexer.token;
            return this.expectToken(o.AT), this.node(n, { kind: c.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(t2) });
          }
          parseTypeReference() {
            let t2 = this._lexer.token, n;
            if (this.expectOptionalToken(o.BRACKET_L)) {
              let i = this.parseTypeReference();
              this.expectToken(o.BRACKET_R), n = this.node(t2, { kind: c.LIST_TYPE, type: i });
            } else n = this.parseNamedType();
            return this.expectOptionalToken(o.BANG) ? this.node(t2, { kind: c.NON_NULL_TYPE, type: n }) : n;
          }
          parseNamedType() {
            return this.node(this._lexer.token, { kind: c.NAMED_TYPE, name: this.parseName() });
          }
          peekDescription() {
            return this.peek(o.STRING) || this.peek(o.BLOCK_STRING);
          }
          parseDescription() {
            if (this.peekDescription()) return this.parseStringLiteral();
          }
          parseSchemaDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("schema");
            let i = this.parseConstDirectives(), r = this.many(o.BRACE_L, this.parseOperationTypeDefinition, o.BRACE_R);
            return this.node(t2, { kind: c.SCHEMA_DEFINITION, description: n, directives: i, operationTypes: r });
          }
          parseOperationTypeDefinition() {
            let t2 = this._lexer.token, n = this.parseOperationType();
            this.expectToken(o.COLON);
            let i = this.parseNamedType();
            return this.node(t2, { kind: c.OPERATION_TYPE_DEFINITION, operation: n, type: i });
          }
          parseScalarTypeDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("scalar");
            let i = this.parseName(), r = this.parseConstDirectives();
            return this.node(t2, { kind: c.SCALAR_TYPE_DEFINITION, description: n, name: i, directives: r });
          }
          parseObjectTypeDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("type");
            let i = this.parseName(), r = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
            return this.node(t2, { kind: c.OBJECT_TYPE_DEFINITION, description: n, name: i, interfaces: r, directives: s, fields: a });
          }
          parseImplementsInterfaces() {
            return this.expectOptionalKeyword("implements") ? this.delimitedMany(o.AMP, this.parseNamedType) : [];
          }
          parseFieldsDefinition() {
            return this.optionalMany(o.BRACE_L, this.parseFieldDefinition, o.BRACE_R);
          }
          parseFieldDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription(), i = this.parseName(), r = this.parseArgumentDefs();
            this.expectToken(o.COLON);
            let s = this.parseTypeReference(), a = this.parseConstDirectives();
            return this.node(t2, { kind: c.FIELD_DEFINITION, description: n, name: i, arguments: r, type: s, directives: a });
          }
          parseArgumentDefs() {
            return this.optionalMany(o.PAREN_L, this.parseInputValueDef, o.PAREN_R);
          }
          parseInputValueDef() {
            let t2 = this._lexer.token, n = this.parseDescription(), i = this.parseName();
            this.expectToken(o.COLON);
            let r = this.parseTypeReference(), s;
            this.expectOptionalToken(o.EQUALS) && (s = this.parseConstValueLiteral());
            let a = this.parseConstDirectives();
            return this.node(t2, { kind: c.INPUT_VALUE_DEFINITION, description: n, name: i, type: r, defaultValue: s, directives: a });
          }
          parseInterfaceTypeDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("interface");
            let i = this.parseName(), r = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
            return this.node(t2, { kind: c.INTERFACE_TYPE_DEFINITION, description: n, name: i, interfaces: r, directives: s, fields: a });
          }
          parseUnionTypeDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("union");
            let i = this.parseName(), r = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
            return this.node(t2, { kind: c.UNION_TYPE_DEFINITION, description: n, name: i, directives: r, types: s });
          }
          parseUnionMemberTypes() {
            return this.expectOptionalToken(o.EQUALS) ? this.delimitedMany(o.PIPE, this.parseNamedType) : [];
          }
          parseEnumTypeDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("enum");
            let i = this.parseName(), r = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
            return this.node(t2, { kind: c.ENUM_TYPE_DEFINITION, description: n, name: i, directives: r, values: s });
          }
          parseEnumValuesDefinition() {
            return this.optionalMany(o.BRACE_L, this.parseEnumValueDefinition, o.BRACE_R);
          }
          parseEnumValueDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription(), i = this.parseEnumValueName(), r = this.parseConstDirectives();
            return this.node(t2, { kind: c.ENUM_VALUE_DEFINITION, description: n, name: i, directives: r });
          }
          parseEnumValueName() {
            if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") throw h(this._lexer.source, this._lexer.token.start, `${ne(this._lexer.token)} is reserved and cannot be used for an enum value.`);
            return this.parseName();
          }
          parseInputObjectTypeDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("input");
            let i = this.parseName(), r = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
            return this.node(t2, { kind: c.INPUT_OBJECT_TYPE_DEFINITION, description: n, name: i, directives: r, fields: s });
          }
          parseInputFieldsDefinition() {
            return this.optionalMany(o.BRACE_L, this.parseInputValueDef, o.BRACE_R);
          }
          parseTypeSystemExtension() {
            let t2 = this._lexer.lookahead();
            if (t2.kind === o.NAME) switch (t2.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
            throw this.unexpected(t2);
          }
          parseSchemaExtension() {
            let t2 = this._lexer.token;
            this.expectKeyword("extend"), this.expectKeyword("schema");
            let n = this.parseConstDirectives(), i = this.optionalMany(o.BRACE_L, this.parseOperationTypeDefinition, o.BRACE_R);
            if (n.length === 0 && i.length === 0) throw this.unexpected();
            return this.node(t2, { kind: c.SCHEMA_EXTENSION, directives: n, operationTypes: i });
          }
          parseScalarTypeExtension() {
            let t2 = this._lexer.token;
            this.expectKeyword("extend"), this.expectKeyword("scalar");
            let n = this.parseName(), i = this.parseConstDirectives();
            if (i.length === 0) throw this.unexpected();
            return this.node(t2, { kind: c.SCALAR_TYPE_EXTENSION, name: n, directives: i });
          }
          parseObjectTypeExtension() {
            let t2 = this._lexer.token;
            this.expectKeyword("extend"), this.expectKeyword("type");
            let n = this.parseName(), i = this.parseImplementsInterfaces(), r = this.parseConstDirectives(), s = this.parseFieldsDefinition();
            if (i.length === 0 && r.length === 0 && s.length === 0) throw this.unexpected();
            return this.node(t2, { kind: c.OBJECT_TYPE_EXTENSION, name: n, interfaces: i, directives: r, fields: s });
          }
          parseInterfaceTypeExtension() {
            let t2 = this._lexer.token;
            this.expectKeyword("extend"), this.expectKeyword("interface");
            let n = this.parseName(), i = this.parseImplementsInterfaces(), r = this.parseConstDirectives(), s = this.parseFieldsDefinition();
            if (i.length === 0 && r.length === 0 && s.length === 0) throw this.unexpected();
            return this.node(t2, { kind: c.INTERFACE_TYPE_EXTENSION, name: n, interfaces: i, directives: r, fields: s });
          }
          parseUnionTypeExtension() {
            let t2 = this._lexer.token;
            this.expectKeyword("extend"), this.expectKeyword("union");
            let n = this.parseName(), i = this.parseConstDirectives(), r = this.parseUnionMemberTypes();
            if (i.length === 0 && r.length === 0) throw this.unexpected();
            return this.node(t2, { kind: c.UNION_TYPE_EXTENSION, name: n, directives: i, types: r });
          }
          parseEnumTypeExtension() {
            let t2 = this._lexer.token;
            this.expectKeyword("extend"), this.expectKeyword("enum");
            let n = this.parseName(), i = this.parseConstDirectives(), r = this.parseEnumValuesDefinition();
            if (i.length === 0 && r.length === 0) throw this.unexpected();
            return this.node(t2, { kind: c.ENUM_TYPE_EXTENSION, name: n, directives: i, values: r });
          }
          parseInputObjectTypeExtension() {
            let t2 = this._lexer.token;
            this.expectKeyword("extend"), this.expectKeyword("input");
            let n = this.parseName(), i = this.parseConstDirectives(), r = this.parseInputFieldsDefinition();
            if (i.length === 0 && r.length === 0) throw this.unexpected();
            return this.node(t2, { kind: c.INPUT_OBJECT_TYPE_EXTENSION, name: n, directives: i, fields: r });
          }
          parseDirectiveDefinition() {
            let t2 = this._lexer.token, n = this.parseDescription();
            this.expectKeyword("directive"), this.expectToken(o.AT);
            let i = this.parseName(), r = this.parseArgumentDefs(), s = this.expectOptionalKeyword("repeatable");
            this.expectKeyword("on");
            let a = this.parseDirectiveLocations();
            return this.node(t2, { kind: c.DIRECTIVE_DEFINITION, description: n, name: i, arguments: r, repeatable: s, locations: a });
          }
          parseDirectiveLocations() {
            return this.delimitedMany(o.PIPE, this.parseDirectiveLocation);
          }
          parseDirectiveLocation() {
            let t2 = this._lexer.token, n = this.parseName();
            if (Object.prototype.hasOwnProperty.call(W2, n.value)) return n;
            throw this.unexpected(t2);
          }
          parseSchemaCoordinate() {
            let t2 = this._lexer.token, n = this.expectOptionalToken(o.AT), i = this.parseName(), r;
            !n && this.expectOptionalToken(o.DOT) && (r = this.parseName());
            let s;
            return (n || r) && this.expectOptionalToken(o.PAREN_L) && (s = this.parseName(), this.expectToken(o.COLON), this.expectToken(o.PAREN_R)), n ? s ? this.node(t2, { kind: c.DIRECTIVE_ARGUMENT_COORDINATE, name: i, argumentName: s }) : this.node(t2, { kind: c.DIRECTIVE_COORDINATE, name: i }) : r ? s ? this.node(t2, { kind: c.ARGUMENT_COORDINATE, name: i, fieldName: r, argumentName: s }) : this.node(t2, { kind: c.MEMBER_COORDINATE, name: i, memberName: r }) : this.node(t2, { kind: c.TYPE_COORDINATE, name: i });
          }
          node(t2, n) {
            return this._options.noLocation !== true && (n.loc = new H2(t2, this._lexer.lastToken, this._lexer.source)), n;
          }
          peek(t2) {
            return this._lexer.token.kind === t2;
          }
          expectToken(t2) {
            let n = this._lexer.token;
            if (n.kind === t2) return this.advanceLexer(), n;
            throw h(this._lexer.source, n.start, `Expected ${ct2(t2)}, found ${ne(n)}.`);
          }
          expectOptionalToken(t2) {
            return this._lexer.token.kind === t2 ? (this.advanceLexer(), true) : false;
          }
          expectKeyword(t2) {
            let n = this._lexer.token;
            if (n.kind === o.NAME && n.value === t2) this.advanceLexer();
            else throw h(this._lexer.source, n.start, `Expected "${t2}", found ${ne(n)}.`);
          }
          expectOptionalKeyword(t2) {
            let n = this._lexer.token;
            return n.kind === o.NAME && n.value === t2 ? (this.advanceLexer(), true) : false;
          }
          unexpected(t2) {
            let n = t2 ?? this._lexer.token;
            return h(this._lexer.source, n.start, `Unexpected ${ne(n)}.`);
          }
          any(t2, n, i) {
            this.expectToken(t2);
            let r = [];
            for (; !this.expectOptionalToken(i); ) r.push(n.call(this));
            return r;
          }
          optionalMany(t2, n, i) {
            if (this.expectOptionalToken(t2)) {
              let r = [];
              do
                r.push(n.call(this));
              while (!this.expectOptionalToken(i));
              return r;
            }
            return [];
          }
          many(t2, n, i) {
            this.expectToken(t2);
            let r = [];
            do
              r.push(n.call(this));
            while (!this.expectOptionalToken(i));
            return r;
          }
          delimitedMany(t2, n) {
            this.expectOptionalToken(t2);
            let i = [];
            do
              i.push(n.call(this));
            while (this.expectOptionalToken(t2));
            return i;
          }
          advanceLexer() {
            let { maxTokens: t2 } = this._options, n = this._lexer.advance();
            if (n.kind !== o.EOF && (++this._tokenCounter, t2 !== void 0 && this._tokenCounter > t2)) throw h(this._lexer.source, n.start, `Document contains more that ${t2} tokens. Parsing aborted.`);
          }
        };
        function ne(e) {
          let t2 = e.value;
          return ct2(e.kind) + (t2 != null ? ` "${t2}"` : "");
        }
        function ct2(e) {
          return nt2(e) ? `"${e}"` : e;
        }
        function en2(e, t2) {
          let n = new SyntaxError(e + " (" + t2.loc.start.line + ":" + t2.loc.start.column + ")");
          return Object.assign(n, t2);
        }
        var ut2 = en2;
        function tn2(e) {
          let t2 = [], { startToken: n, endToken: i } = e.loc;
          for (let r = n; r !== i; r = r.next) r.kind === "Comment" && t2.push({ ...r, loc: { start: r.start, end: r.end } });
          return t2;
        }
        var nn2 = { allowLegacyFragmentVariables: true };
        function rn2(e) {
          if (e?.name === "GraphQLError") {
            let { message: t2, locations: [n] } = e;
            return ut2(t2, { loc: { start: n }, cause: e });
          }
          return e;
        }
        function sn2(e) {
          let t2;
          try {
            t2 = at2(e, nn2);
          } catch (n) {
            throw rn2(n);
          }
          return t2.comments = tn2(t2), t2;
        }
        var on2 = { parse: sn2, astFormat: "graphql", hasPragma: Me2, hasIgnorePragma: Ve, locStart: J, locEnd: q2 };
        var an2 = { graphql: Ye2 };
        return dt2(cn);
      });
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/errors.js
  var ErrorHandler = class {
    constructor() {
      this.listeners = [];
      this.unexpectedErrorHandler = function(e) {
        setTimeout(() => {
          if (e.stack) {
            if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
              throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
            }
            throw new Error(e.message + "\n\n" + e.stack);
          }
          throw e;
        }, 0);
      };
    }
    emit(e) {
      this.listeners.forEach((listener) => {
        listener(e);
      });
    }
    onUnexpectedError(e) {
      this.unexpectedErrorHandler(e);
      this.emit(e);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e) {
      this.unexpectedErrorHandler(e);
    }
  };
  var errorHandler = new ErrorHandler();
  function onUnexpectedError(e) {
    if (!isCancellationError(e)) {
      errorHandler.onUnexpectedError(e);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      const { name: name2, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name: name2,
        message,
        stack,
        noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
      };
    }
    return error;
  }
  var canceledName = "Canceled";
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var CancellationError = class extends Error {
    constructor() {
      super(canceledName);
      this.name = this.message;
    }
  };
  var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
    constructor(msg) {
      super(msg);
      this.name = "CodeExpectedError";
    }
    static fromError(err) {
      if (err instanceof _ErrorNoTelemetry) {
        return err;
      }
      const result = new _ErrorNoTelemetry();
      result.message = err.message;
      result.stack = err.stack;
      return result;
    }
    static isErrorNoTelemetry(err) {
      return err.name === "CodeExpectedError";
    }
  };
  var BugIndicatingError = class _BugIndicatingError extends Error {
    constructor(message) {
      super(message || "An unexpected bug occurred.");
      Object.setPrototypeOf(this, _BugIndicatingError.prototype);
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/functional.js
  function createSingleCallFunction(fn, fnDidRunCallback) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      if (fnDidRunCallback) {
        try {
          result = fn.apply(_this, arguments);
        } finally {
          fnDidRunCallback();
        }
      } else {
        result = fn.apply(_this, arguments);
      }
      return result;
    };
  }

  // node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  (function(Iterable2) {
    function is(thing) {
      return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
    }
    Iterable2.is = is;
    const _empty2 = Object.freeze([]);
    function empty() {
      return _empty2;
    }
    Iterable2.empty = empty;
    function* single(element) {
      yield element;
    }
    Iterable2.single = single;
    function wrap2(iterableOrElement) {
      if (is(iterableOrElement)) {
        return iterableOrElement;
      } else {
        return single(iterableOrElement);
      }
    }
    Iterable2.wrap = wrap2;
    function from(iterable) {
      return iterable || _empty2;
    }
    Iterable2.from = from;
    function* reverse(array) {
      for (let i = array.length - 1; i >= 0; i--) {
        yield array[i];
      }
    }
    Iterable2.reverse = reverse;
    function isEmpty(iterable) {
      return !iterable || iterable[Symbol.iterator]().next().done === true;
    }
    Iterable2.isEmpty = isEmpty;
    function first(iterable) {
      return iterable[Symbol.iterator]().next().value;
    }
    Iterable2.first = first;
    function some(iterable, predicate) {
      let i = 0;
      for (const element of iterable) {
        if (predicate(element, i++)) {
          return true;
        }
      }
      return false;
    }
    Iterable2.some = some;
    function find(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return element;
        }
      }
      return void 0;
    }
    Iterable2.find = find;
    function* filter(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          yield element;
        }
      }
    }
    Iterable2.filter = filter;
    function* map(iterable, fn) {
      let index = 0;
      for (const element of iterable) {
        yield fn(element, index++);
      }
    }
    Iterable2.map = map;
    function* flatMap(iterable, fn) {
      let index = 0;
      for (const element of iterable) {
        yield* fn(element, index++);
      }
    }
    Iterable2.flatMap = flatMap;
    function* concat(...iterables) {
      for (const iterable of iterables) {
        yield* iterable;
      }
    }
    Iterable2.concat = concat;
    function reduce(iterable, reducer, initialValue) {
      let value = initialValue;
      for (const element of iterable) {
        value = reducer(value, element);
      }
      return value;
    }
    Iterable2.reduce = reduce;
    function* slice(arr, from2, to2 = arr.length) {
      if (from2 < 0) {
        from2 += arr.length;
      }
      if (to2 < 0) {
        to2 += arr.length;
      } else if (to2 > arr.length) {
        to2 = arr.length;
      }
      for (; from2 < to2; from2++) {
        yield arr[from2];
      }
    }
    Iterable2.slice = slice;
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
      const consumed = [];
      if (atMost === 0) {
        return [consumed, iterable];
      }
      const iterator = iterable[Symbol.iterator]();
      for (let i = 0; i < atMost; i++) {
        const next = iterator.next();
        if (next.done) {
          return [consumed, Iterable2.empty()];
        }
        consumed.push(next.value);
      }
      return [consumed, { [Symbol.iterator]() {
        return iterator;
      } }];
    }
    Iterable2.consume = consume;
    async function asyncToArray(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return Promise.resolve(result);
    }
    Iterable2.asyncToArray = asyncToArray;
  })(Iterable || (Iterable = {}));

  // node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  var TRACK_DISPOSABLES = false;
  var disposableTracker = null;
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  if (TRACK_DISPOSABLES) {
    const __is_disposable_tracked__ = "__is_disposable_tracked__";
    setDisposableTracker(new class {
      trackDisposable(x2) {
        const stack = new Error("Potentially leaked disposable").stack;
        setTimeout(() => {
          if (!x2[__is_disposable_tracked__]) {
            console.log(stack);
          }
        }, 3e3);
      }
      setParent(child, parent) {
        if (child && child !== Disposable.None) {
          try {
            child[__is_disposable_tracked__] = true;
          } catch {
          }
        }
      }
      markAsDisposed(disposable) {
        if (disposable && disposable !== Disposable.None) {
          try {
            disposable[__is_disposable_tracked__] = true;
          } catch {
          }
        }
      }
      markAsSingleton(disposable) {
      }
    }());
  }
  function trackDisposable(x2) {
    disposableTracker?.trackDisposable(x2);
    return x2;
  }
  function markAsDisposed(disposable) {
    disposableTracker?.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker?.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      const errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self2 = trackDisposable({
      dispose: createSingleCallFunction(() => {
        markAsDisposed(self2);
        fn();
      })
    });
    return self2;
  }
  var DisposableStore = class _DisposableStore {
    static {
      this.DISABLE_DISPOSED_WARNING = false;
    }
    constructor() {
      this._toDispose = /* @__PURE__ */ new Set();
      this._isDisposed = false;
      trackDisposable(this);
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
      if (this._isDisposed) {
        return;
      }
      markAsDisposed(this);
      this._isDisposed = true;
      this.clear();
    }
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
      if (this._toDispose.size === 0) {
        return;
      }
      try {
        dispose(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
    }
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add(o) {
      if (!o) {
        return o;
      }
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      setParentOfDisposable(o, this);
      if (this._isDisposed) {
        if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
          console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
        }
      } else {
        this._toDispose.add(o);
      }
      return o;
    }
    /**
     * Deletes the value from the store, but does not dispose it.
     */
    deleteAndLeak(o) {
      if (!o) {
        return;
      }
      if (this._toDispose.has(o)) {
        this._toDispose.delete(o);
        setParentOfDisposable(o, null);
      }
    }
  };
  var Disposable = class {
    static {
      this.None = Object.freeze({ dispose() {
      } });
    }
    constructor() {
      this._store = new DisposableStore();
      trackDisposable(this);
      setParentOfDisposable(this._store, this);
    }
    dispose() {
      markAsDisposed(this);
      this._store.dispose();
    }
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    _register(o) {
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      return this._store.add(o);
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node = class _Node {
    static {
      this.Undefined = new _Node(void 0);
    }
    constructor(element) {
      this.element = element;
      this.next = _Node.Undefined;
      this.prev = _Node.Undefined;
    }
  };
  var LinkedList = class {
    constructor() {
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._first === Node.Undefined;
    }
    clear() {
      let node = this._first;
      while (node !== Node.Undefined) {
        const next = node.next;
        node.prev = Node.Undefined;
        node.next = Node.Undefined;
        node = next;
      }
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    unshift(element) {
      return this._insert(element, false);
    }
    push(element) {
      return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
      const newNode = new Node(element);
      if (this._first === Node.Undefined) {
        this._first = newNode;
        this._last = newNode;
      } else if (atTheEnd) {
        const oldLast = this._last;
        this._last = newNode;
        newNode.prev = oldLast;
        oldLast.next = newNode;
      } else {
        const oldFirst = this._first;
        this._first = newNode;
        newNode.next = oldFirst;
        oldFirst.prev = newNode;
      }
      this._size += 1;
      let didRemove = false;
      return () => {
        if (!didRemove) {
          didRemove = true;
          this._remove(newNode);
        }
      };
    }
    shift() {
      if (this._first === Node.Undefined) {
        return void 0;
      } else {
        const res = this._first.element;
        this._remove(this._first);
        return res;
      }
    }
    pop() {
      if (this._last === Node.Undefined) {
        return void 0;
      } else {
        const res = this._last.element;
        this._remove(this._last);
        return res;
      }
    }
    _remove(node) {
      if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
        const anchor = node.prev;
        anchor.next = node.next;
        node.next.prev = anchor;
      } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
      } else if (node.next === Node.Undefined) {
        this._last = this._last.prev;
        this._last.next = Node.Undefined;
      } else if (node.prev === Node.Undefined) {
        this._first = this._first.next;
        this._first.prev = Node.Undefined;
      }
      this._size -= 1;
    }
    *[Symbol.iterator]() {
      let node = this._first;
      while (node !== Node.Undefined) {
        yield node.element;
        node = node.next;
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
  var StopWatch = class _StopWatch {
    static create(highResolution) {
      return new _StopWatch(highResolution);
    }
    constructor(highResolution) {
      this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
      this._startTime = this._now();
      this._stopTime = -1;
    }
    stop() {
      this._stopTime = this._now();
    }
    reset() {
      this._startTime = this._now();
      this._stopTime = -1;
    }
    elapsed() {
      if (this._stopTime !== -1) {
        return this._stopTime - this._startTime;
      }
      return this._now() - this._startTime;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableListenerGCedWarning = false;
  var _enableDisposeWithListenerWarning = false;
  var _enableSnapshotPotentialLeakWarning = false;
  var Event;
  (function(Event2) {
    Event2.None = () => Disposable.None;
    function _addLeakageTraceLogic(options) {
      if (_enableSnapshotPotentialLeakWarning) {
        const { onDidAddListener: origListenerDidAdd } = options;
        const stack = Stacktrace.create();
        let count = 0;
        options.onDidAddListener = () => {
          if (++count === 2) {
            console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
            stack.print();
          }
          origListenerDidAdd?.();
        };
      }
    }
    function defer(event, disposable) {
      return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
    }
    Event2.defer = defer;
    function once(event) {
      return (listener, thisArgs = null, disposables) => {
        let didFire = false;
        let result = void 0;
        result = event((e) => {
          if (didFire) {
            return;
          } else if (result) {
            result.dispose();
          } else {
            didFire = true;
          }
          return listener.call(thisArgs, e);
        }, null, disposables);
        if (didFire) {
          result.dispose();
        }
        return result;
      };
    }
    Event2.once = once;
    function onceIf(event, condition) {
      return Event2.once(Event2.filter(event, condition));
    }
    Event2.onceIf = onceIf;
    function map(event, map2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
    }
    Event2.map = map;
    function forEach(event, each, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => {
        each(i);
        listener.call(thisArgs, i);
      }, null, disposables), disposable);
    }
    Event2.forEach = forEach;
    function filter(event, filter2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
    }
    Event2.filter = filter;
    function signal(event) {
      return event;
    }
    Event2.signal = signal;
    function any(...events) {
      return (listener, thisArgs = null, disposables) => {
        const disposable = combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e))));
        return addAndReturnDisposable(disposable, disposables);
      };
    }
    Event2.any = any;
    function reduce(event, merge, initial, disposable) {
      let output = initial;
      return map(event, (e) => {
        output = merge(output, e);
        return output;
      }, disposable);
    }
    Event2.reduce = reduce;
    function snapshot(event, disposable) {
      let listener;
      const options = {
        onWillAddFirstListener() {
          listener = event(emitter.fire, emitter);
        },
        onDidRemoveLastListener() {
          listener?.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable?.add(emitter);
      return emitter.event;
    }
    function addAndReturnDisposable(d, store) {
      if (store instanceof Array) {
        store.push(d);
      } else if (store) {
        store.add(d);
      }
      return d;
    }
    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
      let subscription;
      let output = void 0;
      let handle = void 0;
      let numDebouncedCalls = 0;
      let doFire;
      const options = {
        leakWarningThreshold,
        onWillAddFirstListener() {
          subscription = event((cur) => {
            numDebouncedCalls++;
            output = merge(output, cur);
            if (leading && !handle) {
              emitter.fire(output);
              output = void 0;
            }
            doFire = () => {
              const _output = output;
              output = void 0;
              handle = void 0;
              if (!leading || numDebouncedCalls > 1) {
                emitter.fire(_output);
              }
              numDebouncedCalls = 0;
            };
            if (typeof delay === "number") {
              clearTimeout(handle);
              handle = setTimeout(doFire, delay);
            } else {
              if (handle === void 0) {
                handle = 0;
                queueMicrotask(doFire);
              }
            }
          });
        },
        onWillRemoveListener() {
          if (flushOnListenerRemove && numDebouncedCalls > 0) {
            doFire?.();
          }
        },
        onDidRemoveLastListener() {
          doFire = void 0;
          subscription.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable?.add(emitter);
      return emitter.event;
    }
    Event2.debounce = debounce;
    function accumulate(event, delay = 0, disposable) {
      return Event2.debounce(event, (last, e) => {
        if (!last) {
          return [e];
        }
        last.push(e);
        return last;
      }, delay, void 0, true, void 0, disposable);
    }
    Event2.accumulate = accumulate;
    function latch(event, equals3 = (a, b2) => a === b2, disposable) {
      let firstCall = true;
      let cache;
      return filter(event, (value) => {
        const shouldEmit = firstCall || !equals3(value, cache);
        firstCall = false;
        cache = value;
        return shouldEmit;
      }, disposable);
    }
    Event2.latch = latch;
    function split(event, isT, disposable) {
      return [
        Event2.filter(event, isT, disposable),
        Event2.filter(event, (e) => !isT(e), disposable)
      ];
    }
    Event2.split = split;
    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
      let buffer2 = _buffer.slice();
      let listener = event((e) => {
        if (buffer2) {
          buffer2.push(e);
        } else {
          emitter.fire(e);
        }
      });
      if (disposable) {
        disposable.add(listener);
      }
      const flush = () => {
        buffer2?.forEach((e) => emitter.fire(e));
        buffer2 = null;
      };
      const emitter = new Emitter({
        onWillAddFirstListener() {
          if (!listener) {
            listener = event((e) => emitter.fire(e));
            if (disposable) {
              disposable.add(listener);
            }
          }
        },
        onDidAddFirstListener() {
          if (buffer2) {
            if (flushAfterTimeout) {
              setTimeout(flush);
            } else {
              flush();
            }
          }
        },
        onDidRemoveLastListener() {
          if (listener) {
            listener.dispose();
          }
          listener = null;
        }
      });
      if (disposable) {
        disposable.add(emitter);
      }
      return emitter.event;
    }
    Event2.buffer = buffer;
    function chain(event, sythensize) {
      const fn = (listener, thisArgs, disposables) => {
        const cs = sythensize(new ChainableSynthesis());
        return event(function(value) {
          const result = cs.evaluate(value);
          if (result !== HaltChainable) {
            listener.call(thisArgs, result);
          }
        }, void 0, disposables);
      };
      return fn;
    }
    Event2.chain = chain;
    const HaltChainable = Symbol("HaltChainable");
    class ChainableSynthesis {
      constructor() {
        this.steps = [];
      }
      map(fn) {
        this.steps.push(fn);
        return this;
      }
      forEach(fn) {
        this.steps.push((v2) => {
          fn(v2);
          return v2;
        });
        return this;
      }
      filter(fn) {
        this.steps.push((v2) => fn(v2) ? v2 : HaltChainable);
        return this;
      }
      reduce(merge, initial) {
        let last = initial;
        this.steps.push((v2) => {
          last = merge(last, v2);
          return last;
        });
        return this;
      }
      latch(equals3 = (a, b2) => a === b2) {
        let firstCall = true;
        let cache;
        this.steps.push((value) => {
          const shouldEmit = firstCall || !equals3(value, cache);
          firstCall = false;
          cache = value;
          return shouldEmit ? value : HaltChainable;
        });
        return this;
      }
      evaluate(value) {
        for (const step of this.steps) {
          value = step(value);
          if (value === HaltChainable) {
            break;
          }
        }
        return value;
      }
    }
    function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
      const fn = (...args) => result.fire(map2(...args));
      const onFirstListenerAdd = () => emitter.on(eventName, fn);
      const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
      const fn = (...args) => result.fire(map2(...args));
      const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
      const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromDOMEventEmitter = fromDOMEventEmitter;
    function toPromise(event) {
      return new Promise((resolve2) => once(event)(resolve2));
    }
    Event2.toPromise = toPromise;
    function fromPromise(promise) {
      const result = new Emitter();
      promise.then((res) => {
        result.fire(res);
      }, () => {
        result.fire(void 0);
      }).finally(() => {
        result.dispose();
      });
      return result.event;
    }
    Event2.fromPromise = fromPromise;
    function forward(from, to2) {
      return from((e) => to2.fire(e));
    }
    Event2.forward = forward;
    function runAndSubscribe(event, handler, initial) {
      handler(initial);
      return event((e) => handler(e));
    }
    Event2.runAndSubscribe = runAndSubscribe;
    class EmitterObserver {
      constructor(_observable, store) {
        this._observable = _observable;
        this._counter = 0;
        this._hasChanged = false;
        const options = {
          onWillAddFirstListener: () => {
            _observable.addObserver(this);
            this._observable.reportChanges();
          },
          onDidRemoveLastListener: () => {
            _observable.removeObserver(this);
          }
        };
        if (!store) {
          _addLeakageTraceLogic(options);
        }
        this.emitter = new Emitter(options);
        if (store) {
          store.add(this.emitter);
        }
      }
      beginUpdate(_observable) {
        this._counter++;
      }
      handlePossibleChange(_observable) {
      }
      handleChange(_observable, _change) {
        this._hasChanged = true;
      }
      endUpdate(_observable) {
        this._counter--;
        if (this._counter === 0) {
          this._observable.reportChanges();
          if (this._hasChanged) {
            this._hasChanged = false;
            this.emitter.fire(this._observable.get());
          }
        }
      }
    }
    function fromObservable(obs, store) {
      const observer = new EmitterObserver(obs, store);
      return observer.emitter.event;
    }
    Event2.fromObservable = fromObservable;
    function fromObservableLight(observable) {
      return (listener, thisArgs, disposables) => {
        let count = 0;
        let didChange = false;
        const observer = {
          beginUpdate() {
            count++;
          },
          endUpdate() {
            count--;
            if (count === 0) {
              observable.reportChanges();
              if (didChange) {
                didChange = false;
                listener.call(thisArgs);
              }
            }
          },
          handlePossibleChange() {
          },
          handleChange() {
            didChange = true;
          }
        };
        observable.addObserver(observer);
        observable.reportChanges();
        const disposable = {
          dispose() {
            observable.removeObserver(observer);
          }
        };
        if (disposables instanceof DisposableStore) {
          disposables.add(disposable);
        } else if (Array.isArray(disposables)) {
          disposables.push(disposable);
        }
        return disposable;
      };
    }
    Event2.fromObservableLight = fromObservableLight;
  })(Event || (Event = {}));
  var EventProfiling = class _EventProfiling {
    static {
      this.all = /* @__PURE__ */ new Set();
    }
    static {
      this._idPool = 0;
    }
    constructor(name2) {
      this.listenerCount = 0;
      this.invocationCount = 0;
      this.elapsedOverall = 0;
      this.durations = [];
      this.name = `${name2}_${_EventProfiling._idPool++}`;
      _EventProfiling.all.add(this);
    }
    start(listenerCount) {
      this._stopWatch = new StopWatch();
      this.listenerCount = listenerCount;
    }
    stop() {
      if (this._stopWatch) {
        const elapsed = this._stopWatch.elapsed();
        this.durations.push(elapsed);
        this.elapsedOverall += elapsed;
        this.invocationCount += 1;
        this._stopWatch = void 0;
      }
    }
  };
  var _globalLeakWarningThreshold = -1;
  var LeakageMonitor = class _LeakageMonitor {
    static {
      this._idPool = 1;
    }
    constructor(_errorHandler, threshold, name2 = (_LeakageMonitor._idPool++).toString(16).padStart(3, "0")) {
      this._errorHandler = _errorHandler;
      this.threshold = threshold;
      this.name = name2;
      this._warnCountdown = 0;
    }
    dispose() {
      this._stacks?.clear();
    }
    check(stack, listenerCount) {
      const threshold = this.threshold;
      if (threshold <= 0 || listenerCount < threshold) {
        return void 0;
      }
      if (!this._stacks) {
        this._stacks = /* @__PURE__ */ new Map();
      }
      const count = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count + 1);
      this._warnCountdown -= 1;
      if (this._warnCountdown <= 0) {
        this._warnCountdown = threshold * 0.5;
        const [topStack, topCount] = this.getMostFrequentStack();
        const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;
        console.warn(message);
        console.warn(topStack);
        const error = new ListenerLeakError(message, topStack);
        this._errorHandler(error);
      }
      return () => {
        const count2 = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count2 - 1);
      };
    }
    getMostFrequentStack() {
      if (!this._stacks) {
        return void 0;
      }
      let topStack;
      let topCount = 0;
      for (const [stack, count] of this._stacks) {
        if (!topStack || topCount < count) {
          topStack = [stack, count];
          topCount = count;
        }
      }
      return topStack;
    }
  };
  var Stacktrace = class _Stacktrace {
    static create() {
      const err = new Error();
      return new _Stacktrace(err.stack ?? "");
    }
    constructor(value) {
      this.value = value;
    }
    print() {
      console.warn(this.value.split("\n").slice(2).join("\n"));
    }
  };
  var ListenerLeakError = class extends Error {
    constructor(message, stack) {
      super(message);
      this.name = "ListenerLeakError";
      this.stack = stack;
    }
  };
  var ListenerRefusalError = class extends Error {
    constructor(message, stack) {
      super(message);
      this.name = "ListenerRefusalError";
      this.stack = stack;
    }
  };
  var UniqueContainer = class {
    constructor(value) {
      this.value = value;
    }
  };
  var compactionThreshold = 2;
  var forEachListener = (listeners, fn) => {
    if (listeners instanceof UniqueContainer) {
      fn(listeners);
    } else {
      for (let i = 0; i < listeners.length; i++) {
        const l = listeners[i];
        if (l) {
          fn(l);
        }
      }
    }
  };
  var _listenerFinalizers;
  if (_enableListenerGCedWarning) {
    const leaks = [];
    setInterval(() => {
      if (leaks.length === 0) {
        return;
      }
      console.warn("[LEAKING LISTENERS] GC'ed these listeners that were NOT yet disposed:");
      console.warn(leaks.join("\n"));
      leaks.length = 0;
    }, 3e3);
    _listenerFinalizers = new FinalizationRegistry((heldValue) => {
      if (typeof heldValue === "string") {
        leaks.push(heldValue);
      }
    });
  }
  var Emitter = class {
    constructor(options) {
      this._size = 0;
      this._options = options;
      this._leakageMon = _globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold ? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) : void 0;
      this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : void 0;
      this._deliveryQueue = this._options?.deliveryQueue;
    }
    dispose() {
      if (!this._disposed) {
        this._disposed = true;
        if (this._deliveryQueue?.current === this) {
          this._deliveryQueue.reset();
        }
        if (this._listeners) {
          if (_enableDisposeWithListenerWarning) {
            const listeners = this._listeners;
            queueMicrotask(() => {
              forEachListener(listeners, (l) => l.stack?.print());
            });
          }
          this._listeners = void 0;
          this._size = 0;
        }
        this._options?.onDidRemoveLastListener?.();
        this._leakageMon?.dispose();
      }
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
      this._event ??= (callback, thisArgs, disposables) => {
        if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
          const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
          console.warn(message);
          const tuple = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1];
          const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);
          const errorHandler2 = this._options?.onListenerError || onUnexpectedError;
          errorHandler2(error);
          return Disposable.None;
        }
        if (this._disposed) {
          return Disposable.None;
        }
        if (thisArgs) {
          callback = callback.bind(thisArgs);
        }
        const contained = new UniqueContainer(callback);
        let removeMonitor;
        let stack;
        if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
          contained.stack = Stacktrace.create();
          removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
        }
        if (_enableDisposeWithListenerWarning) {
          contained.stack = stack ?? Stacktrace.create();
        }
        if (!this._listeners) {
          this._options?.onWillAddFirstListener?.(this);
          this._listeners = contained;
          this._options?.onDidAddFirstListener?.(this);
        } else if (this._listeners instanceof UniqueContainer) {
          this._deliveryQueue ??= new EventDeliveryQueuePrivate();
          this._listeners = [this._listeners, contained];
        } else {
          this._listeners.push(contained);
        }
        this._size++;
        const result = toDisposable(() => {
          _listenerFinalizers?.unregister(result);
          removeMonitor?.();
          this._removeListener(contained);
        });
        if (disposables instanceof DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }
        if (_listenerFinalizers) {
          const stack2 = new Error().stack.split("\n").slice(2, 3).join("\n").trim();
          const match = /(file:|vscode-file:\/\/vscode-app)?(\/[^:]*:\d+:\d+)/.exec(stack2);
          _listenerFinalizers.register(result, match?.[2] ?? stack2, result);
        }
        return result;
      };
      return this._event;
    }
    _removeListener(listener) {
      this._options?.onWillRemoveListener?.(this);
      if (!this._listeners) {
        return;
      }
      if (this._size === 1) {
        this._listeners = void 0;
        this._options?.onDidRemoveLastListener?.(this);
        this._size = 0;
        return;
      }
      const listeners = this._listeners;
      const index = listeners.indexOf(listener);
      if (index === -1) {
        console.log("disposed?", this._disposed);
        console.log("size?", this._size);
        console.log("arr?", JSON.stringify(this._listeners));
        throw new Error("Attempted to dispose unknown listener");
      }
      this._size--;
      listeners[index] = void 0;
      const adjustDeliveryQueue = this._deliveryQueue.current === this;
      if (this._size * compactionThreshold <= listeners.length) {
        let n = 0;
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i]) {
            listeners[n++] = listeners[i];
          } else if (adjustDeliveryQueue) {
            this._deliveryQueue.end--;
            if (n < this._deliveryQueue.i) {
              this._deliveryQueue.i--;
            }
          }
        }
        listeners.length = n;
      }
    }
    _deliver(listener, value) {
      if (!listener) {
        return;
      }
      const errorHandler2 = this._options?.onListenerError || onUnexpectedError;
      if (!errorHandler2) {
        listener.value(value);
        return;
      }
      try {
        listener.value(value);
      } catch (e) {
        errorHandler2(e);
      }
    }
    /** Delivers items in the queue. Assumes the queue is ready to go. */
    _deliverQueue(dq) {
      const listeners = dq.current._listeners;
      while (dq.i < dq.end) {
        this._deliver(listeners[dq.i++], dq.value);
      }
      dq.reset();
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
      if (this._deliveryQueue?.current) {
        this._deliverQueue(this._deliveryQueue);
        this._perfMon?.stop();
      }
      this._perfMon?.start(this._size);
      if (!this._listeners) {
      } else if (this._listeners instanceof UniqueContainer) {
        this._deliver(this._listeners, event);
      } else {
        const dq = this._deliveryQueue;
        dq.enqueue(this, event, this._listeners.length);
        this._deliverQueue(dq);
      }
      this._perfMon?.stop();
    }
    hasListeners() {
      return this._size > 0;
    }
  };
  var EventDeliveryQueuePrivate = class {
    constructor() {
      this.i = -1;
      this.end = 0;
    }
    enqueue(emitter, value, end) {
      this.i = 0;
      this.end = end;
      this.current = emitter;
      this.value = value;
    }
    reset() {
      this.i = this.end;
      this.current = void 0;
      this.value = void 0;
    }
  };

  // node_modules/monaco-editor/esm/vs/nls.messages.js
  function getNLSMessages() {
    return globalThis._VSCODE_NLS_MESSAGES;
  }
  function getNLSLanguage() {
    return globalThis._VSCODE_NLS_LANGUAGE;
  }

  // node_modules/monaco-editor/esm/vs/nls.js
  var isPseudo = getNLSLanguage() === "pseudo" || typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
  function _format(message, args) {
    let result;
    if (args.length === 0) {
      result = message;
    } else {
      result = message.replace(/\{(\d+)\}/g, (match, rest) => {
        const index = rest[0];
        const arg = args[index];
        let result2 = match;
        if (typeof arg === "string") {
          result2 = arg;
        } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
          result2 = String(arg);
        }
        return result2;
      });
    }
    if (isPseudo) {
      result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
    }
    return result;
  }
  function localize(data, message, ...args) {
    if (typeof data === "number") {
      return _format(lookupMessage(data, message), args);
    }
    return _format(message, args);
  }
  function lookupMessage(index, fallback) {
    const message = getNLSMessages()?.[index];
    if (typeof message !== "string") {
      if (typeof fallback === "string") {
        return fallback;
      }
      throw new Error(`!!! NLS MISSING: ${index} !!!`);
    }
    return message;
  }

  // node_modules/monaco-editor/esm/vs/base/common/platform.js
  var LANGUAGE_DEFAULT = "en";
  var _isWindows = false;
  var _isMacintosh = false;
  var _isLinux = false;
  var _isLinuxSnap = false;
  var _isNative = false;
  var _isWeb = false;
  var _isElectron = false;
  var _isIOS = false;
  var _isCI = false;
  var _isMobile = false;
  var _locale = void 0;
  var _language = LANGUAGE_DEFAULT;
  var _platformLocale = LANGUAGE_DEFAULT;
  var _translationsConfigFile = void 0;
  var _userAgent = void 0;
  var $globalThis = globalThis;
  var nodeProcess = void 0;
  if (typeof $globalThis.vscode !== "undefined" && typeof $globalThis.vscode.process !== "undefined") {
    nodeProcess = $globalThis.vscode.process;
  } else if (typeof process !== "undefined" && typeof process?.versions?.node === "string") {
    nodeProcess = process;
  }
  var isElectronProcess = typeof nodeProcess?.versions?.electron === "string";
  var isElectronRenderer = isElectronProcess && nodeProcess?.type === "renderer";
  if (typeof nodeProcess === "object") {
    _isWindows = nodeProcess.platform === "win32";
    _isMacintosh = nodeProcess.platform === "darwin";
    _isLinux = nodeProcess.platform === "linux";
    _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
    _isElectron = isElectronProcess;
    _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
    if (rawNlsConfig) {
      try {
        const nlsConfig = JSON.parse(rawNlsConfig);
        _locale = nlsConfig.userLocale;
        _platformLocale = nlsConfig.osLocale;
        _language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;
        _translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;
      } catch (e) {
      }
    }
    _isNative = true;
  } else if (typeof navigator === "object" && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf("Windows") >= 0;
    _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
    _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf("Linux") >= 0;
    _isMobile = _userAgent?.indexOf("Mobi") >= 0;
    _isWeb = true;
    _language = getNLSLanguage() || LANGUAGE_DEFAULT;
    _locale = navigator.language.toLowerCase();
    _platformLocale = _locale;
  } else {
    console.error("Unable to resolve platform.");
  }
  var _platform = 0;
  if (_isMacintosh) {
    _platform = 1;
  } else if (_isWindows) {
    _platform = 3;
  } else if (_isLinux) {
    _platform = 2;
  }
  var isWindows = _isWindows;
  var isMacintosh = _isMacintosh;
  var isNative = _isNative;
  var isWeb = _isWeb;
  var isWebWorker = _isWeb && typeof $globalThis.importScripts === "function";
  var webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;
  var userAgent = _userAgent;
  var setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
  var setTimeout0 = (() => {
    if (setTimeout0IsFaster) {
      const pending = [];
      $globalThis.addEventListener("message", (e) => {
        if (e.data && e.data.vscodeScheduleAsyncWork) {
          for (let i = 0, len = pending.length; i < len; i++) {
            const candidate = pending[i];
            if (candidate.id === e.data.vscodeScheduleAsyncWork) {
              pending.splice(i, 1);
              candidate.callback();
              return;
            }
          }
        }
      });
      let lastId = 0;
      return (callback) => {
        const myId = ++lastId;
        pending.push({
          id: myId,
          callback
        });
        $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
      };
    }
    return (callback) => setTimeout(callback);
  })();
  var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
  var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
  var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
  var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
  var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

  // node_modules/monaco-editor/esm/vs/base/common/cache.js
  function identity(t2) {
    return t2;
  }
  var LRUCachedFunction = class {
    constructor(arg1, arg2) {
      this.lastCache = void 0;
      this.lastArgKey = void 0;
      if (typeof arg1 === "function") {
        this._fn = arg1;
        this._computeKey = identity;
      } else {
        this._fn = arg2;
        this._computeKey = arg1.getCacheKey;
      }
    }
    get(arg) {
      const key = this._computeKey(arg);
      if (this.lastArgKey !== key) {
        this.lastArgKey = key;
        this.lastCache = this._fn(arg);
      }
      return this.lastCache;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy = class {
    constructor(executor) {
      this.executor = executor;
      this._didRun = false;
    }
    /**
     * Get the wrapped value.
     *
     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
     */
    get value() {
      if (!this._didRun) {
        try {
          this._value = this.executor();
        } catch (err) {
          this._error = err;
        } finally {
          this._didRun = true;
        }
      }
      if (this._error) {
        throw this._error;
      }
      return this._value;
    }
    /**
     * Get the wrapped value without forcing evaluation.
     */
    get rawValue() {
      return this._value;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/strings.js
  function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  var UTF8_BOM_CHARACTER = String.fromCharCode(
    65279
    /* CharCode.UTF8_BOM */
  );
  var GraphemeBreakTree = class _GraphemeBreakTree {
    static {
      this._INSTANCE = null;
    }
    static getInstance() {
      if (!_GraphemeBreakTree._INSTANCE) {
        _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
      }
      return _GraphemeBreakTree._INSTANCE;
    }
    constructor() {
      this._data = getGraphemeBreakRawData();
    }
    getGraphemeBreakType(codePoint) {
      if (codePoint < 32) {
        if (codePoint === 10) {
          return 3;
        }
        if (codePoint === 13) {
          return 2;
        }
        return 4;
      }
      if (codePoint < 127) {
        return 0;
      }
      const data = this._data;
      const nodeCount = data.length / 3;
      let nodeIndex = 1;
      while (nodeIndex <= nodeCount) {
        if (codePoint < data[3 * nodeIndex]) {
          nodeIndex = 2 * nodeIndex;
        } else if (codePoint > data[3 * nodeIndex + 1]) {
          nodeIndex = 2 * nodeIndex + 1;
        } else {
          return data[3 * nodeIndex + 2];
        }
      }
      return 0;
    }
  };
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var AmbiguousCharacters = class _AmbiguousCharacters {
    static {
      this.ambiguousCharacterData = new Lazy(() => {
        return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
      });
    }
    static {
      this.cache = new LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {
        function arrayToMap(arr) {
          const result = /* @__PURE__ */ new Map();
          for (let i = 0; i < arr.length; i += 2) {
            result.set(arr[i], arr[i + 1]);
          }
          return result;
        }
        function mergeMaps(map1, map2) {
          const result = new Map(map1);
          for (const [key, value] of map2) {
            result.set(key, value);
          }
          return result;
        }
        function intersectMaps(map1, map2) {
          if (!map1) {
            return map2;
          }
          const result = /* @__PURE__ */ new Map();
          for (const [key, value] of map1) {
            if (map2.has(key)) {
              result.set(key, value);
            }
          }
          return result;
        }
        const data = this.ambiguousCharacterData.value;
        let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
        if (filteredLocales.length === 0) {
          filteredLocales = ["_default"];
        }
        let languageSpecificMap = void 0;
        for (const locale of filteredLocales) {
          const map2 = arrayToMap(data[locale]);
          languageSpecificMap = intersectMaps(languageSpecificMap, map2);
        }
        const commonMap = arrayToMap(data["_common"]);
        const map = mergeMaps(commonMap, languageSpecificMap);
        return new _AmbiguousCharacters(map);
      });
    }
    static getInstance(locales) {
      return _AmbiguousCharacters.cache.get(Array.from(locales));
    }
    static {
      this._locales = new Lazy(() => Object.keys(_AmbiguousCharacters.ambiguousCharacterData.value).filter((k2) => !k2.startsWith("_")));
    }
    static getLocales() {
      return _AmbiguousCharacters._locales.value;
    }
    constructor(confusableDictionary) {
      this.confusableDictionary = confusableDictionary;
    }
    isAmbiguous(codePoint) {
      return this.confusableDictionary.has(codePoint);
    }
    /**
     * Returns the non basic ASCII code point that the given code point can be confused,
     * or undefined if such code point does note exist.
     */
    getPrimaryConfusable(codePoint) {
      return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
      return new Set(this.confusableDictionary.keys());
    }
  };
  var InvisibleCharacters = class _InvisibleCharacters {
    static getRawData() {
      return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
    }
    static {
      this._data = void 0;
    }
    static getData() {
      if (!this._data) {
        this._data = new Set(_InvisibleCharacters.getRawData());
      }
      return this._data;
    }
    static isInvisibleCharacter(codePoint) {
      return _InvisibleCharacters.getData().has(codePoint);
    }
    static get codePoints() {
      return _InvisibleCharacters.getData();
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess;
  var vscodeGlobal = globalThis.vscode;
  if (typeof vscodeGlobal !== "undefined" && typeof vscodeGlobal.process !== "undefined") {
    const sandboxProcess = vscodeGlobal.process;
    safeProcess = {
      get platform() {
        return sandboxProcess.platform;
      },
      get arch() {
        return sandboxProcess.arch;
      },
      get env() {
        return sandboxProcess.env;
      },
      cwd() {
        return sandboxProcess.cwd();
      }
    };
  } else if (typeof process !== "undefined" && typeof process?.versions?.node === "string") {
    safeProcess = {
      get platform() {
        return process.platform;
      },
      get arch() {
        return process.arch;
      },
      get env() {
        return process.env;
      },
      cwd() {
        return process.env["VSCODE_CWD"] || process.cwd();
      }
    };
  } else {
    safeProcess = {
      // Supported
      get platform() {
        return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
      },
      get arch() {
        return void 0;
      },
      // Unsupported
      get env() {
        return {};
      },
      cwd() {
        return "/";
      }
    };
  }
  var cwd = safeProcess.cwd;
  var env = safeProcess.env;
  var platform = safeProcess.platform;

  // node_modules/monaco-editor/esm/vs/base/common/path.js
  var CHAR_UPPERCASE_A = 65;
  var CHAR_LOWERCASE_A = 97;
  var CHAR_UPPERCASE_Z = 90;
  var CHAR_LOWERCASE_Z = 122;
  var CHAR_DOT = 46;
  var CHAR_FORWARD_SLASH = 47;
  var CHAR_BACKWARD_SLASH = 92;
  var CHAR_COLON = 58;
  var CHAR_QUESTION_MARK = 63;
  var ErrorInvalidArgType = class extends Error {
    constructor(name2, expected, actual) {
      let determiner;
      if (typeof expected === "string" && expected.indexOf("not ") === 0) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      const type2 = name2.indexOf(".") !== -1 ? "property" : "argument";
      let msg = `The "${name2}" ${type2} ${determiner} of type ${expected}`;
      msg += `. Received type ${typeof actual}`;
      super(msg);
      this.code = "ERR_INVALID_ARG_TYPE";
    }
  };
  function validateObject(pathObject, name2) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType(name2, "Object", pathObject);
    }
  }
  function validateString(value, name2) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name2, "string", value);
    }
  }
  var platformIsWin32 = platform === "win32";
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (isPathSeparator2(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i)}`;
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function formatExt(ext) {
    return ext ? `${ext[0] === "." ? "" : "."}${ext}` : "";
  }
  function _format2(sep2, pathObject) {
    validateObject(pathObject, "pathObject");
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${formatExt(pathObject.ext)}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedDevice = "";
      let resolvedTail = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1; i--) {
        let path;
        if (i >= 0) {
          path = pathSegments[i];
          validateString(path, `paths[${i}]`);
          if (path.length === 0) {
            continue;
          }
        } else if (resolvedDevice.length === 0) {
          path = cwd();
        } else {
          path = env[`=${resolvedDevice}`] || cwd();
          if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            path = `${resolvedDevice}\\`;
          }
        }
        const len = path.length;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len === 1) {
          if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
          }
        } else if (isPathSeparator(code)) {
          isAbsolute = true;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              const firstPart = path.slice(last, j2);
              last = j2;
              while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                  j2++;
                }
                if (j2 === len || j2 !== last) {
                  device = `\\\\${firstPart}\\${path.slice(last, j2)}`;
                  rootEnd = j2;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
            isAbsolute = true;
            rootEnd = 3;
          }
        }
        if (device.length > 0) {
          if (resolvedDevice.length > 0) {
            if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
              continue;
            }
          } else {
            resolvedDevice = device;
          }
        }
        if (resolvedAbsolute) {
          if (resolvedDevice.length > 0) {
            break;
          }
        } else {
          resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
          resolvedAbsolute = isAbsolute;
          if (isAbsolute && resolvedDevice.length > 0) {
            break;
          }
        }
      }
      resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
      return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
    },
    normalize(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = 0;
      let device;
      let isAbsolute = false;
      const code = path.charCodeAt(0);
      if (len === 1) {
        return isPosixPathSeparator(code) ? "\\" : path;
      }
      if (isPathSeparator(code)) {
        isAbsolute = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
            j2++;
          }
          if (j2 < len && j2 !== last) {
            const firstPart = path.slice(last, j2);
            last = j2;
            while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 === len) {
                return `\\\\${firstPart}\\${path.slice(last)}\\`;
              }
              if (j2 !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j2)}`;
                rootEnd = j2;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute = true;
          rootEnd = 3;
        }
      }
      let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
      if (tail.length === 0 && !isAbsolute) {
        tail = ".";
      }
      if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
      }
      if (device === void 0) {
        return isAbsolute ? `\\${tail}` : tail;
      }
      return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return false;
      }
      const code = path.charCodeAt(0);
      return isPathSeparator(code) || // Possible device root
      len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      let firstPart;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = firstPart = arg;
          } else {
            joined += `\\${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      let needsReplace = true;
      let slashCount = 0;
      if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
          ++slashCount;
          if (firstLen > 2) {
            if (isPathSeparator(firstPart.charCodeAt(2))) {
              ++slashCount;
            } else {
              needsReplace = false;
            }
          }
        }
      }
      if (needsReplace) {
        while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
          slashCount++;
        }
        if (slashCount >= 2) {
          joined = `\\${joined.slice(slashCount)}`;
        }
      }
      return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to2) {
      validateString(from, "from");
      validateString(to2, "to");
      if (from === to2) {
        return "";
      }
      const fromOrig = win32.resolve(from);
      const toOrig = win32.resolve(to2);
      if (fromOrig === toOrig) {
        return "";
      }
      from = fromOrig.toLowerCase();
      to2 = toOrig.toLowerCase();
      if (from === to2) {
        return "";
      }
      let fromStart = 0;
      while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
        fromStart++;
      }
      let fromEnd = from.length;
      while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
        fromEnd--;
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 0;
      while (toStart < to2.length && to2.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        toStart++;
      }
      let toEnd = to2.length;
      while (toEnd - 1 > toStart && to2.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
        toEnd--;
      }
      const toLen = toEnd - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to2.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i !== length) {
        if (lastCommonSep === -1) {
          return toOrig;
        }
      } else {
        if (toLen > length) {
          if (to2.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
            return toOrig.slice(toStart + i + 1);
          }
          if (i === 2) {
            return toOrig.slice(toStart + i);
          }
        }
        if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 2) {
            lastCommonSep = 3;
          }
        }
        if (lastCommonSep === -1) {
          lastCommonSep = 0;
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
          out += out.length === 0 ? ".." : "\\..";
        }
      }
      toStart += lastCommonSep;
      if (out.length > 0) {
        return `${out}${toOrig.slice(toStart, toEnd)}`;
      }
      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        ++toStart;
      }
      return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path) {
      if (typeof path !== "string" || path.length === 0) {
        return path;
      }
      const resolvedPath = win32.resolve(path);
      if (resolvedPath.length <= 2) {
        return path;
      }
      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
          const code = resolvedPath.charCodeAt(2);
          if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
            return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
          }
        }
      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = -1;
      let offset = 0;
      const code = path.charCodeAt(0);
      if (len === 1) {
        return isPathSeparator(code) ? path : ".";
      }
      if (isPathSeparator(code)) {
        rootEnd = offset = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
            j2++;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 === len) {
                return path;
              }
              if (j2 !== last) {
                rootEnd = offset = j2 + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
        offset = rootEnd;
      }
      let end = -1;
      let matchedSlash = true;
      for (let i = len - 1; i >= offset; --i) {
        if (isPathSeparator(path.charCodeAt(i))) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        if (rootEnd === -1) {
          return ".";
        }
        end = rootEnd;
      }
      return path.slice(0, end);
    },
    basename(path, suffix) {
      if (suffix !== void 0) {
        validateString(suffix, "suffix");
      }
      validateString(path, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
        start = 2;
      }
      if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
        if (suffix === path) {
          return "";
        }
        let extIdx = suffix.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= start; --i) {
          const code = path.charCodeAt(i);
          if (isPathSeparator(code)) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === suffix.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start, end);
      }
      for (i = path.length - 1; i >= start; --i) {
        if (isPathSeparator(path.charCodeAt(i))) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start, end);
    },
    extname(path) {
      validateString(path, "path");
      let start = 0;
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
      }
      for (let i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "\\"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const len = path.length;
      let rootEnd = 0;
      let code = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          ret.root = ret.dir = path;
          return ret;
        }
        ret.base = ret.name = path;
        return ret;
      }
      if (isPathSeparator(code)) {
        rootEnd = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
            j2++;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 === len) {
                rootEnd = j2;
              } else if (j2 !== last) {
                rootEnd = j2 + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        if (len <= 2) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 2;
        if (isPathSeparator(path.charCodeAt(2))) {
          if (len === 3) {
            ret.root = ret.dir = path;
            return ret;
          }
          rootEnd = 3;
        }
      }
      if (rootEnd > 0) {
        ret.root = path.slice(0, rootEnd);
      }
      let startDot = -1;
      let startPart = rootEnd;
      let end = -1;
      let matchedSlash = true;
      let i = path.length - 1;
      let preDotState = 0;
      for (; i >= rootEnd; --i) {
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(startPart, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
      } else {
        ret.dir = ret.root;
      }
      return ret;
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null
  };
  var posixCwd = (() => {
    if (platformIsWin32) {
      const regexp = /\\/g;
      return () => {
        const cwd2 = cwd().replace(regexp, "/");
        return cwd2.slice(cwd2.indexOf("/"));
      };
    }
    return () => cwd();
  })();
  var posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        const path = i >= 0 ? pathSegments[i] : posixCwd();
        validateString(path, `paths[${i}]`);
        if (path.length === 0) {
          continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
      if (resolvedAbsolute) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    },
    normalize(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
      path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
      if (path.length === 0) {
        if (isAbsolute) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path += "/";
      }
      return isAbsolute ? `/${path}` : path;
    },
    isAbsolute(path) {
      validateString(path, "path");
      return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = arg;
          } else {
            joined += `/${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return posix.normalize(joined);
    },
    relative(from, to2) {
      validateString(from, "from");
      validateString(to2, "to");
      if (from === to2) {
        return "";
      }
      from = posix.resolve(from);
      to2 = posix.resolve(to2);
      if (from === to2) {
        return "";
      }
      const fromStart = 1;
      const fromEnd = from.length;
      const fromLen = fromEnd - fromStart;
      const toStart = 1;
      const toLen = to2.length - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to2.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i === length) {
        if (toLen > length) {
          if (to2.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
            return to2.slice(toStart + i + 1);
          }
          if (i === 0) {
            return to2.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          out += out.length === 0 ? ".." : "/..";
        }
      }
      return `${out}${to2.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path) {
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let end = -1;
      let matchedSlash = true;
      for (let i = path.length - 1; i >= 1; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end === 1) {
        return "//";
      }
      return path.slice(0, end);
    },
    basename(path, suffix) {
      if (suffix !== void 0) {
        validateString(suffix, "ext");
      }
      validateString(path, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
        if (suffix === path) {
          return "";
        }
        let extIdx = suffix.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= 0; --i) {
          const code = path.charCodeAt(i);
          if (code === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === suffix.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start, end);
      }
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start, end);
    },
    extname(path) {
      validateString(path, "path");
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "/"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i = path.length - 1;
      let preDotState = 0;
      for (; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(start2, end);
        } else {
          ret.name = path.slice(start2, startDot);
          ret.base = path.slice(start2, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0) {
        ret.dir = path.slice(0, startPart - 1);
      } else if (isAbsolute) {
        ret.dir = "/";
      }
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.win32 = win32.win32 = win32;
  posix.posix = win32.posix = posix;
  var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
  var join = platformIsWin32 ? win32.join : posix.join;
  var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
  var relative = platformIsWin32 ? win32.relative : posix.relative;
  var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
  var basename = platformIsWin32 ? win32.basename : posix.basename;
  var extname = platformIsWin32 ? win32.extname : posix.extname;
  var sep = platformIsWin32 ? win32.sep : posix.sep;

  // node_modules/monaco-editor/esm/vs/base/common/uri.js
  var _schemePattern = /^\w[\w\d+.-]*$/;
  var _singleSlashStart = /^\//;
  var _doubleSlashStart = /^\/\//;
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  var _empty = "";
  var _slash = "/";
  var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  var URI = class _URI {
    static isUri(thing) {
      if (thing instanceof _URI) {
        return true;
      }
      if (!thing) {
        return false;
      }
      return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
    }
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
      if (typeof schemeOrData === "object") {
        this.scheme = schemeOrData.scheme || _empty;
        this.authority = schemeOrData.authority || _empty;
        this.path = schemeOrData.path || _empty;
        this.query = schemeOrData.query || _empty;
        this.fragment = schemeOrData.fragment || _empty;
      } else {
        this.scheme = _schemeFix(schemeOrData, _strict);
        this.authority = authority || _empty;
        this.path = _referenceResolution(this.scheme, path || _empty);
        this.query = query || _empty;
        this.fragment = fragment || _empty;
        _validateUri(this, _strict);
      }
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
      return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
      if (!change) {
        return this;
      }
      let { scheme, authority, path, query, fragment } = change;
      if (scheme === void 0) {
        scheme = this.scheme;
      } else if (scheme === null) {
        scheme = _empty;
      }
      if (authority === void 0) {
        authority = this.authority;
      } else if (authority === null) {
        authority = _empty;
      }
      if (path === void 0) {
        path = this.path;
      } else if (path === null) {
        path = _empty;
      }
      if (query === void 0) {
        query = this.query;
      } else if (query === null) {
        query = _empty;
      }
      if (fragment === void 0) {
        fragment = this.fragment;
      } else if (fragment === null) {
        fragment = _empty;
      }
      if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
        return this;
      }
      return new Uri(scheme, authority, path, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value, _strict = false) {
      const match = _regexp.exec(value);
      if (!match) {
        return new Uri(_empty, _empty, _empty, _empty, _empty);
      }
      return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path) {
      let authority = _empty;
      if (isWindows) {
        path = path.replace(/\\/g, _slash);
      }
      if (path[0] === _slash && path[1] === _slash) {
        const idx = path.indexOf(_slash, 2);
        if (idx === -1) {
          authority = path.substring(2);
          path = _slash;
        } else {
          authority = path.substring(2, idx);
          path = path.substring(idx) || _slash;
        }
      }
      return new Uri("file", authority, path, _empty, _empty);
    }
    /**
     * Creates new URI from uri components.
     *
     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
     * validation and should be used for untrusted uri components retrieved from storage,
     * user input, command arguments etc
     */
    static from(components, strict) {
      const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
      return result;
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
      if (!uri.path) {
        throw new Error(`[UriError]: cannot call joinPath on URI without path`);
      }
      let newPath;
      if (isWindows && uri.scheme === "file") {
        newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
      } else {
        newPath = posix.join(uri.path, ...pathFragment);
      }
      return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
      return _asFormatted(this, skipEncoding);
    }
    toJSON() {
      return this;
    }
    static revive(data) {
      if (!data) {
        return data;
      } else if (data instanceof _URI) {
        return data;
      } else {
        const result = new Uri(data);
        result._formatted = data.external ?? null;
        result._fsPath = data._sep === _pathSepMarker ? data.fsPath ?? null : null;
        return result;
      }
    }
  };
  var _pathSepMarker = isWindows ? 1 : void 0;
  var Uri = class extends URI {
    constructor() {
      super(...arguments);
      this._formatted = null;
      this._fsPath = null;
    }
    get fsPath() {
      if (!this._fsPath) {
        this._fsPath = uriToFsPath(this, false);
      }
      return this._fsPath;
    }
    toString(skipEncoding = false) {
      if (!skipEncoding) {
        if (!this._formatted) {
          this._formatted = _asFormatted(this, false);
        }
        return this._formatted;
      } else {
        return _asFormatted(this, true);
      }
    }
    toJSON() {
      const res = {
        $mid: 1
        /* MarshalledId.Uri */
      };
      if (this._fsPath) {
        res.fsPath = this._fsPath;
        res._sep = _pathSepMarker;
      }
      if (this._formatted) {
        res.external = this._formatted;
      }
      if (this.path) {
        res.path = this.path;
      }
      if (this.scheme) {
        res.scheme = this.scheme;
      }
      if (this.authority) {
        res.authority = this.authority;
      }
      if (this.query) {
        res.query = this.query;
      }
      if (this.fragment) {
        res.fragment = this.fragment;
      }
      return res;
    }
  };
  var encodeTable = {
    [
      58
      /* CharCode.Colon */
    ]: "%3A",
    // gen-delims
    [
      47
      /* CharCode.Slash */
    ]: "%2F",
    [
      63
      /* CharCode.QuestionMark */
    ]: "%3F",
    [
      35
      /* CharCode.Hash */
    ]: "%23",
    [
      91
      /* CharCode.OpenSquareBracket */
    ]: "%5B",
    [
      93
      /* CharCode.CloseSquareBracket */
    ]: "%5D",
    [
      64
      /* CharCode.AtSign */
    ]: "%40",
    [
      33
      /* CharCode.ExclamationMark */
    ]: "%21",
    // sub-delims
    [
      36
      /* CharCode.DollarSign */
    ]: "%24",
    [
      38
      /* CharCode.Ampersand */
    ]: "%26",
    [
      39
      /* CharCode.SingleQuote */
    ]: "%27",
    [
      40
      /* CharCode.OpenParen */
    ]: "%28",
    [
      41
      /* CharCode.CloseParen */
    ]: "%29",
    [
      42
      /* CharCode.Asterisk */
    ]: "%2A",
    [
      43
      /* CharCode.Plus */
    ]: "%2B",
    [
      44
      /* CharCode.Comma */
    ]: "%2C",
    [
      59
      /* CharCode.Semicolon */
    ]: "%3B",
    [
      61
      /* CharCode.Equals */
    ]: "%3D",
    [
      32
      /* CharCode.Space */
    ]: "%20"
  };
  function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code = path.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value = uri.path.substr(1);
      }
    } else {
      value = uri.path;
    }
    if (isWindows) {
      value = value.replace(/\//g, "\\");
    }
    return value;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false, false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false, true);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(authority, false, true);
      } else {
        res += encoder(authority.substr(0, idx), false, true);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code = path.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code = path.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true, false);
    }
    if (query) {
      res += "?";
      res += encoder(query, false, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }

  // node_modules/monaco-editor/esm/vs/base/common/network.js
  var Schemas;
  (function(Schemas2) {
    Schemas2.inMemory = "inmemory";
    Schemas2.vscode = "vscode";
    Schemas2.internal = "private";
    Schemas2.walkThrough = "walkThrough";
    Schemas2.walkThroughSnippet = "walkThroughSnippet";
    Schemas2.http = "http";
    Schemas2.https = "https";
    Schemas2.file = "file";
    Schemas2.mailto = "mailto";
    Schemas2.untitled = "untitled";
    Schemas2.data = "data";
    Schemas2.command = "command";
    Schemas2.vscodeRemote = "vscode-remote";
    Schemas2.vscodeRemoteResource = "vscode-remote-resource";
    Schemas2.vscodeManagedRemoteResource = "vscode-managed-remote-resource";
    Schemas2.vscodeUserData = "vscode-userdata";
    Schemas2.vscodeCustomEditor = "vscode-custom-editor";
    Schemas2.vscodeNotebookCell = "vscode-notebook-cell";
    Schemas2.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata";
    Schemas2.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff";
    Schemas2.vscodeNotebookCellOutput = "vscode-notebook-cell-output";
    Schemas2.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff";
    Schemas2.vscodeNotebookMetadata = "vscode-notebook-metadata";
    Schemas2.vscodeInteractiveInput = "vscode-interactive-input";
    Schemas2.vscodeSettings = "vscode-settings";
    Schemas2.vscodeWorkspaceTrust = "vscode-workspace-trust";
    Schemas2.vscodeTerminal = "vscode-terminal";
    Schemas2.vscodeChatCodeBlock = "vscode-chat-code-block";
    Schemas2.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block";
    Schemas2.vscodeChatSesssion = "vscode-chat-editor";
    Schemas2.webviewPanel = "webview-panel";
    Schemas2.vscodeWebview = "vscode-webview";
    Schemas2.extension = "extension";
    Schemas2.vscodeFileResource = "vscode-file";
    Schemas2.tmp = "tmp";
    Schemas2.vsls = "vsls";
    Schemas2.vscodeSourceControl = "vscode-scm";
    Schemas2.commentsInput = "comment";
    Schemas2.codeSetting = "code-setting";
    Schemas2.outputChannel = "output";
  })(Schemas || (Schemas = {}));
  var connectionTokenQueryName = "tkn";
  var RemoteAuthoritiesImpl = class {
    constructor() {
      this._hosts = /* @__PURE__ */ Object.create(null);
      this._ports = /* @__PURE__ */ Object.create(null);
      this._connectionTokens = /* @__PURE__ */ Object.create(null);
      this._preferredWebSchema = "http";
      this._delegate = null;
      this._serverRootPath = "/";
    }
    setPreferredWebSchema(schema) {
      this._preferredWebSchema = schema;
    }
    get _remoteResourcesPath() {
      return posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);
    }
    rewrite(uri) {
      if (this._delegate) {
        try {
          return this._delegate(uri);
        } catch (err) {
          onUnexpectedError(err);
          return uri;
        }
      }
      const authority = uri.authority;
      let host = this._hosts[authority];
      if (host && host.indexOf(":") !== -1 && host.indexOf("[") === -1) {
        host = `[${host}]`;
      }
      const port = this._ports[authority];
      const connectionToken = this._connectionTokens[authority];
      let query = `path=${encodeURIComponent(uri.path)}`;
      if (typeof connectionToken === "string") {
        query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
      }
      return URI.from({
        scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
        authority: `${host}:${port}`,
        path: this._remoteResourcesPath,
        query
      });
    }
  };
  var RemoteAuthorities = new RemoteAuthoritiesImpl();
  var VSCODE_AUTHORITY = "vscode-app";
  var FileAccessImpl = class _FileAccessImpl {
    static {
      this.FALLBACK_AUTHORITY = VSCODE_AUTHORITY;
    }
    /**
     * Returns a URI to use in contexts where the browser is responsible
     * for loading (e.g. fetch()) or when used within the DOM.
     *
     * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
     */
    asBrowserUri(resourcePath) {
      const uri = this.toUri(resourcePath);
      return this.uriToBrowserUri(uri);
    }
    /**
     * Returns a URI to use in contexts where the browser is responsible
     * for loading (e.g. fetch()) or when used within the DOM.
     *
     * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
     */
    uriToBrowserUri(uri) {
      if (uri.scheme === Schemas.vscodeRemote) {
        return RemoteAuthorities.rewrite(uri);
      }
      if (
        // ...only ever for `file` resources
        uri.scheme === Schemas.file && // ...and we run in native environments
        (isNative || // ...or web worker extensions on desktop
        webWorkerOrigin === `${Schemas.vscodeFileResource}://${_FileAccessImpl.FALLBACK_AUTHORITY}`)
      ) {
        return uri.with({
          scheme: Schemas.vscodeFileResource,
          // We need to provide an authority here so that it can serve
          // as origin for network and loading matters in chromium.
          // If the URI is not coming with an authority already, we
          // add our own
          authority: uri.authority || _FileAccessImpl.FALLBACK_AUTHORITY,
          query: null,
          fragment: null
        });
      }
      return uri;
    }
    toUri(uriOrModule, moduleIdToUrl) {
      if (URI.isUri(uriOrModule)) {
        return uriOrModule;
      }
      if (globalThis._VSCODE_FILE_ROOT) {
        const rootUriOrPath = globalThis._VSCODE_FILE_ROOT;
        if (/^\w[\w\d+.-]*:\/\//.test(rootUriOrPath)) {
          return URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);
        }
        const modulePath = join(rootUriOrPath, uriOrModule);
        return URI.file(modulePath);
      }
      return URI.parse(moduleIdToUrl.toUrl(uriOrModule));
    }
  };
  var FileAccess = new FileAccessImpl();
  var COI;
  (function(COI2) {
    const coiHeaders = /* @__PURE__ */ new Map([
      ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
      ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
      ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
    ]);
    COI2.CoopAndCoep = Object.freeze(coiHeaders.get("3"));
    const coiSearchParamName = "vscode-coi";
    function getHeadersFromQuery(url) {
      let params;
      if (typeof url === "string") {
        params = new URL(url).searchParams;
      } else if (url instanceof URL) {
        params = url.searchParams;
      } else if (URI.isUri(url)) {
        params = new URL(url.toString(true)).searchParams;
      }
      const value = params?.get(coiSearchParamName);
      if (!value) {
        return void 0;
      }
      return coiHeaders.get(value);
    }
    COI2.getHeadersFromQuery = getHeadersFromQuery;
    function addSearchParam(urlOrSearch, coop, coep) {
      if (!globalThis.crossOriginIsolated) {
        return;
      }
      const value = coop && coep ? "3" : coep ? "2" : "1";
      if (urlOrSearch instanceof URLSearchParams) {
        urlOrSearch.set(coiSearchParamName, value);
      } else {
        urlOrSearch[coiSearchParamName] = value;
      }
    }
    COI2.addSearchParam = addSearchParam;
  })(COI || (COI = {}));

  // node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
  var isESM = true;
  var DEFAULT_CHANNEL = "default";
  var INITIALIZE = "$initialize";
  var RequestMessage = class {
    constructor(vsWorker, req, channel, method, args) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.channel = channel;
      this.method = method;
      this.args = args;
      this.type = 0;
    }
  };
  var ReplyMessage = class {
    constructor(vsWorker, seq, res, err) {
      this.vsWorker = vsWorker;
      this.seq = seq;
      this.res = res;
      this.err = err;
      this.type = 1;
    }
  };
  var SubscribeEventMessage = class {
    constructor(vsWorker, req, channel, eventName, arg) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.channel = channel;
      this.eventName = eventName;
      this.arg = arg;
      this.type = 2;
    }
  };
  var EventMessage = class {
    constructor(vsWorker, req, event) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.event = event;
      this.type = 3;
    }
  };
  var UnsubscribeEventMessage = class {
    constructor(vsWorker, req) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.type = 4;
    }
  };
  var SimpleWorkerProtocol = class {
    constructor(handler) {
      this._workerId = -1;
      this._handler = handler;
      this._lastSentReq = 0;
      this._pendingReplies = /* @__PURE__ */ Object.create(null);
      this._pendingEmitters = /* @__PURE__ */ new Map();
      this._pendingEvents = /* @__PURE__ */ new Map();
    }
    setWorkerId(workerId) {
      this._workerId = workerId;
    }
    sendMessage(channel, method, args) {
      const req = String(++this._lastSentReq);
      return new Promise((resolve2, reject) => {
        this._pendingReplies[req] = {
          resolve: resolve2,
          reject
        };
        this._send(new RequestMessage(this._workerId, req, channel, method, args));
      });
    }
    listen(channel, eventName, arg) {
      let req = null;
      const emitter = new Emitter({
        onWillAddFirstListener: () => {
          req = String(++this._lastSentReq);
          this._pendingEmitters.set(req, emitter);
          this._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));
        },
        onDidRemoveLastListener: () => {
          this._pendingEmitters.delete(req);
          this._send(new UnsubscribeEventMessage(this._workerId, req));
          req = null;
        }
      });
      return emitter.event;
    }
    handleMessage(message) {
      if (!message || !message.vsWorker) {
        return;
      }
      if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
        return;
      }
      this._handleMessage(message);
    }
    createProxyToRemoteChannel(channel, sendMessageBarrier) {
      const handler = {
        get: (target, name2) => {
          if (typeof name2 === "string" && !target[name2]) {
            if (propertyIsDynamicEvent(name2)) {
              target[name2] = (arg) => {
                return this.listen(channel, name2, arg);
              };
            } else if (propertyIsEvent(name2)) {
              target[name2] = this.listen(channel, name2, void 0);
            } else if (name2.charCodeAt(0) === 36) {
              target[name2] = async (...myArgs) => {
                await sendMessageBarrier?.();
                return this.sendMessage(channel, name2, myArgs);
              };
            }
          }
          return target[name2];
        }
      };
      return new Proxy(/* @__PURE__ */ Object.create(null), handler);
    }
    _handleMessage(msg) {
      switch (msg.type) {
        case 1:
          return this._handleReplyMessage(msg);
        case 0:
          return this._handleRequestMessage(msg);
        case 2:
          return this._handleSubscribeEventMessage(msg);
        case 3:
          return this._handleEventMessage(msg);
        case 4:
          return this._handleUnsubscribeEventMessage(msg);
      }
    }
    _handleReplyMessage(replyMessage) {
      if (!this._pendingReplies[replyMessage.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      const reply = this._pendingReplies[replyMessage.seq];
      delete this._pendingReplies[replyMessage.seq];
      if (replyMessage.err) {
        let err = replyMessage.err;
        if (replyMessage.err.$isError) {
          err = new Error();
          err.name = replyMessage.err.name;
          err.message = replyMessage.err.message;
          err.stack = replyMessage.err.stack;
        }
        reply.reject(err);
        return;
      }
      reply.resolve(replyMessage.res);
    }
    _handleRequestMessage(requestMessage) {
      const req = requestMessage.req;
      const result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);
      result.then((r) => {
        this._send(new ReplyMessage(this._workerId, req, r, void 0));
      }, (e) => {
        if (e.detail instanceof Error) {
          e.detail = transformErrorForSerialization(e.detail);
        }
        this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
      });
    }
    _handleSubscribeEventMessage(msg) {
      const req = msg.req;
      const disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {
        this._send(new EventMessage(this._workerId, req, event));
      });
      this._pendingEvents.set(req, disposable);
    }
    _handleEventMessage(msg) {
      if (!this._pendingEmitters.has(msg.req)) {
        console.warn("Got event for unknown req");
        return;
      }
      this._pendingEmitters.get(msg.req).fire(msg.event);
    }
    _handleUnsubscribeEventMessage(msg) {
      if (!this._pendingEvents.has(msg.req)) {
        console.warn("Got unsubscribe for unknown req");
        return;
      }
      this._pendingEvents.get(msg.req).dispose();
      this._pendingEvents.delete(msg.req);
    }
    _send(msg) {
      const transfer = [];
      if (msg.type === 0) {
        for (let i = 0; i < msg.args.length; i++) {
          if (msg.args[i] instanceof ArrayBuffer) {
            transfer.push(msg.args[i]);
          }
        }
      } else if (msg.type === 1) {
        if (msg.res instanceof ArrayBuffer) {
          transfer.push(msg.res);
        }
      }
      this._handler.sendMessage(msg, transfer);
    }
  };
  function propertyIsEvent(name2) {
    return name2[0] === "o" && name2[1] === "n" && isUpperAsciiLetter(name2.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name2) {
    return /^onDynamic/.test(name2) && isUpperAsciiLetter(name2.charCodeAt(9));
  }
  var SimpleWorkerServer = class {
    constructor(postMessage, requestHandlerFactory) {
      this._localChannels = /* @__PURE__ */ new Map();
      this._remoteChannels = /* @__PURE__ */ new Map();
      this._requestHandlerFactory = requestHandlerFactory;
      this._requestHandler = null;
      this._protocol = new SimpleWorkerProtocol({
        sendMessage: (msg, transfer) => {
          postMessage(msg, transfer);
        },
        handleMessage: (channel, method, args) => this._handleMessage(channel, method, args),
        handleEvent: (channel, eventName, arg) => this._handleEvent(channel, eventName, arg)
      });
    }
    onmessage(msg) {
      this._protocol.handleMessage(msg);
    }
    _handleMessage(channel, method, args) {
      if (channel === DEFAULT_CHANNEL && method === INITIALIZE) {
        return this.initialize(args[0], args[1], args[2]);
      }
      const requestHandler = channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel);
      if (!requestHandler) {
        return Promise.reject(new Error(`Missing channel ${channel} on worker thread`));
      }
      if (typeof requestHandler[method] !== "function") {
        return Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));
      }
      try {
        return Promise.resolve(requestHandler[method].apply(requestHandler, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _handleEvent(channel, eventName, arg) {
      const requestHandler = channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel);
      if (!requestHandler) {
        throw new Error(`Missing channel ${channel} on worker thread`);
      }
      if (propertyIsDynamicEvent(eventName)) {
        const event = requestHandler[eventName].call(requestHandler, arg);
        if (typeof event !== "function") {
          throw new Error(`Missing dynamic event ${eventName} on request handler.`);
        }
        return event;
      }
      if (propertyIsEvent(eventName)) {
        const event = requestHandler[eventName];
        if (typeof event !== "function") {
          throw new Error(`Missing event ${eventName} on request handler.`);
        }
        return event;
      }
      throw new Error(`Malformed event name ${eventName}`);
    }
    getChannel(channel) {
      if (!this._remoteChannels.has(channel)) {
        const inst = this._protocol.createProxyToRemoteChannel(channel);
        this._remoteChannels.set(channel, inst);
      }
      return this._remoteChannels.get(channel);
    }
    async initialize(workerId, loaderConfig, moduleId) {
      this._protocol.setWorkerId(workerId);
      if (this._requestHandlerFactory) {
        this._requestHandler = this._requestHandlerFactory(this);
        return;
      }
      if (loaderConfig) {
        if (typeof loaderConfig.baseUrl !== "undefined") {
          delete loaderConfig["baseUrl"];
        }
        if (typeof loaderConfig.paths !== "undefined") {
          if (typeof loaderConfig.paths.vs !== "undefined") {
            delete loaderConfig.paths["vs"];
          }
        }
        if (typeof loaderConfig.trustedTypesPolicy !== "undefined") {
          delete loaderConfig["trustedTypesPolicy"];
        }
        loaderConfig.catchError = true;
        globalThis.require.config(loaderConfig);
      }
      if (isESM) {
        const url = FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);
        return import(`${url}`).then((module) => {
          this._requestHandler = module.create(this);
          if (!this._requestHandler) {
            throw new Error(`No RequestHandler!`);
          }
        });
      }
      return new Promise((resolve2, reject) => {
        const req = globalThis.require;
        req([moduleId], (module) => {
          this._requestHandler = module.create(this);
          if (!this._requestHandler) {
            reject(new Error(`No RequestHandler!`));
            return;
          }
          resolve2();
        }, reject);
      });
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
  var DiffChange = class {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
      this.originalStart = originalStart;
      this.originalLength = originalLength;
      this.modifiedStart = modifiedStart;
      this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
      return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
      return this.modifiedStart + this.modifiedLength;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
      hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value << bits | (mask & value) >>> delta) >>> 0;
  }
  function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    while (value.length < length) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b2) => b2.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1 = class _StringSHA1 {
    static {
      this._bigBlock32 = new DataView(new ArrayBuffer(320));
    }
    // 80 * 4 = 320
    constructor() {
      this._h0 = 1732584193;
      this._h1 = 4023233417;
      this._h2 = 2562383102;
      this._h3 = 271733878;
      this._h4 = 3285377520;
      this._buff = new Uint8Array(
        64 + 3
        /* to fit any utf-8 */
      );
      this._buffDV = new DataView(this._buff.buffer);
      this._buffLen = 0;
      this._totalLen = 0;
      this._leftoverHighSurrogate = 0;
      this._finished = false;
    }
    update(str) {
      const strLen = str.length;
      if (strLen === 0) {
        return;
      }
      const buff = this._buff;
      let buffLen = this._buffLen;
      let leftoverHighSurrogate = this._leftoverHighSurrogate;
      let charCode;
      let offset;
      if (leftoverHighSurrogate !== 0) {
        charCode = leftoverHighSurrogate;
        offset = -1;
        leftoverHighSurrogate = 0;
      } else {
        charCode = str.charCodeAt(0);
        offset = 0;
      }
      while (true) {
        let codePoint = charCode;
        if (isHighSurrogate(charCode)) {
          if (offset + 1 < strLen) {
            const nextCharCode = str.charCodeAt(offset + 1);
            if (isLowSurrogate(nextCharCode)) {
              offset++;
              codePoint = computeCodePoint(charCode, nextCharCode);
            } else {
              codePoint = 65533;
            }
          } else {
            leftoverHighSurrogate = charCode;
            break;
          }
        } else if (isLowSurrogate(charCode)) {
          codePoint = 65533;
        }
        buffLen = this._push(buff, buffLen, codePoint);
        offset++;
        if (offset < strLen) {
          charCode = str.charCodeAt(offset);
        } else {
          break;
        }
      }
      this._buffLen = buffLen;
      this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
      if (codePoint < 128) {
        buff[buffLen++] = codePoint;
      } else if (codePoint < 2048) {
        buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint < 65536) {
        buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else {
        buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
        buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      }
      if (buffLen >= 64) {
        this._step();
        buffLen -= 64;
        this._totalLen += 64;
        buff[0] = buff[64 + 0];
        buff[1] = buff[64 + 1];
        buff[2] = buff[64 + 2];
      }
      return buffLen;
    }
    digest() {
      if (!this._finished) {
        this._finished = true;
        if (this._leftoverHighSurrogate) {
          this._leftoverHighSurrogate = 0;
          this._buffLen = this._push(
            this._buff,
            this._buffLen,
            65533
            /* SHA1Constant.UNICODE_REPLACEMENT */
          );
        }
        this._totalLen += this._buffLen;
        this._wrapUp();
      }
      return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
      this._buff[this._buffLen++] = 128;
      fill(this._buff, this._buffLen);
      if (this._buffLen > 56) {
        this._step();
        fill(this._buff);
      }
      const ml = 8 * this._totalLen;
      this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
      this._buffDV.setUint32(60, ml % 4294967296, false);
      this._step();
    }
    _step() {
      const bigBlock32 = _StringSHA1._bigBlock32;
      const data = this._buffDV;
      for (let j2 = 0; j2 < 64; j2 += 4) {
        bigBlock32.setUint32(j2, data.getUint32(j2, false), false);
      }
      for (let j2 = 64; j2 < 320; j2 += 4) {
        bigBlock32.setUint32(j2, leftRotate(bigBlock32.getUint32(j2 - 12, false) ^ bigBlock32.getUint32(j2 - 32, false) ^ bigBlock32.getUint32(j2 - 56, false) ^ bigBlock32.getUint32(j2 - 64, false), 1), false);
      }
      let a = this._h0;
      let b2 = this._h1;
      let c = this._h2;
      let d = this._h3;
      let e = this._h4;
      let f, k2;
      let temp;
      for (let j2 = 0; j2 < 80; j2++) {
        if (j2 < 20) {
          f = b2 & c | ~b2 & d;
          k2 = 1518500249;
        } else if (j2 < 40) {
          f = b2 ^ c ^ d;
          k2 = 1859775393;
        } else if (j2 < 60) {
          f = b2 & c | b2 & d | c & d;
          k2 = 2400959708;
        } else {
          f = b2 ^ c ^ d;
          k2 = 3395469782;
        }
        temp = leftRotate(a, 5) + f + e + k2 + bigBlock32.getUint32(j2 * 4, false) & 4294967295;
        e = d;
        d = c;
        c = leftRotate(b2, 30);
        b2 = a;
        a = temp;
      }
      this._h0 = this._h0 + a & 4294967295;
      this._h1 = this._h1 + b2 & 4294967295;
      this._h2 = this._h2 + c & 4294967295;
      this._h3 = this._h3 + d & 4294967295;
      this._h4 = this._h4 + e & 4294967295;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
  var StringDiffSequence = class {
    constructor(source) {
      this.source = source;
    }
    getElements() {
      const source = this.source;
      const characters = new Int32Array(source.length);
      for (let i = 0, len = source.length; i < len; i++) {
        characters[i] = source.charCodeAt(i);
      }
      return characters;
    }
  };
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var Debug = class {
    static Assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
  };
  var MyArray = class {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
  };
  var DiffChangeHelper = class {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
      this.m_changes = [];
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
      }
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      this.m_changes.reverse();
      return this.m_changes;
    }
  };
  var LcsDiff = class _LcsDiff {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
      this.ContinueProcessingPredicate = continueProcessingPredicate;
      this._originalSequence = originalSequence;
      this._modifiedSequence = modifiedSequence;
      const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
      const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
      this._hasStrings = originalHasStrings && modifiedHasStrings;
      this._originalStringElements = originalStringElements;
      this._originalElementsOrHash = originalElementsOrHash;
      this._modifiedStringElements = modifiedStringElements;
      this._modifiedElementsOrHash = modifiedElementsOrHash;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
      return arr.length > 0 && typeof arr[0] === "string";
    }
    static _getElements(sequence) {
      const elements = sequence.getElements();
      if (_LcsDiff._isStringArray(elements)) {
        const hashes = new Int32Array(elements.length);
        for (let i = 0, len = elements.length; i < len; i++) {
          hashes[i] = stringHash(elements[i], 0);
        }
        return [elements, hashes, true];
      }
      if (elements instanceof Int32Array) {
        return [[], elements, false];
      }
      return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
      if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
      if (!this.ElementsAreEqual(originalIndex, newIndex)) {
        return false;
      }
      const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
      const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
      return originalElement === modifiedElement;
    }
    static _getStrictElement(sequence, index) {
      if (typeof sequence.getStrictElement === "function") {
        return sequence.getStrictElement(index);
      }
      return null;
    }
    OriginalElementsAreEqual(index1, index2) {
      if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
    }
    ModifiedElementsAreEqual(index1, index2) {
      if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
    }
    ComputeDiff(pretty) {
      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
      const quitEarlyArr = [false];
      let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
      if (pretty) {
        changes = this.PrettifyChanges(changes);
      }
      return {
        quitEarly: quitEarlyArr[0],
        changes
      };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
      quitEarlyArr[0] = false;
      while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
        originalStart++;
        modifiedStart++;
      }
      while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
        originalEnd--;
        modifiedEnd--;
      }
      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
        let changes;
        if (modifiedStart <= modifiedEnd) {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          changes = [
            new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        } else if (originalStart <= originalEnd) {
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
          ];
        } else {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [];
        }
        return changes;
      }
      const midOriginalArr = [0];
      const midModifiedArr = [0];
      const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
      const midOriginal = midOriginalArr[0];
      const midModified = midModifiedArr[0];
      if (result !== null) {
        return result;
      } else if (!quitEarlyArr[0]) {
        const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
        let rightChanges = [];
        if (!quitEarlyArr[0]) {
          rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
        } else {
          rightChanges = [
            new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
          ];
        }
        return this.ConcatenateChanges(leftChanges, rightChanges);
      }
      return [
        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
      ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
      let forwardChanges = null;
      let reverseChanges = null;
      let changeHelper = new DiffChangeHelper();
      let diagonalMin = diagonalForwardStart;
      let diagonalMax = diagonalForwardEnd;
      let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
      let lastOriginalIndex = -1073741824;
      let historyIndex = this.m_forwardHistory.length - 1;
      do {
        const diagonal = diagonalRelative + diagonalForwardBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
          diagonalRelative = diagonal + 1 - diagonalForwardBase;
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex - 1;
          changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalForwardBase;
        }
        if (historyIndex >= 0) {
          forwardPoints = this.m_forwardHistory[historyIndex];
          diagonalForwardBase = forwardPoints[0];
          diagonalMin = 1;
          diagonalMax = forwardPoints.length - 1;
        }
      } while (--historyIndex >= -1);
      forwardChanges = changeHelper.getReverseChanges();
      if (quitEarlyArr[0]) {
        let originalStartPoint = midOriginalArr[0] + 1;
        let modifiedStartPoint = midModifiedArr[0] + 1;
        if (forwardChanges !== null && forwardChanges.length > 0) {
          const lastForwardChange = forwardChanges[forwardChanges.length - 1];
          originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
          modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
        }
        reverseChanges = [
          new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
        ];
      } else {
        changeHelper = new DiffChangeHelper();
        diagonalMin = diagonalReverseStart;
        diagonalMax = diagonalReverseEnd;
        diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
        lastOriginalIndex = 1073741824;
        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
        do {
          const diagonal = diagonalRelative + diagonalReverseBase;
          if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex + 1;
            changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal + 1 - diagonalReverseBase;
          } else {
            originalIndex = reversePoints[diagonal - 1];
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex;
            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal - 1 - diagonalReverseBase;
          }
          if (historyIndex >= 0) {
            reversePoints = this.m_reverseHistory[historyIndex];
            diagonalReverseBase = reversePoints[0];
            diagonalMin = 1;
            diagonalMax = reversePoints.length - 1;
          }
        } while (--historyIndex >= -1);
        reverseChanges = changeHelper.getChanges();
      }
      return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
      let originalIndex = 0, modifiedIndex = 0;
      let diagonalForwardStart = 0, diagonalForwardEnd = 0;
      let diagonalReverseStart = 0, diagonalReverseEnd = 0;
      originalStart--;
      modifiedStart--;
      midOriginalArr[0] = 0;
      midModifiedArr[0] = 0;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
      const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
      const numDiagonals = maxDifferences + 1;
      const forwardPoints = new Int32Array(numDiagonals);
      const reversePoints = new Int32Array(numDiagonals);
      const diagonalForwardBase = modifiedEnd - modifiedStart;
      const diagonalReverseBase = originalEnd - originalStart;
      const diagonalForwardOffset = originalStart - modifiedStart;
      const diagonalReverseOffset = originalEnd - modifiedEnd;
      const delta = diagonalReverseBase - diagonalForwardBase;
      const deltaIsEven = delta % 2 === 0;
      forwardPoints[diagonalForwardBase] = originalStart;
      reversePoints[diagonalReverseBase] = originalEnd;
      quitEarlyArr[0] = false;
      for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
        let furthestOriginalIndex = 0;
        let furthestModifiedIndex = 0;
        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
          if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
            originalIndex = forwardPoints[diagonal + 1];
          } else {
            originalIndex = forwardPoints[diagonal - 1] + 1;
          }
          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
            originalIndex++;
            modifiedIndex++;
          }
          forwardPoints[diagonal] = originalIndex;
          if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
            furthestOriginalIndex = originalIndex;
            furthestModifiedIndex = modifiedIndex;
          }
          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
            if (originalIndex >= reversePoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
          quitEarlyArr[0] = true;
          midOriginalArr[0] = furthestOriginalIndex;
          midModifiedArr[0] = furthestModifiedIndex;
          if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
          } else {
            originalStart++;
            modifiedStart++;
            return [
              new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
          }
        }
        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
          if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
          } else {
            originalIndex = reversePoints[diagonal - 1];
          }
          modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
            originalIndex--;
            modifiedIndex--;
          }
          reversePoints[diagonal] = originalIndex;
          if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
            if (originalIndex <= forwardPoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        if (numDifferences <= 1447) {
          let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
          temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
          MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
          this.m_forwardHistory.push(temp);
          temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
          temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
          MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
          this.m_reverseHistory.push(temp);
        }
      }
      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
      for (let i = 0; i < changes.length; i++) {
        const change = changes[i];
        const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
        const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
          const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
          const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
          if (endStrictEqual && !startStrictEqual) {
            break;
          }
          change.originalStart++;
          change.modifiedStart++;
        }
        const mergedChangeArr = [null];
        if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
          changes[i] = mergedChangeArr[0];
          changes.splice(i + 1, 1);
          i--;
          continue;
        }
      }
      for (let i = changes.length - 1; i >= 0; i--) {
        const change = changes[i];
        let originalStop = 0;
        let modifiedStop = 0;
        if (i > 0) {
          const prevChange = changes[i - 1];
          originalStop = prevChange.originalStart + prevChange.originalLength;
          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
        }
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        let bestDelta = 0;
        let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
        for (let delta = 1; ; delta++) {
          const originalStart = change.originalStart - delta;
          const modifiedStart = change.modifiedStart - delta;
          if (originalStart < originalStop || modifiedStart < modifiedStop) {
            break;
          }
          if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
            break;
          }
          if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
            break;
          }
          const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
          const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
          if (score2 > bestScore) {
            bestScore = score2;
            bestDelta = delta;
          }
        }
        change.originalStart -= bestDelta;
        change.modifiedStart -= bestDelta;
        const mergedChangeArr = [null];
        if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
          changes[i - 1] = mergedChangeArr[0];
          changes.splice(i, 1);
          i++;
          continue;
        }
      }
      if (this._hasStrings) {
        for (let i = 1, len = changes.length; i < len; i++) {
          const aChange = changes[i - 1];
          const bChange = changes[i];
          const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
          const aOriginalStart = aChange.originalStart;
          const bOriginalEnd = bChange.originalStart + bChange.originalLength;
          const abOriginalLength = bOriginalEnd - aOriginalStart;
          const aModifiedStart = aChange.modifiedStart;
          const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
          const abModifiedLength = bModifiedEnd - aModifiedStart;
          if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
            const t2 = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
            if (t2) {
              const [originalMatchStart, modifiedMatchStart] = t2;
              if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                aChange.originalLength = originalMatchStart - aChange.originalStart;
                aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                bChange.originalStart = originalMatchStart + matchedLength;
                bChange.modifiedStart = modifiedMatchStart + matchedLength;
                bChange.originalLength = bOriginalEnd - bChange.originalStart;
                bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
              }
            }
          }
        }
      }
      return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
      if (originalLength < desiredLength || modifiedLength < desiredLength) {
        return null;
      }
      const originalMax = originalStart + originalLength - desiredLength + 1;
      const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
      let bestScore = 0;
      let bestOriginalStart = 0;
      let bestModifiedStart = 0;
      for (let i = originalStart; i < originalMax; i++) {
        for (let j2 = modifiedStart; j2 < modifiedMax; j2++) {
          const score2 = this._contiguousSequenceScore(i, j2, desiredLength);
          if (score2 > 0 && score2 > bestScore) {
            bestScore = score2;
            bestOriginalStart = i;
            bestModifiedStart = j2;
          }
        }
      }
      if (bestScore > 0) {
        return [bestOriginalStart, bestModifiedStart];
      }
      return null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length) {
      let score2 = 0;
      for (let l = 0; l < length; l++) {
        if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
          return 0;
        }
        score2 += this._originalStringElements[originalStart + l].length;
      }
      return score2;
    }
    _OriginalIsBoundary(index) {
      if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
      if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
        return true;
      }
      if (originalLength > 0) {
        const originalEnd = originalStart + originalLength;
        if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
          return true;
        }
      }
      return false;
    }
    _ModifiedIsBoundary(index) {
      if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
      if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
        return true;
      }
      if (modifiedLength > 0) {
        const modifiedEnd = modifiedStart + modifiedLength;
        if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
          return true;
        }
      }
      return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
      const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
      const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
      return originalScore + modifiedScore;
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
      const mergedChangeArr = [];
      if (left.length === 0 || right.length === 0) {
        return right.length > 0 ? right : left;
      } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
        const result = new Array(left.length + right.length - 1);
        MyArray.Copy(left, 0, result, 0, left.length - 1);
        result[left.length - 1] = mergedChangeArr[0];
        MyArray.Copy(right, 1, result, left.length, right.length - 1);
        return result;
      } else {
        const result = new Array(left.length + right.length);
        MyArray.Copy(left, 0, result, 0, left.length);
        MyArray.Copy(right, 0, result, left.length, right.length);
        return result;
      }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
      Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
      Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        const originalStart = left.originalStart;
        let originalLength = left.originalLength;
        const modifiedStart = left.modifiedStart;
        let modifiedLength = left.modifiedLength;
        if (left.originalStart + left.originalLength >= right.originalStart) {
          originalLength = right.originalStart + right.originalLength - left.originalStart;
        }
        if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
          modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
        }
        mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
        return true;
      } else {
        mergedChangeArr[0] = null;
        return false;
      }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
      if (diagonal >= 0 && diagonal < numDiagonals) {
        return diagonal;
      }
      const diagonalsBelow = diagonalBaseIndex;
      const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
      const diffEven = numDifferences % 2 === 0;
      if (diagonal < 0) {
        const lowerBoundEven = diagonalsBelow % 2 === 0;
        return diffEven === lowerBoundEven ? 0 : 1;
      } else {
        const upperBoundEven = diagonalsAbove % 2 === 0;
        return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/position.js
  var Position = class _Position {
    constructor(lineNumber, column) {
      this.lineNumber = lineNumber;
      this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
      if (newLineNumber === this.lineNumber && newColumn === this.column) {
        return this;
      } else {
        return new _Position(newLineNumber, newColumn);
      }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
      return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
      return _Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a, b2) {
      if (!a && !b2) {
        return true;
      }
      return !!a && !!b2 && a.lineNumber === b2.lineNumber && a.column === b2.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
      return _Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a, b2) {
      if (a.lineNumber < b2.lineNumber) {
        return true;
      }
      if (b2.lineNumber < a.lineNumber) {
        return false;
      }
      return a.column < b2.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
      return _Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a, b2) {
      if (a.lineNumber < b2.lineNumber) {
        return true;
      }
      if (b2.lineNumber < a.lineNumber) {
        return false;
      }
      return a.column <= b2.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a, b2) {
      const aLineNumber = a.lineNumber | 0;
      const bLineNumber = b2.lineNumber | 0;
      if (aLineNumber === bLineNumber) {
        const aColumn = a.column | 0;
        const bColumn = b2.column | 0;
        return aColumn - bColumn;
      }
      return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
      return new _Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")";
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
      return new _Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
      return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
    }
    toJSON() {
      return {
        lineNumber: this.lineNumber,
        column: this.column
      };
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/range.js
  var Range = class _Range {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
      if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
        this.startLineNumber = endLineNumber;
        this.startColumn = endColumn;
        this.endLineNumber = startLineNumber;
        this.endColumn = startColumn;
      } else {
        this.startLineNumber = startLineNumber;
        this.startColumn = startColumn;
        this.endLineNumber = endLineNumber;
        this.endColumn = endColumn;
      }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
      return _Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
      return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position) {
      return _Range.containsPosition(this, position);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position) {
      if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
        return false;
      }
      if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range, position) {
      if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
        return false;
      }
      if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
      return _Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
      return _Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
      return _Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a, b2) {
      let startLineNumber;
      let startColumn;
      let endLineNumber;
      let endColumn;
      if (b2.startLineNumber < a.startLineNumber) {
        startLineNumber = b2.startLineNumber;
        startColumn = b2.startColumn;
      } else if (b2.startLineNumber === a.startLineNumber) {
        startLineNumber = b2.startLineNumber;
        startColumn = Math.min(b2.startColumn, a.startColumn);
      } else {
        startLineNumber = a.startLineNumber;
        startColumn = a.startColumn;
      }
      if (b2.endLineNumber > a.endLineNumber) {
        endLineNumber = b2.endLineNumber;
        endColumn = b2.endColumn;
      } else if (b2.endLineNumber === a.endLineNumber) {
        endLineNumber = b2.endLineNumber;
        endColumn = Math.max(b2.endColumn, a.endColumn);
      } else {
        endLineNumber = a.endLineNumber;
        endColumn = a.endColumn;
      }
      return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
      return _Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a, b2) {
      let resultStartLineNumber = a.startLineNumber;
      let resultStartColumn = a.startColumn;
      let resultEndLineNumber = a.endLineNumber;
      let resultEndColumn = a.endColumn;
      const otherStartLineNumber = b2.startLineNumber;
      const otherStartColumn = b2.startColumn;
      const otherEndLineNumber = b2.endLineNumber;
      const otherEndColumn = b2.endColumn;
      if (resultStartLineNumber < otherStartLineNumber) {
        resultStartLineNumber = otherStartLineNumber;
        resultStartColumn = otherStartColumn;
      } else if (resultStartLineNumber === otherStartLineNumber) {
        resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
      }
      if (resultEndLineNumber > otherEndLineNumber) {
        resultEndLineNumber = otherEndLineNumber;
        resultEndColumn = otherEndColumn;
      } else if (resultEndLineNumber === otherEndLineNumber) {
        resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
      }
      if (resultStartLineNumber > resultEndLineNumber) {
        return null;
      }
      if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
        return null;
      }
      return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
      return _Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a, b2) {
      if (!a && !b2) {
        return true;
      }
      return !!a && !!b2 && a.startLineNumber === b2.startLineNumber && a.startColumn === b2.startColumn && a.endLineNumber === b2.endLineNumber && a.endColumn === b2.endColumn;
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
      return _Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
      return new Position(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
      return _Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
      return new Position(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
      return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
      return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
      return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
      return _Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
      return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd() {
      return _Range.collapseToEnd(this);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range) {
      return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount) {
      return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
    }
    // ---
    static fromPositions(start, end = start) {
      return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    static lift(range) {
      if (!range) {
        return null;
      }
      return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
      return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a, b2) {
      if (a.endLineNumber < b2.startLineNumber || a.endLineNumber === b2.startLineNumber && a.endColumn < b2.startColumn) {
        return false;
      }
      if (b2.endLineNumber < a.startLineNumber || b2.endLineNumber === a.startLineNumber && b2.endColumn < a.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a, b2) {
      if (a.endLineNumber < b2.startLineNumber || a.endLineNumber === b2.startLineNumber && a.endColumn <= b2.startColumn) {
        return false;
      }
      if (b2.endLineNumber < a.startLineNumber || b2.endLineNumber === a.startLineNumber && b2.endColumn <= a.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a, b2) {
      if (a && b2) {
        const aStartLineNumber = a.startLineNumber | 0;
        const bStartLineNumber = b2.startLineNumber | 0;
        if (aStartLineNumber === bStartLineNumber) {
          const aStartColumn = a.startColumn | 0;
          const bStartColumn = b2.startColumn | 0;
          if (aStartColumn === bStartColumn) {
            const aEndLineNumber = a.endLineNumber | 0;
            const bEndLineNumber = b2.endLineNumber | 0;
            if (aEndLineNumber === bEndLineNumber) {
              const aEndColumn = a.endColumn | 0;
              const bEndColumn = b2.endColumn | 0;
              return aEndColumn - bEndColumn;
            }
            return aEndLineNumber - bEndLineNumber;
          }
          return aStartColumn - bStartColumn;
        }
        return aStartLineNumber - bStartLineNumber;
      }
      const aExists = a ? 1 : 0;
      const bExists = b2 ? 1 : 0;
      return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a, b2) {
      if (a.endLineNumber === b2.endLineNumber) {
        if (a.endColumn === b2.endColumn) {
          if (a.startLineNumber === b2.startLineNumber) {
            return a.startColumn - b2.startColumn;
          }
          return a.startLineNumber - b2.startLineNumber;
        }
        return a.endColumn - b2.endColumn;
      }
      return a.endLineNumber - b2.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
      return range.endLineNumber > range.startLineNumber;
    }
    toJSON() {
      return this;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/uint.js
  function toUint8(v2) {
    if (v2 < 0) {
      return 0;
    }
    if (v2 > 255) {
      return 255;
    }
    return v2 | 0;
  }
  function toUint32(v2) {
    if (v2 < 0) {
      return 0;
    }
    if (v2 > 4294967295) {
      return 4294967295;
    }
    return v2 | 0;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier = class _CharacterClassifier {
    constructor(_defaultValue) {
      const defaultValue = toUint8(_defaultValue);
      this._defaultValue = defaultValue;
      this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
      this._map = /* @__PURE__ */ new Map();
    }
    static _createAsciiMap(defaultValue) {
      const asciiMap = new Uint8Array(256);
      asciiMap.fill(defaultValue);
      return asciiMap;
    }
    set(charCode, _value) {
      const value = toUint8(_value);
      if (charCode >= 0 && charCode < 256) {
        this._asciiMap[charCode] = value;
      } else {
        this._map.set(charCode, value);
      }
    }
    get(charCode) {
      if (charCode >= 0 && charCode < 256) {
        return this._asciiMap[charCode];
      } else {
        return this._map.get(charCode) || this._defaultValue;
      }
    }
    clear() {
      this._asciiMap.fill(this._defaultValue);
      this._map.clear();
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
  var Uint8Matrix = class {
    constructor(rows, cols, defaultValue) {
      const data = new Uint8Array(rows * cols);
      for (let i = 0, len = rows * cols; i < len; i++) {
        data[i] = defaultValue;
      }
      this._data = data;
      this.rows = rows;
      this.cols = cols;
    }
    get(row, col) {
      return this._data[row * this.cols + col];
    }
    set(row, col, value) {
      this._data[row * this.cols + col] = value;
    }
  };
  var StateMachine = class {
    constructor(edges) {
      let maxCharCode = 0;
      let maxState = 0;
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to2] = edges[i];
        if (chCode > maxCharCode) {
          maxCharCode = chCode;
        }
        if (from > maxState) {
          maxState = from;
        }
        if (to2 > maxState) {
          maxState = to2;
        }
      }
      maxCharCode++;
      maxState++;
      const states = new Uint8Matrix(
        maxState,
        maxCharCode,
        0
        /* State.Invalid */
      );
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to2] = edges[i];
        states.set(from, chCode, to2);
      }
      this._states = states;
      this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
      if (chCode < 0 || chCode >= this._maxCharCode) {
        return 0;
      }
      return this._states.get(currentState, chCode);
    }
  };
  var _stateMachine = null;
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [
          1,
          104,
          2
          /* State.H */
        ],
        [
          1,
          72,
          2
          /* State.H */
        ],
        [
          1,
          102,
          6
          /* State.F */
        ],
        [
          1,
          70,
          6
          /* State.F */
        ],
        [
          2,
          116,
          3
          /* State.HT */
        ],
        [
          2,
          84,
          3
          /* State.HT */
        ],
        [
          3,
          116,
          4
          /* State.HTT */
        ],
        [
          3,
          84,
          4
          /* State.HTT */
        ],
        [
          4,
          112,
          5
          /* State.HTTP */
        ],
        [
          4,
          80,
          5
          /* State.HTTP */
        ],
        [
          5,
          115,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          83,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          58,
          10
          /* State.AfterColon */
        ],
        [
          6,
          105,
          7
          /* State.FI */
        ],
        [
          6,
          73,
          7
          /* State.FI */
        ],
        [
          7,
          108,
          8
          /* State.FIL */
        ],
        [
          7,
          76,
          8
          /* State.FIL */
        ],
        [
          8,
          101,
          9
          /* State.BeforeColon */
        ],
        [
          8,
          69,
          9
          /* State.BeforeColon */
        ],
        [
          9,
          58,
          10
          /* State.AfterColon */
        ],
        [
          10,
          47,
          11
          /* State.AlmostThere */
        ],
        [
          11,
          47,
          12
          /* State.End */
        ]
      ]);
    }
    return _stateMachine;
  }
  var _classifier = null;
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(
        0
        /* CharacterClass.None */
      );
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
        _classifier.set(
          FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
          1
          /* CharacterClass.ForceTermination */
        );
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;:";
      for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
        _classifier.set(
          CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
          2
          /* CharacterClass.CannotEndIn */
        );
      }
    }
    return _classifier;
  }
  var LinkComputer = class _LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
      let lastIncludedCharIndex = linkEndIndex - 1;
      do {
        const chCode = line.charCodeAt(lastIncludedCharIndex);
        const chClass = classifier.get(chCode);
        if (chClass !== 2) {
          break;
        }
        lastIncludedCharIndex--;
      } while (lastIncludedCharIndex > linkBeginIndex);
      if (linkBeginIndex > 0) {
        const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
        const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
        if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
          lastIncludedCharIndex--;
        }
      }
      return {
        range: {
          startLineNumber: lineNumber,
          startColumn: linkBeginIndex + 1,
          endLineNumber: lineNumber,
          endColumn: lastIncludedCharIndex + 2
        },
        url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
      };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
      const classifier = getClassifier();
      const result = [];
      for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
        const line = model.getLineContent(i);
        const len = line.length;
        let j2 = 0;
        let linkBeginIndex = 0;
        let linkBeginChCode = 0;
        let state = 1;
        let hasOpenParens = false;
        let hasOpenSquareBracket = false;
        let inSquareBrackets = false;
        let hasOpenCurlyBracket = false;
        while (j2 < len) {
          let resetStateMachine = false;
          const chCode = line.charCodeAt(j2);
          if (state === 13) {
            let chClass;
            switch (chCode) {
              case 40:
                hasOpenParens = true;
                chClass = 0;
                break;
              case 41:
                chClass = hasOpenParens ? 0 : 1;
                break;
              case 91:
                inSquareBrackets = true;
                hasOpenSquareBracket = true;
                chClass = 0;
                break;
              case 93:
                inSquareBrackets = false;
                chClass = hasOpenSquareBracket ? 0 : 1;
                break;
              case 123:
                hasOpenCurlyBracket = true;
                chClass = 0;
                break;
              case 125:
                chClass = hasOpenCurlyBracket ? 0 : 1;
                break;
              // The following three rules make it that ' or " or ` are allowed inside links
              // only if the link is wrapped by some other quote character
              case 39:
              case 34:
              case 96:
                if (linkBeginChCode === chCode) {
                  chClass = 1;
                } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                  chClass = 0;
                } else {
                  chClass = 1;
                }
                break;
              case 42:
                chClass = linkBeginChCode === 42 ? 1 : 0;
                break;
              case 124:
                chClass = linkBeginChCode === 124 ? 1 : 0;
                break;
              case 32:
                chClass = inSquareBrackets ? 0 : 1;
                break;
              default:
                chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j2));
              resetStateMachine = true;
            }
          } else if (state === 12) {
            let chClass;
            if (chCode === 91) {
              hasOpenSquareBracket = true;
              chClass = 0;
            } else {
              chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              resetStateMachine = true;
            } else {
              state = 13;
            }
          } else {
            state = stateMachine.nextState(state, chCode);
            if (state === 0) {
              resetStateMachine = true;
            }
          }
          if (resetStateMachine) {
            state = 1;
            hasOpenParens = false;
            hasOpenSquareBracket = false;
            hasOpenCurlyBracket = false;
            linkBeginIndex = j2 + 1;
            linkBeginChCode = chCode;
          }
          j2++;
        }
        if (state === 13) {
          result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
        }
      }
      return result;
    }
  };
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }

  // node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace = class _BasicInplaceReplace {
    constructor() {
      this._defaultValueSet = [
        ["true", "false"],
        ["True", "False"],
        ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
        ["public", "protected", "private"]
      ];
    }
    static {
      this.INSTANCE = new _BasicInplaceReplace();
    }
    navigateValueSet(range1, text1, range2, text22, up) {
      if (range1 && text1) {
        const result = this.doNavigateValueSet(text1, up);
        if (result) {
          return {
            range: range1,
            value: result
          };
        }
      }
      if (range2 && text22) {
        const result = this.doNavigateValueSet(text22, up);
        if (result) {
          return {
            range: range2,
            value: result
          };
        }
      }
      return null;
    }
    doNavigateValueSet(text3, up) {
      const numberResult = this.numberReplace(text3, up);
      if (numberResult !== null) {
        return numberResult;
      }
      return this.textReplace(text3, up);
    }
    numberReplace(value, up) {
      const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
      let n1 = Number(value);
      const n2 = parseFloat(value);
      if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
        if (n1 === 0 && !up) {
          return null;
        } else {
          n1 = Math.floor(n1 * precision);
          n1 += up ? precision : -precision;
          return String(n1 / precision);
        }
      }
      return null;
    }
    textReplace(value, up) {
      return this.valueSetsReplace(this._defaultValueSet, value, up);
    }
    valueSetsReplace(valueSets, value, up) {
      let result = null;
      for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
        result = this.valueSetReplace(valueSets[i], value, up);
      }
      return result;
    }
    valueSetReplace(valueSet, value, up) {
      let idx = valueSet.indexOf(value);
      if (idx >= 0) {
        idx += up ? 1 : -1;
        if (idx < 0) {
          idx = valueSet.length - 1;
        } else {
          idx %= valueSet.length;
        }
        return valueSet[idx];
      }
      return null;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle = setTimeout(callback.bind(context), 0);
    return { dispose() {
      clearTimeout(handle);
    } };
  });
  var CancellationToken;
  (function(CancellationToken2) {
    function isCancellationToken(thing) {
      if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
        return true;
      }
      if (thing instanceof MutableToken) {
        return true;
      }
      if (!thing || typeof thing !== "object") {
        return false;
      }
      return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
    }
    CancellationToken2.isCancellationToken = isCancellationToken;
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: shortcutEvent
    });
  })(CancellationToken || (CancellationToken = {}));
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
      this._emitter = null;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = null;
      }
    }
  };
  var CancellationTokenSource = class {
    constructor(parent) {
      this._token = void 0;
      this._parentListener = void 0;
      this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else if (this._token instanceof MutableToken) {
        this._token.cancel();
      }
    }
    dispose(cancel = false) {
      if (cancel) {
        this.cancel();
      }
      this._parentListener?.dispose();
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
  var KeyCodeStrMap = class {
    constructor() {
      this._keyCodeToStr = [];
      this._strToKeyCode = /* @__PURE__ */ Object.create(null);
    }
    define(keyCode, str) {
      this._keyCodeToStr[keyCode] = str;
      this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
      return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
      return this._strToKeyCode[str.toLowerCase()] || 0;
    }
  };
  var uiMap = new KeyCodeStrMap();
  var userSettingsUSMap = new KeyCodeStrMap();
  var userSettingsGeneralMap = new KeyCodeStrMap();
  var EVENT_KEY_CODE_MAP = new Array(230);
  var NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
  var scanCodeIntToStr = [];
  var scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
  var scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
  var IMMUTABLE_CODE_TO_KEY_CODE = [];
  var IMMUTABLE_KEY_CODE_TO_CODE = [];
  for (let i = 0; i <= 193; i++) {
    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
  }
  for (let i = 0; i <= 132; i++) {
    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
  }
  (function() {
    const empty = "";
    const mappings = [
      // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
      [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
      [1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
      [1, 2, "Super", 0, empty, 0, empty, empty, empty],
      [1, 3, "Fn", 0, empty, 0, empty, empty, empty],
      [1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
      [1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
      [1, 6, "Resume", 0, empty, 0, empty, empty, empty],
      [1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
      [1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
      [1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
      [0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
      [0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
      [0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
      [0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
      [0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
      [0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
      [0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
      [0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
      [0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
      [0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
      [0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
      [0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
      [0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
      [0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
      [0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
      [0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
      [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
      [0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
      [0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
      [0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
      [0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
      [0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
      [0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
      [0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
      [0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
      [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
      [0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
      [0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
      [0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
      [0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
      [0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
      [0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
      [0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
      [0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
      [0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
      [0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
      [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
      [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
      [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
      [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
      [1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
      [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
      [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
      [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
      [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
      [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
      [0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
      // has been dropped from the w3c spec
      [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
      [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
      [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
      [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
      [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
      [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
      [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
      [1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
      [1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
      [1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
      [1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
      [1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
      [1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
      [1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
      [1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
      [1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
      [1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
      [1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
      [1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
      [1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
      [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", empty, empty],
      [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
      [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
      [1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
      [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
      [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
      [1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
      [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
      [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
      [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
      [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
      [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
      [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", empty, empty],
      [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
      [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
      [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
      [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", empty, empty],
      [1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
      [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
      [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
      [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
      [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
      [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
      [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
      [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
      [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
      [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
      [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
      [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
      [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", empty, empty],
      [1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
      [1, 108, "Power", 0, empty, 0, empty, empty, empty],
      [1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
      [1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
      [1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
      [1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
      [1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
      [1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
      [1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
      [1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
      [1, 117, "F20", 78, "F20", 131, "VK_F20", empty, empty],
      [1, 118, "F21", 79, "F21", 132, "VK_F21", empty, empty],
      [1, 119, "F22", 80, "F22", 133, "VK_F22", empty, empty],
      [1, 120, "F23", 81, "F23", 134, "VK_F23", empty, empty],
      [1, 121, "F24", 82, "F24", 135, "VK_F24", empty, empty],
      [1, 122, "Open", 0, empty, 0, empty, empty, empty],
      [1, 123, "Help", 0, empty, 0, empty, empty, empty],
      [1, 124, "Select", 0, empty, 0, empty, empty, empty],
      [1, 125, "Again", 0, empty, 0, empty, empty, empty],
      [1, 126, "Undo", 0, empty, 0, empty, empty, empty],
      [1, 127, "Cut", 0, empty, 0, empty, empty, empty],
      [1, 128, "Copy", 0, empty, 0, empty, empty, empty],
      [1, 129, "Paste", 0, empty, 0, empty, empty, empty],
      [1, 130, "Find", 0, empty, 0, empty, empty, empty],
      [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
      [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
      [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
      [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
      [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
      [1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
      [0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
      [1, 138, "Convert", 0, empty, 0, empty, empty, empty],
      [1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
      [1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
      [1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
      [1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
      [1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
      [1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
      [1, 145, "Abort", 0, empty, 0, empty, empty, empty],
      [1, 146, "Props", 0, empty, 0, empty, empty, empty],
      [1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
      [1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
      [1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
      [1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
      [1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
      [1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
      [1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
      [1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
      [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", empty, empty],
      [1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
      [1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
      [1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
      [1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
      [1, 0, empty, 57, "Meta", 91, "VK_COMMAND", empty, empty],
      [1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
      [1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
      [1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
      [1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
      [1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
      [1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
      [1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
      [1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
      [1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
      [1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
      [1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
      [1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
      [1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
      [1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
      [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
      [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
      [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
      [1, 174, "Eject", 0, empty, 0, empty, empty, empty],
      [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
      [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
      [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
      [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
      [1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
      [1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
      [1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
      [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
      [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
      [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
      [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
      [1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
      [1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
      [1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
      [1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
      [1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
      [1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
      [1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
      // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
      // If an Input Method Editor is processing key input and the event is keydown, return 229.
      [1, 0, empty, 114, "KeyInComposition", 229, empty, empty, empty],
      [1, 0, empty, 116, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
      [1, 0, empty, 96, "OEM_8", 223, "VK_OEM_8", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
    ];
    const seenKeyCode = [];
    const seenScanCode = [];
    for (const mapping of mappings) {
      const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
      if (!seenScanCode[scanCode]) {
        seenScanCode[scanCode] = true;
        scanCodeIntToStr[scanCode] = scanCodeStr;
        scanCodeStrToInt[scanCodeStr] = scanCode;
        scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
        if (immutable) {
          IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
          if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
            IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
          }
        }
      }
      if (!seenKeyCode[keyCode]) {
        seenKeyCode[keyCode] = true;
        if (!keyCodeStr) {
          throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
        }
        uiMap.define(keyCode, keyCodeStr);
        userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
      }
      if (eventKeyCode) {
        EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
      }
      if (vkey) {
        NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
      }
    }
    IMMUTABLE_KEY_CODE_TO_CODE[
      3
      /* KeyCode.Enter */
    ] = 46;
  })();
  var KeyCodeUtils;
  (function(KeyCodeUtils2) {
    function toString(keyCode) {
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toString = toString;
    function fromString(key) {
      return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromString = fromString;
    function toUserSettingsUS(keyCode) {
      return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
      return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
      return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromUserSettings = fromUserSettings;
    function toElectronAccelerator(keyCode) {
      if (keyCode >= 98 && keyCode <= 113) {
        return null;
      }
      switch (keyCode) {
        case 16:
          return "Up";
        case 18:
          return "Down";
        case 15:
          return "Left";
        case 17:
          return "Right";
      }
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
  })(KeyCodeUtils || (KeyCodeUtils = {}));
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
  var Selection = class _Selection extends Range {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
      super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
      this.selectionStartLineNumber = selectionStartLineNumber;
      this.selectionStartColumn = selectionStartColumn;
      this.positionLineNumber = positionLineNumber;
      this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
      return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
      return _Selection.selectionsEqual(this, other);
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a, b2) {
      return a.selectionStartLineNumber === b2.selectionStartLineNumber && a.selectionStartColumn === b2.selectionStartColumn && a.positionLineNumber === b2.positionLineNumber && a.positionColumn === b2.positionColumn;
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
      if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
        return 0;
      }
      return 1;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
      return new Position(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart() {
      return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start, end = start) {
      return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range, direction) {
      if (direction === 0) {
        return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      } else {
        return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
      }
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
      return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a, b2) {
      if (a && !b2 || !a && b2) {
        return false;
      }
      if (!a && !b2) {
        return true;
      }
      if (a.length !== b2.length) {
        return false;
      }
      for (let i = 0, len = a.length; i < len; i++) {
        if (!this.selectionsEqual(a[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
      return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
      if (direction === 0) {
        return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/types.js
  function isString(str) {
    return typeof str === "string";
  }

  // node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js
  var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
  function register(id, fontCharacter) {
    if (isString(fontCharacter)) {
      const val = _codiconFontCharacters[fontCharacter];
      if (val === void 0) {
        throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
      }
      fontCharacter = val;
    }
    _codiconFontCharacters[id] = fontCharacter;
    return { id };
  }

  // node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js
  var codiconsLibrary = {
    add: register("add", 6e4),
    plus: register("plus", 6e4),
    gistNew: register("gist-new", 6e4),
    repoCreate: register("repo-create", 6e4),
    lightbulb: register("lightbulb", 60001),
    lightBulb: register("light-bulb", 60001),
    repo: register("repo", 60002),
    repoDelete: register("repo-delete", 60002),
    gistFork: register("gist-fork", 60003),
    repoForked: register("repo-forked", 60003),
    gitPullRequest: register("git-pull-request", 60004),
    gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
    recordKeys: register("record-keys", 60005),
    keyboard: register("keyboard", 60005),
    tag: register("tag", 60006),
    gitPullRequestLabel: register("git-pull-request-label", 60006),
    tagAdd: register("tag-add", 60006),
    tagRemove: register("tag-remove", 60006),
    person: register("person", 60007),
    personFollow: register("person-follow", 60007),
    personOutline: register("person-outline", 60007),
    personFilled: register("person-filled", 60007),
    gitBranch: register("git-branch", 60008),
    gitBranchCreate: register("git-branch-create", 60008),
    gitBranchDelete: register("git-branch-delete", 60008),
    sourceControl: register("source-control", 60008),
    mirror: register("mirror", 60009),
    mirrorPublic: register("mirror-public", 60009),
    star: register("star", 60010),
    starAdd: register("star-add", 60010),
    starDelete: register("star-delete", 60010),
    starEmpty: register("star-empty", 60010),
    comment: register("comment", 60011),
    commentAdd: register("comment-add", 60011),
    alert: register("alert", 60012),
    warning: register("warning", 60012),
    search: register("search", 60013),
    searchSave: register("search-save", 60013),
    logOut: register("log-out", 60014),
    signOut: register("sign-out", 60014),
    logIn: register("log-in", 60015),
    signIn: register("sign-in", 60015),
    eye: register("eye", 60016),
    eyeUnwatch: register("eye-unwatch", 60016),
    eyeWatch: register("eye-watch", 60016),
    circleFilled: register("circle-filled", 60017),
    primitiveDot: register("primitive-dot", 60017),
    closeDirty: register("close-dirty", 60017),
    debugBreakpoint: register("debug-breakpoint", 60017),
    debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
    debugHint: register("debug-hint", 60017),
    terminalDecorationSuccess: register("terminal-decoration-success", 60017),
    primitiveSquare: register("primitive-square", 60018),
    edit: register("edit", 60019),
    pencil: register("pencil", 60019),
    info: register("info", 60020),
    issueOpened: register("issue-opened", 60020),
    gistPrivate: register("gist-private", 60021),
    gitForkPrivate: register("git-fork-private", 60021),
    lock: register("lock", 60021),
    mirrorPrivate: register("mirror-private", 60021),
    close: register("close", 60022),
    removeClose: register("remove-close", 60022),
    x: register("x", 60022),
    repoSync: register("repo-sync", 60023),
    sync: register("sync", 60023),
    clone: register("clone", 60024),
    desktopDownload: register("desktop-download", 60024),
    beaker: register("beaker", 60025),
    microscope: register("microscope", 60025),
    vm: register("vm", 60026),
    deviceDesktop: register("device-desktop", 60026),
    file: register("file", 60027),
    fileText: register("file-text", 60027),
    more: register("more", 60028),
    ellipsis: register("ellipsis", 60028),
    kebabHorizontal: register("kebab-horizontal", 60028),
    mailReply: register("mail-reply", 60029),
    reply: register("reply", 60029),
    organization: register("organization", 60030),
    organizationFilled: register("organization-filled", 60030),
    organizationOutline: register("organization-outline", 60030),
    newFile: register("new-file", 60031),
    fileAdd: register("file-add", 60031),
    newFolder: register("new-folder", 60032),
    fileDirectoryCreate: register("file-directory-create", 60032),
    trash: register("trash", 60033),
    trashcan: register("trashcan", 60033),
    history: register("history", 60034),
    clock: register("clock", 60034),
    folder: register("folder", 60035),
    fileDirectory: register("file-directory", 60035),
    symbolFolder: register("symbol-folder", 60035),
    logoGithub: register("logo-github", 60036),
    markGithub: register("mark-github", 60036),
    github: register("github", 60036),
    terminal: register("terminal", 60037),
    console: register("console", 60037),
    repl: register("repl", 60037),
    zap: register("zap", 60038),
    symbolEvent: register("symbol-event", 60038),
    error: register("error", 60039),
    stop: register("stop", 60039),
    variable: register("variable", 60040),
    symbolVariable: register("symbol-variable", 60040),
    array: register("array", 60042),
    symbolArray: register("symbol-array", 60042),
    symbolModule: register("symbol-module", 60043),
    symbolPackage: register("symbol-package", 60043),
    symbolNamespace: register("symbol-namespace", 60043),
    symbolObject: register("symbol-object", 60043),
    symbolMethod: register("symbol-method", 60044),
    symbolFunction: register("symbol-function", 60044),
    symbolConstructor: register("symbol-constructor", 60044),
    symbolBoolean: register("symbol-boolean", 60047),
    symbolNull: register("symbol-null", 60047),
    symbolNumeric: register("symbol-numeric", 60048),
    symbolNumber: register("symbol-number", 60048),
    symbolStructure: register("symbol-structure", 60049),
    symbolStruct: register("symbol-struct", 60049),
    symbolParameter: register("symbol-parameter", 60050),
    symbolTypeParameter: register("symbol-type-parameter", 60050),
    symbolKey: register("symbol-key", 60051),
    symbolText: register("symbol-text", 60051),
    symbolReference: register("symbol-reference", 60052),
    goToFile: register("go-to-file", 60052),
    symbolEnum: register("symbol-enum", 60053),
    symbolValue: register("symbol-value", 60053),
    symbolRuler: register("symbol-ruler", 60054),
    symbolUnit: register("symbol-unit", 60054),
    activateBreakpoints: register("activate-breakpoints", 60055),
    archive: register("archive", 60056),
    arrowBoth: register("arrow-both", 60057),
    arrowDown: register("arrow-down", 60058),
    arrowLeft: register("arrow-left", 60059),
    arrowRight: register("arrow-right", 60060),
    arrowSmallDown: register("arrow-small-down", 60061),
    arrowSmallLeft: register("arrow-small-left", 60062),
    arrowSmallRight: register("arrow-small-right", 60063),
    arrowSmallUp: register("arrow-small-up", 60064),
    arrowUp: register("arrow-up", 60065),
    bell: register("bell", 60066),
    bold: register("bold", 60067),
    book: register("book", 60068),
    bookmark: register("bookmark", 60069),
    debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
    debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
    debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
    debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
    debugBreakpointData: register("debug-breakpoint-data", 60073),
    debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
    debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
    debugBreakpointLog: register("debug-breakpoint-log", 60075),
    debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
    briefcase: register("briefcase", 60076),
    broadcast: register("broadcast", 60077),
    browser: register("browser", 60078),
    bug: register("bug", 60079),
    calendar: register("calendar", 60080),
    caseSensitive: register("case-sensitive", 60081),
    check: register("check", 60082),
    checklist: register("checklist", 60083),
    chevronDown: register("chevron-down", 60084),
    chevronLeft: register("chevron-left", 60085),
    chevronRight: register("chevron-right", 60086),
    chevronUp: register("chevron-up", 60087),
    chromeClose: register("chrome-close", 60088),
    chromeMaximize: register("chrome-maximize", 60089),
    chromeMinimize: register("chrome-minimize", 60090),
    chromeRestore: register("chrome-restore", 60091),
    circleOutline: register("circle-outline", 60092),
    circle: register("circle", 60092),
    debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
    terminalDecorationIncomplete: register("terminal-decoration-incomplete", 60092),
    circleSlash: register("circle-slash", 60093),
    circuitBoard: register("circuit-board", 60094),
    clearAll: register("clear-all", 60095),
    clippy: register("clippy", 60096),
    closeAll: register("close-all", 60097),
    cloudDownload: register("cloud-download", 60098),
    cloudUpload: register("cloud-upload", 60099),
    code: register("code", 60100),
    collapseAll: register("collapse-all", 60101),
    colorMode: register("color-mode", 60102),
    commentDiscussion: register("comment-discussion", 60103),
    creditCard: register("credit-card", 60105),
    dash: register("dash", 60108),
    dashboard: register("dashboard", 60109),
    database: register("database", 60110),
    debugContinue: register("debug-continue", 60111),
    debugDisconnect: register("debug-disconnect", 60112),
    debugPause: register("debug-pause", 60113),
    debugRestart: register("debug-restart", 60114),
    debugStart: register("debug-start", 60115),
    debugStepInto: register("debug-step-into", 60116),
    debugStepOut: register("debug-step-out", 60117),
    debugStepOver: register("debug-step-over", 60118),
    debugStop: register("debug-stop", 60119),
    debug: register("debug", 60120),
    deviceCameraVideo: register("device-camera-video", 60121),
    deviceCamera: register("device-camera", 60122),
    deviceMobile: register("device-mobile", 60123),
    diffAdded: register("diff-added", 60124),
    diffIgnored: register("diff-ignored", 60125),
    diffModified: register("diff-modified", 60126),
    diffRemoved: register("diff-removed", 60127),
    diffRenamed: register("diff-renamed", 60128),
    diff: register("diff", 60129),
    diffSidebyside: register("diff-sidebyside", 60129),
    discard: register("discard", 60130),
    editorLayout: register("editor-layout", 60131),
    emptyWindow: register("empty-window", 60132),
    exclude: register("exclude", 60133),
    extensions: register("extensions", 60134),
    eyeClosed: register("eye-closed", 60135),
    fileBinary: register("file-binary", 60136),
    fileCode: register("file-code", 60137),
    fileMedia: register("file-media", 60138),
    filePdf: register("file-pdf", 60139),
    fileSubmodule: register("file-submodule", 60140),
    fileSymlinkDirectory: register("file-symlink-directory", 60141),
    fileSymlinkFile: register("file-symlink-file", 60142),
    fileZip: register("file-zip", 60143),
    files: register("files", 60144),
    filter: register("filter", 60145),
    flame: register("flame", 60146),
    foldDown: register("fold-down", 60147),
    foldUp: register("fold-up", 60148),
    fold: register("fold", 60149),
    folderActive: register("folder-active", 60150),
    folderOpened: register("folder-opened", 60151),
    gear: register("gear", 60152),
    gift: register("gift", 60153),
    gistSecret: register("gist-secret", 60154),
    gist: register("gist", 60155),
    gitCommit: register("git-commit", 60156),
    gitCompare: register("git-compare", 60157),
    compareChanges: register("compare-changes", 60157),
    gitMerge: register("git-merge", 60158),
    githubAction: register("github-action", 60159),
    githubAlt: register("github-alt", 60160),
    globe: register("globe", 60161),
    grabber: register("grabber", 60162),
    graph: register("graph", 60163),
    gripper: register("gripper", 60164),
    heart: register("heart", 60165),
    home: register("home", 60166),
    horizontalRule: register("horizontal-rule", 60167),
    hubot: register("hubot", 60168),
    inbox: register("inbox", 60169),
    issueReopened: register("issue-reopened", 60171),
    issues: register("issues", 60172),
    italic: register("italic", 60173),
    jersey: register("jersey", 60174),
    json: register("json", 60175),
    kebabVertical: register("kebab-vertical", 60176),
    key: register("key", 60177),
    law: register("law", 60178),
    lightbulbAutofix: register("lightbulb-autofix", 60179),
    linkExternal: register("link-external", 60180),
    link: register("link", 60181),
    listOrdered: register("list-ordered", 60182),
    listUnordered: register("list-unordered", 60183),
    liveShare: register("live-share", 60184),
    loading: register("loading", 60185),
    location: register("location", 60186),
    mailRead: register("mail-read", 60187),
    mail: register("mail", 60188),
    markdown: register("markdown", 60189),
    megaphone: register("megaphone", 60190),
    mention: register("mention", 60191),
    milestone: register("milestone", 60192),
    gitPullRequestMilestone: register("git-pull-request-milestone", 60192),
    mortarBoard: register("mortar-board", 60193),
    move: register("move", 60194),
    multipleWindows: register("multiple-windows", 60195),
    mute: register("mute", 60196),
    noNewline: register("no-newline", 60197),
    note: register("note", 60198),
    octoface: register("octoface", 60199),
    openPreview: register("open-preview", 60200),
    package: register("package", 60201),
    paintcan: register("paintcan", 60202),
    pin: register("pin", 60203),
    play: register("play", 60204),
    run: register("run", 60204),
    plug: register("plug", 60205),
    preserveCase: register("preserve-case", 60206),
    preview: register("preview", 60207),
    project: register("project", 60208),
    pulse: register("pulse", 60209),
    question: register("question", 60210),
    quote: register("quote", 60211),
    radioTower: register("radio-tower", 60212),
    reactions: register("reactions", 60213),
    references: register("references", 60214),
    refresh: register("refresh", 60215),
    regex: register("regex", 60216),
    remoteExplorer: register("remote-explorer", 60217),
    remote: register("remote", 60218),
    remove: register("remove", 60219),
    replaceAll: register("replace-all", 60220),
    replace: register("replace", 60221),
    repoClone: register("repo-clone", 60222),
    repoForcePush: register("repo-force-push", 60223),
    repoPull: register("repo-pull", 60224),
    repoPush: register("repo-push", 60225),
    report: register("report", 60226),
    requestChanges: register("request-changes", 60227),
    rocket: register("rocket", 60228),
    rootFolderOpened: register("root-folder-opened", 60229),
    rootFolder: register("root-folder", 60230),
    rss: register("rss", 60231),
    ruby: register("ruby", 60232),
    saveAll: register("save-all", 60233),
    saveAs: register("save-as", 60234),
    save: register("save", 60235),
    screenFull: register("screen-full", 60236),
    screenNormal: register("screen-normal", 60237),
    searchStop: register("search-stop", 60238),
    server: register("server", 60240),
    settingsGear: register("settings-gear", 60241),
    settings: register("settings", 60242),
    shield: register("shield", 60243),
    smiley: register("smiley", 60244),
    sortPrecedence: register("sort-precedence", 60245),
    splitHorizontal: register("split-horizontal", 60246),
    splitVertical: register("split-vertical", 60247),
    squirrel: register("squirrel", 60248),
    starFull: register("star-full", 60249),
    starHalf: register("star-half", 60250),
    symbolClass: register("symbol-class", 60251),
    symbolColor: register("symbol-color", 60252),
    symbolConstant: register("symbol-constant", 60253),
    symbolEnumMember: register("symbol-enum-member", 60254),
    symbolField: register("symbol-field", 60255),
    symbolFile: register("symbol-file", 60256),
    symbolInterface: register("symbol-interface", 60257),
    symbolKeyword: register("symbol-keyword", 60258),
    symbolMisc: register("symbol-misc", 60259),
    symbolOperator: register("symbol-operator", 60260),
    symbolProperty: register("symbol-property", 60261),
    wrench: register("wrench", 60261),
    wrenchSubaction: register("wrench-subaction", 60261),
    symbolSnippet: register("symbol-snippet", 60262),
    tasklist: register("tasklist", 60263),
    telescope: register("telescope", 60264),
    textSize: register("text-size", 60265),
    threeBars: register("three-bars", 60266),
    thumbsdown: register("thumbsdown", 60267),
    thumbsup: register("thumbsup", 60268),
    tools: register("tools", 60269),
    triangleDown: register("triangle-down", 60270),
    triangleLeft: register("triangle-left", 60271),
    triangleRight: register("triangle-right", 60272),
    triangleUp: register("triangle-up", 60273),
    twitter: register("twitter", 60274),
    unfold: register("unfold", 60275),
    unlock: register("unlock", 60276),
    unmute: register("unmute", 60277),
    unverified: register("unverified", 60278),
    verified: register("verified", 60279),
    versions: register("versions", 60280),
    vmActive: register("vm-active", 60281),
    vmOutline: register("vm-outline", 60282),
    vmRunning: register("vm-running", 60283),
    watch: register("watch", 60284),
    whitespace: register("whitespace", 60285),
    wholeWord: register("whole-word", 60286),
    window: register("window", 60287),
    wordWrap: register("word-wrap", 60288),
    zoomIn: register("zoom-in", 60289),
    zoomOut: register("zoom-out", 60290),
    listFilter: register("list-filter", 60291),
    listFlat: register("list-flat", 60292),
    listSelection: register("list-selection", 60293),
    selection: register("selection", 60293),
    listTree: register("list-tree", 60294),
    debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
    debugBreakpointFunction: register("debug-breakpoint-function", 60296),
    debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
    debugStackframeActive: register("debug-stackframe-active", 60297),
    circleSmallFilled: register("circle-small-filled", 60298),
    debugStackframeDot: register("debug-stackframe-dot", 60298),
    terminalDecorationMark: register("terminal-decoration-mark", 60298),
    debugStackframe: register("debug-stackframe", 60299),
    debugStackframeFocused: register("debug-stackframe-focused", 60299),
    debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
    symbolString: register("symbol-string", 60301),
    debugReverseContinue: register("debug-reverse-continue", 60302),
    debugStepBack: register("debug-step-back", 60303),
    debugRestartFrame: register("debug-restart-frame", 60304),
    debugAlt: register("debug-alt", 60305),
    callIncoming: register("call-incoming", 60306),
    callOutgoing: register("call-outgoing", 60307),
    menu: register("menu", 60308),
    expandAll: register("expand-all", 60309),
    feedback: register("feedback", 60310),
    gitPullRequestReviewer: register("git-pull-request-reviewer", 60310),
    groupByRefType: register("group-by-ref-type", 60311),
    ungroupByRefType: register("ungroup-by-ref-type", 60312),
    account: register("account", 60313),
    gitPullRequestAssignee: register("git-pull-request-assignee", 60313),
    bellDot: register("bell-dot", 60314),
    debugConsole: register("debug-console", 60315),
    library: register("library", 60316),
    output: register("output", 60317),
    runAll: register("run-all", 60318),
    syncIgnored: register("sync-ignored", 60319),
    pinned: register("pinned", 60320),
    githubInverted: register("github-inverted", 60321),
    serverProcess: register("server-process", 60322),
    serverEnvironment: register("server-environment", 60323),
    pass: register("pass", 60324),
    issueClosed: register("issue-closed", 60324),
    stopCircle: register("stop-circle", 60325),
    playCircle: register("play-circle", 60326),
    record: register("record", 60327),
    debugAltSmall: register("debug-alt-small", 60328),
    vmConnect: register("vm-connect", 60329),
    cloud: register("cloud", 60330),
    merge: register("merge", 60331),
    export: register("export", 60332),
    graphLeft: register("graph-left", 60333),
    magnet: register("magnet", 60334),
    notebook: register("notebook", 60335),
    redo: register("redo", 60336),
    checkAll: register("check-all", 60337),
    pinnedDirty: register("pinned-dirty", 60338),
    passFilled: register("pass-filled", 60339),
    circleLargeFilled: register("circle-large-filled", 60340),
    circleLarge: register("circle-large", 60341),
    circleLargeOutline: register("circle-large-outline", 60341),
    combine: register("combine", 60342),
    gather: register("gather", 60342),
    table: register("table", 60343),
    variableGroup: register("variable-group", 60344),
    typeHierarchy: register("type-hierarchy", 60345),
    typeHierarchySub: register("type-hierarchy-sub", 60346),
    typeHierarchySuper: register("type-hierarchy-super", 60347),
    gitPullRequestCreate: register("git-pull-request-create", 60348),
    runAbove: register("run-above", 60349),
    runBelow: register("run-below", 60350),
    notebookTemplate: register("notebook-template", 60351),
    debugRerun: register("debug-rerun", 60352),
    workspaceTrusted: register("workspace-trusted", 60353),
    workspaceUntrusted: register("workspace-untrusted", 60354),
    workspaceUnknown: register("workspace-unknown", 60355),
    terminalCmd: register("terminal-cmd", 60356),
    terminalDebian: register("terminal-debian", 60357),
    terminalLinux: register("terminal-linux", 60358),
    terminalPowershell: register("terminal-powershell", 60359),
    terminalTmux: register("terminal-tmux", 60360),
    terminalUbuntu: register("terminal-ubuntu", 60361),
    terminalBash: register("terminal-bash", 60362),
    arrowSwap: register("arrow-swap", 60363),
    copy: register("copy", 60364),
    personAdd: register("person-add", 60365),
    filterFilled: register("filter-filled", 60366),
    wand: register("wand", 60367),
    debugLineByLine: register("debug-line-by-line", 60368),
    inspect: register("inspect", 60369),
    layers: register("layers", 60370),
    layersDot: register("layers-dot", 60371),
    layersActive: register("layers-active", 60372),
    compass: register("compass", 60373),
    compassDot: register("compass-dot", 60374),
    compassActive: register("compass-active", 60375),
    azure: register("azure", 60376),
    issueDraft: register("issue-draft", 60377),
    gitPullRequestClosed: register("git-pull-request-closed", 60378),
    gitPullRequestDraft: register("git-pull-request-draft", 60379),
    debugAll: register("debug-all", 60380),
    debugCoverage: register("debug-coverage", 60381),
    runErrors: register("run-errors", 60382),
    folderLibrary: register("folder-library", 60383),
    debugContinueSmall: register("debug-continue-small", 60384),
    beakerStop: register("beaker-stop", 60385),
    graphLine: register("graph-line", 60386),
    graphScatter: register("graph-scatter", 60387),
    pieChart: register("pie-chart", 60388),
    bracket: register("bracket", 60175),
    bracketDot: register("bracket-dot", 60389),
    bracketError: register("bracket-error", 60390),
    lockSmall: register("lock-small", 60391),
    azureDevops: register("azure-devops", 60392),
    verifiedFilled: register("verified-filled", 60393),
    newline: register("newline", 60394),
    layout: register("layout", 60395),
    layoutActivitybarLeft: register("layout-activitybar-left", 60396),
    layoutActivitybarRight: register("layout-activitybar-right", 60397),
    layoutPanelLeft: register("layout-panel-left", 60398),
    layoutPanelCenter: register("layout-panel-center", 60399),
    layoutPanelJustify: register("layout-panel-justify", 60400),
    layoutPanelRight: register("layout-panel-right", 60401),
    layoutPanel: register("layout-panel", 60402),
    layoutSidebarLeft: register("layout-sidebar-left", 60403),
    layoutSidebarRight: register("layout-sidebar-right", 60404),
    layoutStatusbar: register("layout-statusbar", 60405),
    layoutMenubar: register("layout-menubar", 60406),
    layoutCentered: register("layout-centered", 60407),
    target: register("target", 60408),
    indent: register("indent", 60409),
    recordSmall: register("record-small", 60410),
    errorSmall: register("error-small", 60411),
    terminalDecorationError: register("terminal-decoration-error", 60411),
    arrowCircleDown: register("arrow-circle-down", 60412),
    arrowCircleLeft: register("arrow-circle-left", 60413),
    arrowCircleRight: register("arrow-circle-right", 60414),
    arrowCircleUp: register("arrow-circle-up", 60415),
    layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
    layoutPanelOff: register("layout-panel-off", 60417),
    layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
    blank: register("blank", 60419),
    heartFilled: register("heart-filled", 60420),
    map: register("map", 60421),
    mapHorizontal: register("map-horizontal", 60421),
    foldHorizontal: register("fold-horizontal", 60421),
    mapFilled: register("map-filled", 60422),
    mapHorizontalFilled: register("map-horizontal-filled", 60422),
    foldHorizontalFilled: register("fold-horizontal-filled", 60422),
    circleSmall: register("circle-small", 60423),
    bellSlash: register("bell-slash", 60424),
    bellSlashDot: register("bell-slash-dot", 60425),
    commentUnresolved: register("comment-unresolved", 60426),
    gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
    gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
    searchFuzzy: register("search-fuzzy", 60429),
    commentDraft: register("comment-draft", 60430),
    send: register("send", 60431),
    sparkle: register("sparkle", 60432),
    insert: register("insert", 60433),
    mic: register("mic", 60434),
    thumbsdownFilled: register("thumbsdown-filled", 60435),
    thumbsupFilled: register("thumbsup-filled", 60436),
    coffee: register("coffee", 60437),
    snake: register("snake", 60438),
    game: register("game", 60439),
    vr: register("vr", 60440),
    chip: register("chip", 60441),
    piano: register("piano", 60442),
    music: register("music", 60443),
    micFilled: register("mic-filled", 60444),
    repoFetch: register("repo-fetch", 60445),
    copilot: register("copilot", 60446),
    lightbulbSparkle: register("lightbulb-sparkle", 60447),
    robot: register("robot", 60448),
    sparkleFilled: register("sparkle-filled", 60449),
    diffSingle: register("diff-single", 60450),
    diffMultiple: register("diff-multiple", 60451),
    surroundWith: register("surround-with", 60452),
    share: register("share", 60453),
    gitStash: register("git-stash", 60454),
    gitStashApply: register("git-stash-apply", 60455),
    gitStashPop: register("git-stash-pop", 60456),
    vscode: register("vscode", 60457),
    vscodeInsiders: register("vscode-insiders", 60458),
    codeOss: register("code-oss", 60459),
    runCoverage: register("run-coverage", 60460),
    runAllCoverage: register("run-all-coverage", 60461),
    coverage: register("coverage", 60462),
    githubProject: register("github-project", 60463),
    mapVertical: register("map-vertical", 60464),
    foldVertical: register("fold-vertical", 60464),
    mapVerticalFilled: register("map-vertical-filled", 60465),
    foldVerticalFilled: register("fold-vertical-filled", 60465),
    goToSearch: register("go-to-search", 60466),
    percentage: register("percentage", 60467),
    sortPercentage: register("sort-percentage", 60467),
    attach: register("attach", 60468)
  };

  // node_modules/monaco-editor/esm/vs/base/common/codicons.js
  var codiconsDerived = {
    dialogError: register("dialog-error", "error"),
    dialogWarning: register("dialog-warning", "warning"),
    dialogInfo: register("dialog-info", "info"),
    dialogClose: register("dialog-close", "close"),
    treeItemExpanded: register("tree-item-expanded", "chevron-down"),
    // collapsed is done with rotation
    treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
    treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
    treeFilterClear: register("tree-filter-clear", "close"),
    treeItemLoading: register("tree-item-loading", "loading"),
    menuSelection: register("menu-selection", "check"),
    menuSubmenu: register("menu-submenu", "chevron-right"),
    menuBarMore: register("menubar-more", "more"),
    scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
    scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
    scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
    scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
    toolBarMore: register("toolbar-more", "more"),
    quickInputBack: register("quick-input-back", "arrow-left"),
    dropDownButton: register("drop-down-button", 60084),
    symbolCustomColor: register("symbol-customcolor", 60252),
    exportIcon: register("export", 60332),
    workspaceUnspecified: register("workspace-unspecified", 60355),
    newLine: register("newline", 60394),
    thumbsDownFilled: register("thumbsdown-filled", 60435),
    thumbsUpFilled: register("thumbsup-filled", 60436),
    gitFetch: register("git-fetch", 60445),
    lightbulbSparkleAutofix: register("lightbulb-sparkle-autofix", 60447),
    debugBreakpointPending: register("debug-breakpoint-pending", 60377)
  };
  var Codicon = {
    ...codiconsLibrary,
    ...codiconsDerived
  };

  // node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
  var TokenizationRegistry = class {
    constructor() {
      this._tokenizationSupports = /* @__PURE__ */ new Map();
      this._factories = /* @__PURE__ */ new Map();
      this._onDidChange = new Emitter();
      this.onDidChange = this._onDidChange.event;
      this._colorMap = null;
    }
    handleChange(languageIds) {
      this._onDidChange.fire({
        changedLanguages: languageIds,
        changedColorMap: false
      });
    }
    register(languageId, support) {
      this._tokenizationSupports.set(languageId, support);
      this.handleChange([languageId]);
      return toDisposable(() => {
        if (this._tokenizationSupports.get(languageId) !== support) {
          return;
        }
        this._tokenizationSupports.delete(languageId);
        this.handleChange([languageId]);
      });
    }
    get(languageId) {
      return this._tokenizationSupports.get(languageId) || null;
    }
    registerFactory(languageId, factory) {
      this._factories.get(languageId)?.dispose();
      const myData = new TokenizationSupportFactoryData(this, languageId, factory);
      this._factories.set(languageId, myData);
      return toDisposable(() => {
        const v2 = this._factories.get(languageId);
        if (!v2 || v2 !== myData) {
          return;
        }
        this._factories.delete(languageId);
        v2.dispose();
      });
    }
    async getOrCreate(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return tokenizationSupport;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return null;
      }
      await factory.resolve();
      return this.get(languageId);
    }
    isResolved(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return true;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return true;
      }
      return false;
    }
    setColorMap(colorMap) {
      this._colorMap = colorMap;
      this._onDidChange.fire({
        changedLanguages: Array.from(this._tokenizationSupports.keys()),
        changedColorMap: true
      });
    }
    getColorMap() {
      return this._colorMap;
    }
    getDefaultBackground() {
      if (this._colorMap && this._colorMap.length > 2) {
        return this._colorMap[
          2
          /* ColorId.DefaultBackground */
        ];
      }
      return null;
    }
  };
  var TokenizationSupportFactoryData = class extends Disposable {
    get isResolved() {
      return this._isResolved;
    }
    constructor(_registry, _languageId, _factory) {
      super();
      this._registry = _registry;
      this._languageId = _languageId;
      this._factory = _factory;
      this._isDisposed = false;
      this._resolvePromise = null;
      this._isResolved = false;
    }
    dispose() {
      this._isDisposed = true;
      super.dispose();
    }
    async resolve() {
      if (!this._resolvePromise) {
        this._resolvePromise = this._create();
      }
      return this._resolvePromise;
    }
    async _create() {
      const value = await this._factory.tokenizationSupport;
      this._isResolved = true;
      if (value && !this._isDisposed) {
        this._register(this._registry.register(this._languageId, value));
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/languages.js
  var Token = class {
    constructor(offset, type2, language) {
      this.offset = offset;
      this.type = type2;
      this.language = language;
      this._tokenBrand = void 0;
    }
    toString() {
      return "(" + this.offset + ", " + this.type + ")";
    }
  };
  var HoverVerbosityAction;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction || (HoverVerbosityAction = {}));
  var CompletionItemKinds;
  (function(CompletionItemKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolMethod);
    byKind.set(1, Codicon.symbolFunction);
    byKind.set(2, Codicon.symbolConstructor);
    byKind.set(3, Codicon.symbolField);
    byKind.set(4, Codicon.symbolVariable);
    byKind.set(5, Codicon.symbolClass);
    byKind.set(6, Codicon.symbolStruct);
    byKind.set(7, Codicon.symbolInterface);
    byKind.set(8, Codicon.symbolModule);
    byKind.set(9, Codicon.symbolProperty);
    byKind.set(10, Codicon.symbolEvent);
    byKind.set(11, Codicon.symbolOperator);
    byKind.set(12, Codicon.symbolUnit);
    byKind.set(13, Codicon.symbolValue);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(14, Codicon.symbolConstant);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(16, Codicon.symbolEnumMember);
    byKind.set(17, Codicon.symbolKeyword);
    byKind.set(27, Codicon.symbolSnippet);
    byKind.set(18, Codicon.symbolText);
    byKind.set(19, Codicon.symbolColor);
    byKind.set(20, Codicon.symbolFile);
    byKind.set(21, Codicon.symbolReference);
    byKind.set(22, Codicon.symbolCustomColor);
    byKind.set(23, Codicon.symbolFolder);
    byKind.set(24, Codicon.symbolTypeParameter);
    byKind.set(25, Codicon.account);
    byKind.set(26, Codicon.issues);
    function toIcon(kind) {
      let codicon = byKind.get(kind);
      if (!codicon) {
        console.info("No codicon found for CompletionItemKind " + kind);
        codicon = Codicon.symbolProperty;
      }
      return codicon;
    }
    CompletionItemKinds2.toIcon = toIcon;
    const data = /* @__PURE__ */ new Map();
    data.set(
      "method",
      0
      /* CompletionItemKind.Method */
    );
    data.set(
      "function",
      1
      /* CompletionItemKind.Function */
    );
    data.set(
      "constructor",
      2
      /* CompletionItemKind.Constructor */
    );
    data.set(
      "field",
      3
      /* CompletionItemKind.Field */
    );
    data.set(
      "variable",
      4
      /* CompletionItemKind.Variable */
    );
    data.set(
      "class",
      5
      /* CompletionItemKind.Class */
    );
    data.set(
      "struct",
      6
      /* CompletionItemKind.Struct */
    );
    data.set(
      "interface",
      7
      /* CompletionItemKind.Interface */
    );
    data.set(
      "module",
      8
      /* CompletionItemKind.Module */
    );
    data.set(
      "property",
      9
      /* CompletionItemKind.Property */
    );
    data.set(
      "event",
      10
      /* CompletionItemKind.Event */
    );
    data.set(
      "operator",
      11
      /* CompletionItemKind.Operator */
    );
    data.set(
      "unit",
      12
      /* CompletionItemKind.Unit */
    );
    data.set(
      "value",
      13
      /* CompletionItemKind.Value */
    );
    data.set(
      "constant",
      14
      /* CompletionItemKind.Constant */
    );
    data.set(
      "enum",
      15
      /* CompletionItemKind.Enum */
    );
    data.set(
      "enum-member",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "enumMember",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "keyword",
      17
      /* CompletionItemKind.Keyword */
    );
    data.set(
      "snippet",
      27
      /* CompletionItemKind.Snippet */
    );
    data.set(
      "text",
      18
      /* CompletionItemKind.Text */
    );
    data.set(
      "color",
      19
      /* CompletionItemKind.Color */
    );
    data.set(
      "file",
      20
      /* CompletionItemKind.File */
    );
    data.set(
      "reference",
      21
      /* CompletionItemKind.Reference */
    );
    data.set(
      "customcolor",
      22
      /* CompletionItemKind.Customcolor */
    );
    data.set(
      "folder",
      23
      /* CompletionItemKind.Folder */
    );
    data.set(
      "type-parameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "typeParameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "account",
      25
      /* CompletionItemKind.User */
    );
    data.set(
      "issue",
      26
      /* CompletionItemKind.Issue */
    );
    function fromString(value, strict) {
      let res = data.get(value);
      if (typeof res === "undefined" && !strict) {
        res = 9;
      }
      return res;
    }
    CompletionItemKinds2.fromString = fromString;
  })(CompletionItemKinds || (CompletionItemKinds = {}));
  var InlineCompletionTriggerKind;
  (function(InlineCompletionTriggerKind4) {
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
  var DocumentPasteTriggerKind;
  (function(DocumentPasteTriggerKind2) {
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["Automatic"] = 0] = "Automatic";
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["PasteAs"] = 1] = "PasteAs";
  })(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
    DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
    DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var symbolKindNames = {
    [
      17
      /* SymbolKind.Array */
    ]: localize("Array", "array"),
    [
      16
      /* SymbolKind.Boolean */
    ]: localize("Boolean", "boolean"),
    [
      4
      /* SymbolKind.Class */
    ]: localize("Class", "class"),
    [
      13
      /* SymbolKind.Constant */
    ]: localize("Constant", "constant"),
    [
      8
      /* SymbolKind.Constructor */
    ]: localize("Constructor", "constructor"),
    [
      9
      /* SymbolKind.Enum */
    ]: localize("Enum", "enumeration"),
    [
      21
      /* SymbolKind.EnumMember */
    ]: localize("EnumMember", "enumeration member"),
    [
      23
      /* SymbolKind.Event */
    ]: localize("Event", "event"),
    [
      7
      /* SymbolKind.Field */
    ]: localize("Field", "field"),
    [
      0
      /* SymbolKind.File */
    ]: localize("File", "file"),
    [
      11
      /* SymbolKind.Function */
    ]: localize("Function", "function"),
    [
      10
      /* SymbolKind.Interface */
    ]: localize("Interface", "interface"),
    [
      19
      /* SymbolKind.Key */
    ]: localize("Key", "key"),
    [
      5
      /* SymbolKind.Method */
    ]: localize("Method", "method"),
    [
      1
      /* SymbolKind.Module */
    ]: localize("Module", "module"),
    [
      2
      /* SymbolKind.Namespace */
    ]: localize("Namespace", "namespace"),
    [
      20
      /* SymbolKind.Null */
    ]: localize("Null", "null"),
    [
      15
      /* SymbolKind.Number */
    ]: localize("Number", "number"),
    [
      18
      /* SymbolKind.Object */
    ]: localize("Object", "object"),
    [
      24
      /* SymbolKind.Operator */
    ]: localize("Operator", "operator"),
    [
      3
      /* SymbolKind.Package */
    ]: localize("Package", "package"),
    [
      6
      /* SymbolKind.Property */
    ]: localize("Property", "property"),
    [
      14
      /* SymbolKind.String */
    ]: localize("String", "string"),
    [
      22
      /* SymbolKind.Struct */
    ]: localize("Struct", "struct"),
    [
      25
      /* SymbolKind.TypeParameter */
    ]: localize("TypeParameter", "type parameter"),
    [
      12
      /* SymbolKind.Variable */
    ]: localize("Variable", "variable")
  };
  var SymbolKinds;
  (function(SymbolKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolFile);
    byKind.set(1, Codicon.symbolModule);
    byKind.set(2, Codicon.symbolNamespace);
    byKind.set(3, Codicon.symbolPackage);
    byKind.set(4, Codicon.symbolClass);
    byKind.set(5, Codicon.symbolMethod);
    byKind.set(6, Codicon.symbolProperty);
    byKind.set(7, Codicon.symbolField);
    byKind.set(8, Codicon.symbolConstructor);
    byKind.set(9, Codicon.symbolEnum);
    byKind.set(10, Codicon.symbolInterface);
    byKind.set(11, Codicon.symbolFunction);
    byKind.set(12, Codicon.symbolVariable);
    byKind.set(13, Codicon.symbolConstant);
    byKind.set(14, Codicon.symbolString);
    byKind.set(15, Codicon.symbolNumber);
    byKind.set(16, Codicon.symbolBoolean);
    byKind.set(17, Codicon.symbolArray);
    byKind.set(18, Codicon.symbolObject);
    byKind.set(19, Codicon.symbolKey);
    byKind.set(20, Codicon.symbolNull);
    byKind.set(21, Codicon.symbolEnumMember);
    byKind.set(22, Codicon.symbolStruct);
    byKind.set(23, Codicon.symbolEvent);
    byKind.set(24, Codicon.symbolOperator);
    byKind.set(25, Codicon.symbolTypeParameter);
    function toIcon(kind) {
      let icon = byKind.get(kind);
      if (!icon) {
        console.info("No codicon found for SymbolKind " + kind);
        icon = Codicon.symbolProperty;
      }
      return icon;
    }
    SymbolKinds2.toIcon = toIcon;
  })(SymbolKinds || (SymbolKinds = {}));
  var FoldingRangeKind = class _FoldingRangeKind {
    static {
      this.Comment = new _FoldingRangeKind("comment");
    }
    static {
      this.Imports = new _FoldingRangeKind("imports");
    }
    static {
      this.Region = new _FoldingRangeKind("region");
    }
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value) {
      switch (value) {
        case "comment":
          return _FoldingRangeKind.Comment;
        case "imports":
          return _FoldingRangeKind.Imports;
        case "region":
          return _FoldingRangeKind.Region;
      }
      return new _FoldingRangeKind(value);
    }
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value) {
      this.value = value;
    }
  };
  var NewSymbolNameTag;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag || (NewSymbolNameTag = {}));
  var NewSymbolNameTriggerKind;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));
  var Command;
  (function(Command3) {
    function is(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return typeof obj.id === "string" && typeof obj.title === "string";
    }
    Command3.is = is;
  })(Command || (Command = {}));
  var InlayHintKind;
  (function(InlayHintKind4) {
    InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
    InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
  })(InlayHintKind || (InlayHintKind = {}));
  var TokenizationRegistry2 = new TokenizationRegistry();
  var TreeSitterTokenizationRegistry = new TokenizationRegistry();
  var InlineEditTriggerKind;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind || (InlineEditTriggerKind = {}));

  // node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport;
  (function(AccessibilitySupport2) {
    AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
    AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
    AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
  })(AccessibilitySupport || (AccessibilitySupport = {}));
  var CodeActionTriggerType;
  (function(CodeActionTriggerType2) {
    CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
    CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
  })(CodeActionTriggerType || (CodeActionTriggerType = {}));
  var CompletionItemInsertTextRule;
  (function(CompletionItemInsertTextRule2) {
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
  })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
  var CompletionItemKind;
  (function(CompletionItemKind4) {
    CompletionItemKind4[CompletionItemKind4["Method"] = 0] = "Method";
    CompletionItemKind4[CompletionItemKind4["Function"] = 1] = "Function";
    CompletionItemKind4[CompletionItemKind4["Constructor"] = 2] = "Constructor";
    CompletionItemKind4[CompletionItemKind4["Field"] = 3] = "Field";
    CompletionItemKind4[CompletionItemKind4["Variable"] = 4] = "Variable";
    CompletionItemKind4[CompletionItemKind4["Class"] = 5] = "Class";
    CompletionItemKind4[CompletionItemKind4["Struct"] = 6] = "Struct";
    CompletionItemKind4[CompletionItemKind4["Interface"] = 7] = "Interface";
    CompletionItemKind4[CompletionItemKind4["Module"] = 8] = "Module";
    CompletionItemKind4[CompletionItemKind4["Property"] = 9] = "Property";
    CompletionItemKind4[CompletionItemKind4["Event"] = 10] = "Event";
    CompletionItemKind4[CompletionItemKind4["Operator"] = 11] = "Operator";
    CompletionItemKind4[CompletionItemKind4["Unit"] = 12] = "Unit";
    CompletionItemKind4[CompletionItemKind4["Value"] = 13] = "Value";
    CompletionItemKind4[CompletionItemKind4["Constant"] = 14] = "Constant";
    CompletionItemKind4[CompletionItemKind4["Enum"] = 15] = "Enum";
    CompletionItemKind4[CompletionItemKind4["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind4[CompletionItemKind4["Keyword"] = 17] = "Keyword";
    CompletionItemKind4[CompletionItemKind4["Text"] = 18] = "Text";
    CompletionItemKind4[CompletionItemKind4["Color"] = 19] = "Color";
    CompletionItemKind4[CompletionItemKind4["File"] = 20] = "File";
    CompletionItemKind4[CompletionItemKind4["Reference"] = 21] = "Reference";
    CompletionItemKind4[CompletionItemKind4["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind4[CompletionItemKind4["Folder"] = 23] = "Folder";
    CompletionItemKind4[CompletionItemKind4["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind4[CompletionItemKind4["User"] = 25] = "User";
    CompletionItemKind4[CompletionItemKind4["Issue"] = 26] = "Issue";
    CompletionItemKind4[CompletionItemKind4["Snippet"] = 27] = "Snippet";
  })(CompletionItemKind || (CompletionItemKind = {}));
  var CompletionItemTag;
  (function(CompletionItemTag3) {
    CompletionItemTag3[CompletionItemTag3["Deprecated"] = 1] = "Deprecated";
  })(CompletionItemTag || (CompletionItemTag = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
  })(CompletionTriggerKind || (CompletionTriggerKind = {}));
  var ContentWidgetPositionPreference;
  (function(ContentWidgetPositionPreference2) {
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
  })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
  var CursorChangeReason;
  (function(CursorChangeReason2) {
    CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
    CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
    CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
    CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
    CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
    CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
  })(CursorChangeReason || (CursorChangeReason = {}));
  var DefaultEndOfLine;
  (function(DefaultEndOfLine2) {
    DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
    DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
  })(DefaultEndOfLine || (DefaultEndOfLine = {}));
  var DocumentHighlightKind2;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
    DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
    DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
  })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
  var EditorAutoIndentStrategy;
  (function(EditorAutoIndentStrategy2) {
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
  })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
  var EditorOption;
  (function(EditorOption2) {
    EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
    EditorOption2[EditorOption2["ariaRequired"] = 5] = "ariaRequired";
    EditorOption2[EditorOption2["autoClosingBrackets"] = 6] = "autoClosingBrackets";
    EditorOption2[EditorOption2["autoClosingComments"] = 7] = "autoClosingComments";
    EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
    EditorOption2[EditorOption2["autoClosingDelete"] = 9] = "autoClosingDelete";
    EditorOption2[EditorOption2["autoClosingOvertype"] = 10] = "autoClosingOvertype";
    EditorOption2[EditorOption2["autoClosingQuotes"] = 11] = "autoClosingQuotes";
    EditorOption2[EditorOption2["autoIndent"] = 12] = "autoIndent";
    EditorOption2[EditorOption2["automaticLayout"] = 13] = "automaticLayout";
    EditorOption2[EditorOption2["autoSurround"] = 14] = "autoSurround";
    EditorOption2[EditorOption2["bracketPairColorization"] = 15] = "bracketPairColorization";
    EditorOption2[EditorOption2["guides"] = 16] = "guides";
    EditorOption2[EditorOption2["codeLens"] = 17] = "codeLens";
    EditorOption2[EditorOption2["codeLensFontFamily"] = 18] = "codeLensFontFamily";
    EditorOption2[EditorOption2["codeLensFontSize"] = 19] = "codeLensFontSize";
    EditorOption2[EditorOption2["colorDecorators"] = 20] = "colorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
    EditorOption2[EditorOption2["columnSelection"] = 22] = "columnSelection";
    EditorOption2[EditorOption2["comments"] = 23] = "comments";
    EditorOption2[EditorOption2["contextmenu"] = 24] = "contextmenu";
    EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
    EditorOption2[EditorOption2["cursorBlinking"] = 26] = "cursorBlinking";
    EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
    EditorOption2[EditorOption2["cursorStyle"] = 28] = "cursorStyle";
    EditorOption2[EditorOption2["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
    EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
    EditorOption2[EditorOption2["cursorWidth"] = 31] = "cursorWidth";
    EditorOption2[EditorOption2["disableLayerHinting"] = 32] = "disableLayerHinting";
    EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
    EditorOption2[EditorOption2["domReadOnly"] = 34] = "domReadOnly";
    EditorOption2[EditorOption2["dragAndDrop"] = 35] = "dragAndDrop";
    EditorOption2[EditorOption2["dropIntoEditor"] = 36] = "dropIntoEditor";
    EditorOption2[EditorOption2["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
    EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
    EditorOption2[EditorOption2["extraEditorClassName"] = 39] = "extraEditorClassName";
    EditorOption2[EditorOption2["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
    EditorOption2[EditorOption2["find"] = 41] = "find";
    EditorOption2[EditorOption2["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
    EditorOption2[EditorOption2["folding"] = 43] = "folding";
    EditorOption2[EditorOption2["foldingStrategy"] = 44] = "foldingStrategy";
    EditorOption2[EditorOption2["foldingHighlight"] = 45] = "foldingHighlight";
    EditorOption2[EditorOption2["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
    EditorOption2[EditorOption2["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
    EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
    EditorOption2[EditorOption2["fontFamily"] = 49] = "fontFamily";
    EditorOption2[EditorOption2["fontInfo"] = 50] = "fontInfo";
    EditorOption2[EditorOption2["fontLigatures"] = 51] = "fontLigatures";
    EditorOption2[EditorOption2["fontSize"] = 52] = "fontSize";
    EditorOption2[EditorOption2["fontWeight"] = 53] = "fontWeight";
    EditorOption2[EditorOption2["fontVariations"] = 54] = "fontVariations";
    EditorOption2[EditorOption2["formatOnPaste"] = 55] = "formatOnPaste";
    EditorOption2[EditorOption2["formatOnType"] = 56] = "formatOnType";
    EditorOption2[EditorOption2["glyphMargin"] = 57] = "glyphMargin";
    EditorOption2[EditorOption2["gotoLocation"] = 58] = "gotoLocation";
    EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
    EditorOption2[EditorOption2["hover"] = 60] = "hover";
    EditorOption2[EditorOption2["inDiffEditor"] = 61] = "inDiffEditor";
    EditorOption2[EditorOption2["inlineSuggest"] = 62] = "inlineSuggest";
    EditorOption2[EditorOption2["inlineEdit"] = 63] = "inlineEdit";
    EditorOption2[EditorOption2["letterSpacing"] = 64] = "letterSpacing";
    EditorOption2[EditorOption2["lightbulb"] = 65] = "lightbulb";
    EditorOption2[EditorOption2["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
    EditorOption2[EditorOption2["lineHeight"] = 67] = "lineHeight";
    EditorOption2[EditorOption2["lineNumbers"] = 68] = "lineNumbers";
    EditorOption2[EditorOption2["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
    EditorOption2[EditorOption2["linkedEditing"] = 70] = "linkedEditing";
    EditorOption2[EditorOption2["links"] = 71] = "links";
    EditorOption2[EditorOption2["matchBrackets"] = 72] = "matchBrackets";
    EditorOption2[EditorOption2["minimap"] = 73] = "minimap";
    EditorOption2[EditorOption2["mouseStyle"] = 74] = "mouseStyle";
    EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
    EditorOption2[EditorOption2["mouseWheelZoom"] = 76] = "mouseWheelZoom";
    EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
    EditorOption2[EditorOption2["multiCursorModifier"] = 78] = "multiCursorModifier";
    EditorOption2[EditorOption2["multiCursorPaste"] = 79] = "multiCursorPaste";
    EditorOption2[EditorOption2["multiCursorLimit"] = 80] = "multiCursorLimit";
    EditorOption2[EditorOption2["occurrencesHighlight"] = 81] = "occurrencesHighlight";
    EditorOption2[EditorOption2["overviewRulerBorder"] = 82] = "overviewRulerBorder";
    EditorOption2[EditorOption2["overviewRulerLanes"] = 83] = "overviewRulerLanes";
    EditorOption2[EditorOption2["padding"] = 84] = "padding";
    EditorOption2[EditorOption2["pasteAs"] = 85] = "pasteAs";
    EditorOption2[EditorOption2["parameterHints"] = 86] = "parameterHints";
    EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
    EditorOption2[EditorOption2["placeholder"] = 88] = "placeholder";
    EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 89] = "definitionLinkOpensInPeek";
    EditorOption2[EditorOption2["quickSuggestions"] = 90] = "quickSuggestions";
    EditorOption2[EditorOption2["quickSuggestionsDelay"] = 91] = "quickSuggestionsDelay";
    EditorOption2[EditorOption2["readOnly"] = 92] = "readOnly";
    EditorOption2[EditorOption2["readOnlyMessage"] = 93] = "readOnlyMessage";
    EditorOption2[EditorOption2["renameOnType"] = 94] = "renameOnType";
    EditorOption2[EditorOption2["renderControlCharacters"] = 95] = "renderControlCharacters";
    EditorOption2[EditorOption2["renderFinalNewline"] = 96] = "renderFinalNewline";
    EditorOption2[EditorOption2["renderLineHighlight"] = 97] = "renderLineHighlight";
    EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 98] = "renderLineHighlightOnlyWhenFocus";
    EditorOption2[EditorOption2["renderValidationDecorations"] = 99] = "renderValidationDecorations";
    EditorOption2[EditorOption2["renderWhitespace"] = 100] = "renderWhitespace";
    EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 101] = "revealHorizontalRightPadding";
    EditorOption2[EditorOption2["roundedSelection"] = 102] = "roundedSelection";
    EditorOption2[EditorOption2["rulers"] = 103] = "rulers";
    EditorOption2[EditorOption2["scrollbar"] = 104] = "scrollbar";
    EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 105] = "scrollBeyondLastColumn";
    EditorOption2[EditorOption2["scrollBeyondLastLine"] = 106] = "scrollBeyondLastLine";
    EditorOption2[EditorOption2["scrollPredominantAxis"] = 107] = "scrollPredominantAxis";
    EditorOption2[EditorOption2["selectionClipboard"] = 108] = "selectionClipboard";
    EditorOption2[EditorOption2["selectionHighlight"] = 109] = "selectionHighlight";
    EditorOption2[EditorOption2["selectOnLineNumbers"] = 110] = "selectOnLineNumbers";
    EditorOption2[EditorOption2["showFoldingControls"] = 111] = "showFoldingControls";
    EditorOption2[EditorOption2["showUnused"] = 112] = "showUnused";
    EditorOption2[EditorOption2["snippetSuggestions"] = 113] = "snippetSuggestions";
    EditorOption2[EditorOption2["smartSelect"] = 114] = "smartSelect";
    EditorOption2[EditorOption2["smoothScrolling"] = 115] = "smoothScrolling";
    EditorOption2[EditorOption2["stickyScroll"] = 116] = "stickyScroll";
    EditorOption2[EditorOption2["stickyTabStops"] = 117] = "stickyTabStops";
    EditorOption2[EditorOption2["stopRenderingLineAfter"] = 118] = "stopRenderingLineAfter";
    EditorOption2[EditorOption2["suggest"] = 119] = "suggest";
    EditorOption2[EditorOption2["suggestFontSize"] = 120] = "suggestFontSize";
    EditorOption2[EditorOption2["suggestLineHeight"] = 121] = "suggestLineHeight";
    EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 122] = "suggestOnTriggerCharacters";
    EditorOption2[EditorOption2["suggestSelection"] = 123] = "suggestSelection";
    EditorOption2[EditorOption2["tabCompletion"] = 124] = "tabCompletion";
    EditorOption2[EditorOption2["tabIndex"] = 125] = "tabIndex";
    EditorOption2[EditorOption2["unicodeHighlighting"] = 126] = "unicodeHighlighting";
    EditorOption2[EditorOption2["unusualLineTerminators"] = 127] = "unusualLineTerminators";
    EditorOption2[EditorOption2["useShadowDOM"] = 128] = "useShadowDOM";
    EditorOption2[EditorOption2["useTabStops"] = 129] = "useTabStops";
    EditorOption2[EditorOption2["wordBreak"] = 130] = "wordBreak";
    EditorOption2[EditorOption2["wordSegmenterLocales"] = 131] = "wordSegmenterLocales";
    EditorOption2[EditorOption2["wordSeparators"] = 132] = "wordSeparators";
    EditorOption2[EditorOption2["wordWrap"] = 133] = "wordWrap";
    EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 134] = "wordWrapBreakAfterCharacters";
    EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 135] = "wordWrapBreakBeforeCharacters";
    EditorOption2[EditorOption2["wordWrapColumn"] = 136] = "wordWrapColumn";
    EditorOption2[EditorOption2["wordWrapOverride1"] = 137] = "wordWrapOverride1";
    EditorOption2[EditorOption2["wordWrapOverride2"] = 138] = "wordWrapOverride2";
    EditorOption2[EditorOption2["wrappingIndent"] = 139] = "wrappingIndent";
    EditorOption2[EditorOption2["wrappingStrategy"] = 140] = "wrappingStrategy";
    EditorOption2[EditorOption2["showDeprecated"] = 141] = "showDeprecated";
    EditorOption2[EditorOption2["inlayHints"] = 142] = "inlayHints";
    EditorOption2[EditorOption2["editorClassName"] = 143] = "editorClassName";
    EditorOption2[EditorOption2["pixelRatio"] = 144] = "pixelRatio";
    EditorOption2[EditorOption2["tabFocusMode"] = 145] = "tabFocusMode";
    EditorOption2[EditorOption2["layoutInfo"] = 146] = "layoutInfo";
    EditorOption2[EditorOption2["wrappingInfo"] = 147] = "wrappingInfo";
    EditorOption2[EditorOption2["defaultColorDecorators"] = 148] = "defaultColorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 149] = "colorDecoratorsActivatedOn";
    EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 150] = "inlineCompletionsAccessibilityVerbose";
  })(EditorOption || (EditorOption = {}));
  var EndOfLinePreference;
  (function(EndOfLinePreference2) {
    EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
    EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
    EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
  })(EndOfLinePreference || (EndOfLinePreference = {}));
  var EndOfLineSequence;
  (function(EndOfLineSequence2) {
    EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
    EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
  })(EndOfLineSequence || (EndOfLineSequence = {}));
  var GlyphMarginLane;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane || (GlyphMarginLane = {}));
  var HoverVerbosityAction2;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction2 || (HoverVerbosityAction2 = {}));
  var IndentAction;
  (function(IndentAction2) {
    IndentAction2[IndentAction2["None"] = 0] = "None";
    IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
    IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
    IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
  })(IndentAction || (IndentAction = {}));
  var InjectedTextCursorStops;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
  var InlayHintKind2;
  (function(InlayHintKind4) {
    InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
    InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
  })(InlayHintKind2 || (InlayHintKind2 = {}));
  var InlineCompletionTriggerKind2;
  (function(InlineCompletionTriggerKind4) {
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
  var InlineEditTriggerKind2;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind2 || (InlineEditTriggerKind2 = {}));
  var KeyCode;
  (function(KeyCode2) {
    KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
    KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
    KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
    KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
    KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
    KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
    KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
    KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
    KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
    KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
    KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
    KeyCode2[KeyCode2["Space"] = 10] = "Space";
    KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
    KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
    KeyCode2[KeyCode2["End"] = 13] = "End";
    KeyCode2[KeyCode2["Home"] = 14] = "Home";
    KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
    KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
    KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
    KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
    KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
    KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
    KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
    KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
    KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
    KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
    KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
    KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
    KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
    KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
    KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
    KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
    KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
    KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
    KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
    KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
    KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
    KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
    KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
    KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
    KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
    KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
    KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
    KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
    KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
    KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
    KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
    KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
    KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
    KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
    KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
    KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
    KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
    KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
    KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
    KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
    KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
    KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
    KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
    KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
    KeyCode2[KeyCode2["F1"] = 59] = "F1";
    KeyCode2[KeyCode2["F2"] = 60] = "F2";
    KeyCode2[KeyCode2["F3"] = 61] = "F3";
    KeyCode2[KeyCode2["F4"] = 62] = "F4";
    KeyCode2[KeyCode2["F5"] = 63] = "F5";
    KeyCode2[KeyCode2["F6"] = 64] = "F6";
    KeyCode2[KeyCode2["F7"] = 65] = "F7";
    KeyCode2[KeyCode2["F8"] = 66] = "F8";
    KeyCode2[KeyCode2["F9"] = 67] = "F9";
    KeyCode2[KeyCode2["F10"] = 68] = "F10";
    KeyCode2[KeyCode2["F11"] = 69] = "F11";
    KeyCode2[KeyCode2["F12"] = 70] = "F12";
    KeyCode2[KeyCode2["F13"] = 71] = "F13";
    KeyCode2[KeyCode2["F14"] = 72] = "F14";
    KeyCode2[KeyCode2["F15"] = 73] = "F15";
    KeyCode2[KeyCode2["F16"] = 74] = "F16";
    KeyCode2[KeyCode2["F17"] = 75] = "F17";
    KeyCode2[KeyCode2["F18"] = 76] = "F18";
    KeyCode2[KeyCode2["F19"] = 77] = "F19";
    KeyCode2[KeyCode2["F20"] = 78] = "F20";
    KeyCode2[KeyCode2["F21"] = 79] = "F21";
    KeyCode2[KeyCode2["F22"] = 80] = "F22";
    KeyCode2[KeyCode2["F23"] = 81] = "F23";
    KeyCode2[KeyCode2["F24"] = 82] = "F24";
    KeyCode2[KeyCode2["NumLock"] = 83] = "NumLock";
    KeyCode2[KeyCode2["ScrollLock"] = 84] = "ScrollLock";
    KeyCode2[KeyCode2["Semicolon"] = 85] = "Semicolon";
    KeyCode2[KeyCode2["Equal"] = 86] = "Equal";
    KeyCode2[KeyCode2["Comma"] = 87] = "Comma";
    KeyCode2[KeyCode2["Minus"] = 88] = "Minus";
    KeyCode2[KeyCode2["Period"] = 89] = "Period";
    KeyCode2[KeyCode2["Slash"] = 90] = "Slash";
    KeyCode2[KeyCode2["Backquote"] = 91] = "Backquote";
    KeyCode2[KeyCode2["BracketLeft"] = 92] = "BracketLeft";
    KeyCode2[KeyCode2["Backslash"] = 93] = "Backslash";
    KeyCode2[KeyCode2["BracketRight"] = 94] = "BracketRight";
    KeyCode2[KeyCode2["Quote"] = 95] = "Quote";
    KeyCode2[KeyCode2["OEM_8"] = 96] = "OEM_8";
    KeyCode2[KeyCode2["IntlBackslash"] = 97] = "IntlBackslash";
    KeyCode2[KeyCode2["Numpad0"] = 98] = "Numpad0";
    KeyCode2[KeyCode2["Numpad1"] = 99] = "Numpad1";
    KeyCode2[KeyCode2["Numpad2"] = 100] = "Numpad2";
    KeyCode2[KeyCode2["Numpad3"] = 101] = "Numpad3";
    KeyCode2[KeyCode2["Numpad4"] = 102] = "Numpad4";
    KeyCode2[KeyCode2["Numpad5"] = 103] = "Numpad5";
    KeyCode2[KeyCode2["Numpad6"] = 104] = "Numpad6";
    KeyCode2[KeyCode2["Numpad7"] = 105] = "Numpad7";
    KeyCode2[KeyCode2["Numpad8"] = 106] = "Numpad8";
    KeyCode2[KeyCode2["Numpad9"] = 107] = "Numpad9";
    KeyCode2[KeyCode2["NumpadMultiply"] = 108] = "NumpadMultiply";
    KeyCode2[KeyCode2["NumpadAdd"] = 109] = "NumpadAdd";
    KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
    KeyCode2[KeyCode2["NumpadSubtract"] = 111] = "NumpadSubtract";
    KeyCode2[KeyCode2["NumpadDecimal"] = 112] = "NumpadDecimal";
    KeyCode2[KeyCode2["NumpadDivide"] = 113] = "NumpadDivide";
    KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
    KeyCode2[KeyCode2["ABNT_C1"] = 115] = "ABNT_C1";
    KeyCode2[KeyCode2["ABNT_C2"] = 116] = "ABNT_C2";
    KeyCode2[KeyCode2["AudioVolumeMute"] = 117] = "AudioVolumeMute";
    KeyCode2[KeyCode2["AudioVolumeUp"] = 118] = "AudioVolumeUp";
    KeyCode2[KeyCode2["AudioVolumeDown"] = 119] = "AudioVolumeDown";
    KeyCode2[KeyCode2["BrowserSearch"] = 120] = "BrowserSearch";
    KeyCode2[KeyCode2["BrowserHome"] = 121] = "BrowserHome";
    KeyCode2[KeyCode2["BrowserBack"] = 122] = "BrowserBack";
    KeyCode2[KeyCode2["BrowserForward"] = 123] = "BrowserForward";
    KeyCode2[KeyCode2["MediaTrackNext"] = 124] = "MediaTrackNext";
    KeyCode2[KeyCode2["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
    KeyCode2[KeyCode2["MediaStop"] = 126] = "MediaStop";
    KeyCode2[KeyCode2["MediaPlayPause"] = 127] = "MediaPlayPause";
    KeyCode2[KeyCode2["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
    KeyCode2[KeyCode2["LaunchMail"] = 129] = "LaunchMail";
    KeyCode2[KeyCode2["LaunchApp2"] = 130] = "LaunchApp2";
    KeyCode2[KeyCode2["Clear"] = 131] = "Clear";
    KeyCode2[KeyCode2["MAX_VALUE"] = 132] = "MAX_VALUE";
  })(KeyCode || (KeyCode = {}));
  var MarkerSeverity;
  (function(MarkerSeverity2) {
    MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
    MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
    MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
    MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
  })(MarkerSeverity || (MarkerSeverity = {}));
  var MarkerTag;
  (function(MarkerTag2) {
    MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
  })(MarkerTag || (MarkerTag = {}));
  var MinimapPosition;
  (function(MinimapPosition2) {
    MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
    MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
  })(MinimapPosition || (MinimapPosition = {}));
  var MinimapSectionHeaderStyle;
  (function(MinimapSectionHeaderStyle2) {
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Normal"] = 1] = "Normal";
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Underlined"] = 2] = "Underlined";
  })(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));
  var MouseTargetType;
  (function(MouseTargetType2) {
    MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
    MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
    MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
    MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
  })(MouseTargetType || (MouseTargetType = {}));
  var NewSymbolNameTag2;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));
  var NewSymbolNameTriggerKind2;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind2 || (NewSymbolNameTriggerKind2 = {}));
  var OverlayWidgetPositionPreference;
  (function(OverlayWidgetPositionPreference2) {
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
  })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
  var OverviewRulerLane;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane || (OverviewRulerLane = {}));
  var PartialAcceptTriggerKind;
  (function(PartialAcceptTriggerKind2) {
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Word"] = 0] = "Word";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Line"] = 1] = "Line";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Suggest"] = 2] = "Suggest";
  })(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));
  var PositionAffinity;
  (function(PositionAffinity2) {
    PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
    PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
    PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
    PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
    PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
  })(PositionAffinity || (PositionAffinity = {}));
  var RenderLineNumbersType;
  (function(RenderLineNumbersType2) {
    RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
    RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
    RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
    RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
    RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
  })(RenderLineNumbersType || (RenderLineNumbersType = {}));
  var RenderMinimap;
  (function(RenderMinimap2) {
    RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
    RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
    RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
  })(RenderMinimap || (RenderMinimap = {}));
  var ScrollType;
  (function(ScrollType2) {
    ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
    ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
  })(ScrollType || (ScrollType = {}));
  var ScrollbarVisibility;
  (function(ScrollbarVisibility2) {
    ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
    ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
  })(ScrollbarVisibility || (ScrollbarVisibility = {}));
  var SelectionDirection;
  (function(SelectionDirection2) {
    SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
    SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
  })(SelectionDirection || (SelectionDirection = {}));
  var ShowLightbulbIconMode;
  (function(ShowLightbulbIconMode2) {
    ShowLightbulbIconMode2["Off"] = "off";
    ShowLightbulbIconMode2["OnCode"] = "onCode";
    ShowLightbulbIconMode2["On"] = "on";
  })(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
  var SignatureHelpTriggerKind2;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
  var SymbolKind;
  (function(SymbolKind3) {
    SymbolKind3[SymbolKind3["File"] = 0] = "File";
    SymbolKind3[SymbolKind3["Module"] = 1] = "Module";
    SymbolKind3[SymbolKind3["Namespace"] = 2] = "Namespace";
    SymbolKind3[SymbolKind3["Package"] = 3] = "Package";
    SymbolKind3[SymbolKind3["Class"] = 4] = "Class";
    SymbolKind3[SymbolKind3["Method"] = 5] = "Method";
    SymbolKind3[SymbolKind3["Property"] = 6] = "Property";
    SymbolKind3[SymbolKind3["Field"] = 7] = "Field";
    SymbolKind3[SymbolKind3["Constructor"] = 8] = "Constructor";
    SymbolKind3[SymbolKind3["Enum"] = 9] = "Enum";
    SymbolKind3[SymbolKind3["Interface"] = 10] = "Interface";
    SymbolKind3[SymbolKind3["Function"] = 11] = "Function";
    SymbolKind3[SymbolKind3["Variable"] = 12] = "Variable";
    SymbolKind3[SymbolKind3["Constant"] = 13] = "Constant";
    SymbolKind3[SymbolKind3["String"] = 14] = "String";
    SymbolKind3[SymbolKind3["Number"] = 15] = "Number";
    SymbolKind3[SymbolKind3["Boolean"] = 16] = "Boolean";
    SymbolKind3[SymbolKind3["Array"] = 17] = "Array";
    SymbolKind3[SymbolKind3["Object"] = 18] = "Object";
    SymbolKind3[SymbolKind3["Key"] = 19] = "Key";
    SymbolKind3[SymbolKind3["Null"] = 20] = "Null";
    SymbolKind3[SymbolKind3["EnumMember"] = 21] = "EnumMember";
    SymbolKind3[SymbolKind3["Struct"] = 22] = "Struct";
    SymbolKind3[SymbolKind3["Event"] = 23] = "Event";
    SymbolKind3[SymbolKind3["Operator"] = 24] = "Operator";
    SymbolKind3[SymbolKind3["TypeParameter"] = 25] = "TypeParameter";
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag3) {
    SymbolTag3[SymbolTag3["Deprecated"] = 1] = "Deprecated";
  })(SymbolTag || (SymbolTag = {}));
  var TextEditorCursorBlinkingStyle;
  (function(TextEditorCursorBlinkingStyle2) {
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
  })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
  var TextEditorCursorStyle;
  (function(TextEditorCursorStyle2) {
    TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
    TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
  })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
  var TrackedRangeStickiness;
  (function(TrackedRangeStickiness2) {
    TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
  })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
  var WrappingIndent;
  (function(WrappingIndent2) {
    WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
    WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
    WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
    WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
  })(WrappingIndent || (WrappingIndent = {}));

  // node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
  var KeyMod = class {
    static {
      this.CtrlCmd = 2048;
    }
    static {
      this.Shift = 1024;
    }
    static {
      this.Alt = 512;
    }
    static {
      this.WinCtrl = 256;
    }
    static chord(firstPart, secondPart) {
      return KeyChord(firstPart, secondPart);
    }
  };
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      // undefined override expected here
      languages: void 0,
      // undefined override expected here
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position,
      Range,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI,
      Token
    };
  }

  // node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js
  var EditorWorkerHost = class _EditorWorkerHost {
    static {
      this.CHANNEL_NAME = "editorWorkerHost";
    }
    static getChannel(workerServer) {
      return workerServer.getChannel(_EditorWorkerHost.CHANNEL_NAME);
    }
    static setChannel(workerClient, obj) {
      workerClient.setChannel(_EditorWorkerHost.CHANNEL_NAME, obj);
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/map.js
  var _a;
  var _b;
  var ResourceMapEntry = class {
    constructor(uri, value) {
      this.uri = uri;
      this.value = value;
    }
  };
  function isEntries(arg) {
    return Array.isArray(arg);
  }
  var ResourceMap = class _ResourceMap {
    static {
      this.defaultToKey = (resource) => resource.toString();
    }
    constructor(arg, toKey) {
      this[_a] = "ResourceMap";
      if (arg instanceof _ResourceMap) {
        this.map = new Map(arg.map);
        this.toKey = toKey ?? _ResourceMap.defaultToKey;
      } else if (isEntries(arg)) {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = toKey ?? _ResourceMap.defaultToKey;
        for (const [resource, value] of arg) {
          this.set(resource, value);
        }
      } else {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = arg ?? _ResourceMap.defaultToKey;
      }
    }
    set(resource, value) {
      this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
      return this;
    }
    get(resource) {
      return this.map.get(this.toKey(resource))?.value;
    }
    has(resource) {
      return this.map.has(this.toKey(resource));
    }
    get size() {
      return this.map.size;
    }
    clear() {
      this.map.clear();
    }
    delete(resource) {
      return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
      if (typeof thisArg !== "undefined") {
        clb = clb.bind(thisArg);
      }
      for (const [_2, entry] of this.map) {
        clb(entry.value, entry.uri, this);
      }
    }
    *values() {
      for (const entry of this.map.values()) {
        yield entry.value;
      }
    }
    *keys() {
      for (const entry of this.map.values()) {
        yield entry.uri;
      }
    }
    *entries() {
      for (const entry of this.map.values()) {
        yield [entry.uri, entry.value];
      }
    }
    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {
      for (const [, entry] of this.map) {
        yield [entry.uri, entry.value];
      }
    }
  };
  var LinkedMap = class {
    constructor() {
      this[_b] = "LinkedMap";
      this._map = /* @__PURE__ */ new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      return this._head?.value;
    }
    get last() {
      return this._tail?.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = 0) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      if (touch !== 0) {
        this.touch(item, touch);
      }
      return item.value;
    }
    set(key, value, touch = 0) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== 0) {
          this.touch(item, touch);
        }
      } else {
        item = { key, value, next: void 0, previous: void 0 };
        switch (touch) {
          case 0:
            this.addItemLast(item);
            break;
          case 1:
            this.addItemFirst(item);
            break;
          case 2:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        if (this._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        current = current.next;
      }
    }
    keys() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.key, done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    values() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.value, done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    entries() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: [current.key, current.value], done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._head;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.next;
        currentSize--;
      }
      this._head = current;
      this._size = currentSize;
      if (current) {
        current.previous = void 0;
      }
      this._state++;
    }
    trimNew(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._tail;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.previous;
        currentSize--;
      }
      this._tail = current;
      this._size = currentSize;
      if (current) {
        current.next = void 0;
      }
      this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        if (!item.next) {
          throw new Error("Invalid list");
        }
        item.next.previous = void 0;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw new Error("Invalid list");
        }
        item.previous.next = void 0;
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = void 0;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== 1 && touch !== 2) {
        return;
      }
      if (touch === 1) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
        this._state++;
      } else if (touch === 2) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
        this._state++;
      }
    }
    toJSON() {
      const data = [];
      this.forEach((value, key) => {
        data.push([key, value]);
      });
      return data;
    }
    fromJSON(data) {
      this.clear();
      for (const [key, value] of data) {
        this.set(key, value);
      }
    }
  };
  var Cache = class extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get(key, touch = 2) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(
        key,
        0
        /* Touch.None */
      );
    }
    set(key, value) {
      super.set(
        key,
        value,
        2
        /* Touch.AsNew */
      );
      return this;
    }
    checkTrim() {
      if (this.size > this._limit) {
        this.trim(Math.round(this._limit * this._ratio));
      }
    }
  };
  var LRUCache = class extends Cache {
    constructor(limit, ratio = 1) {
      super(limit, ratio);
    }
    trim(newSize) {
      this.trimOld(newSize);
    }
    set(key, value) {
      super.set(key, value);
      this.checkTrim();
      return this;
    }
  };
  var SetMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    add(key, value) {
      let values = this.map.get(key);
      if (!values) {
        values = /* @__PURE__ */ new Set();
        this.map.set(key, values);
      }
      values.add(value);
    }
    delete(key, value) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.delete(value);
      if (values.size === 0) {
        this.map.delete(key);
      }
    }
    forEach(key, fn) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.forEach(fn);
    }
    get(key) {
      const values = this.map.get(key);
      if (!values) {
        return /* @__PURE__ */ new Set();
      }
      return values;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
  var wordClassifierCache = new LRUCache(10);

  // node_modules/monaco-editor/esm/vs/base/common/objects.js
  function getAllPropertyNames(obj) {
    let res = [];
    while (Object.prototype !== obj) {
      res = res.concat(Object.getOwnPropertyNames(obj));
      obj = Object.getPrototypeOf(obj);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane2;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
  var GlyphMarginLane2;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
  var InjectedTextCursorStops2;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));

  // node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text3, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text3.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text3.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text3, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text3.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text3.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text3, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text3, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text3, textLength, matchStartIndex, matchLength);
  }
  var Searcher = class {
    constructor(wordSeparators, searchRegex) {
      this._wordSeparators = wordSeparators;
      this._searchRegex = searchRegex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    reset(lastIndex) {
      this._searchRegex.lastIndex = lastIndex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    next(text3) {
      const textLength = text3.length;
      let m;
      do {
        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
          return null;
        }
        m = this._searchRegex.exec(text3);
        if (!m) {
          return null;
        }
        const matchStartIndex = m.index;
        const matchLength = m[0].length;
        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
          if (matchLength === 0) {
            if (getNextCodePoint(text3, textLength, this._searchRegex.lastIndex) > 65535) {
              this._searchRegex.lastIndex += 2;
            } else {
              this._searchRegex.lastIndex += 1;
            }
            continue;
          }
          return null;
        }
        this._prevMatchStartIndex = matchStartIndex;
        this._prevMatchLength = matchLength;
        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text3, textLength, matchStartIndex, matchLength)) {
          return m;
        }
      } while (m);
      return null;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/assert.js
  function assertNever(value, message = "Unreachable") {
    throw new Error(message);
  }
  function assertFn(condition) {
    if (!condition()) {
      debugger;
      condition();
      onUnexpectedError(new BugIndicatingError("Assertion Failed"));
    }
  }
  function checkAdjacentItems(items, predicate) {
    let i = 0;
    while (i < items.length - 1) {
      const a = items[i];
      const b2 = items[i + 1];
      if (!predicate(a, b2)) {
        return false;
      }
      i++;
    }
    return true;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  var DEFAULT_WORD_REGEXP = createWordRegExp();
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  var _defaultConfig = new LinkedList();
  _defaultConfig.unshift({
    maxLen: 1e3,
    windowSize: 15,
    timeBudget: 150
  });
  function getWordAtText(column, wordDefinition, text3, textOffset, config) {
    wordDefinition = ensureValidWordDefinition(wordDefinition);
    if (!config) {
      config = Iterable.first(_defaultConfig);
    }
    if (text3.length > config.maxLen) {
      let start = column - config.maxLen / 2;
      if (start < 0) {
        start = 0;
      } else {
        textOffset += start;
      }
      text3 = text3.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text3, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1; ; i++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text3, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text3, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text3)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  var UnicodeTextModelHighlighter = class {
    static computeUnicodeHighlights(model, options, range) {
      const startLine = range ? range.startLineNumber : 1;
      const endLine = range ? range.endLineNumber : model.getLineCount();
      const codePointHighlighter = new CodePointHighlighter(options);
      const candidates = codePointHighlighter.getCandidateCodePoints();
      let regex;
      if (candidates === "allNonBasicAscii") {
        regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
      } else {
        regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
      }
      const searcher = new Searcher(null, regex);
      const ranges = [];
      let hasMore = false;
      let m;
      let ambiguousCharacterCount = 0;
      let invisibleCharacterCount = 0;
      let nonBasicAsciiCharacterCount = 0;
      forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
        const lineContent = model.getLineContent(lineNumber);
        const lineLength = lineContent.length;
        searcher.reset(0);
        do {
          m = searcher.next(lineContent);
          if (m) {
            let startIndex = m.index;
            let endIndex = m.index + m[0].length;
            if (startIndex > 0) {
              const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                startIndex--;
              }
            }
            if (endIndex + 1 < lineLength) {
              const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                endIndex++;
              }
            }
            const str = lineContent.substring(startIndex, endIndex);
            let word2 = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
            if (word2 && word2.endColumn <= startIndex + 1) {
              word2 = null;
            }
            const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word2 ? word2.word : null);
            if (highlightReason !== 0) {
              if (highlightReason === 3) {
                ambiguousCharacterCount++;
              } else if (highlightReason === 2) {
                invisibleCharacterCount++;
              } else if (highlightReason === 1) {
                nonBasicAsciiCharacterCount++;
              } else {
                assertNever(highlightReason);
              }
              const MAX_RESULT_LENGTH = 1e3;
              if (ranges.length >= MAX_RESULT_LENGTH) {
                hasMore = true;
                break forLoop;
              }
              ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
            }
          }
        } while (m);
      }
      return {
        ranges,
        hasMore,
        ambiguousCharacterCount,
        invisibleCharacterCount,
        nonBasicAsciiCharacterCount
      };
    }
    static computeUnicodeHighlightReason(char, options) {
      const codePointHighlighter = new CodePointHighlighter(options);
      const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
      switch (reason) {
        case 0:
          return null;
        case 2:
          return {
            kind: 1
            /* UnicodeHighlighterReasonKind.Invisible */
          };
        case 3: {
          const codePoint = char.codePointAt(0);
          const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
          const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
          return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
        }
        case 1:
          return {
            kind: 2
            /* UnicodeHighlighterReasonKind.NonBasicAscii */
          };
      }
    }
  };
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
    return src;
  }
  var CodePointHighlighter = class {
    constructor(options) {
      this.options = options;
      this.allowedCodePoints = new Set(options.allowedCodePoints);
      this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
      if (this.options.nonBasicASCII) {
        return "allNonBasicAscii";
      }
      const set = /* @__PURE__ */ new Set();
      if (this.options.invisibleCharacters) {
        for (const cp of InvisibleCharacters.codePoints) {
          if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
            set.add(cp);
          }
        }
      }
      if (this.options.ambiguousCharacters) {
        for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
          set.add(cp);
        }
      }
      for (const cp of this.allowedCodePoints) {
        set.delete(cp);
      }
      return set;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
      const codePoint = character.codePointAt(0);
      if (this.allowedCodePoints.has(codePoint)) {
        return 0;
      }
      if (this.options.nonBasicASCII) {
        return 1;
      }
      let hasBasicASCIICharacters = false;
      let hasNonConfusableNonBasicAsciiCharacter = false;
      if (wordContext) {
        for (const char of wordContext) {
          const codePoint2 = char.codePointAt(0);
          const isBasicASCII2 = isBasicASCII(char);
          hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
          if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
            hasNonConfusableNonBasicAsciiCharacter = true;
          }
        }
      }
      if (
        /* Don't allow mixing weird looking characters with ASCII */
        !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
        hasNonConfusableNonBasicAsciiCharacter
      ) {
        return 0;
      }
      if (this.options.invisibleCharacters) {
        if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
          return 2;
        }
      }
      if (this.options.ambiguousCharacters) {
        if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
          return 3;
        }
      }
      return 0;
    }
  };
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }

  // node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
  var LinesDiff = class {
    constructor(changes, moves, hitTimeout) {
      this.changes = changes;
      this.moves = moves;
      this.hitTimeout = hitTimeout;
    }
  };
  var MovedText = class {
    constructor(lineRangeMapping, changes) {
      this.lineRangeMapping = lineRangeMapping;
      this.changes = changes;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js
  var OffsetRange = class _OffsetRange {
    static addRange(range, sortedRanges) {
      let i = 0;
      while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
        i++;
      }
      let j2 = i;
      while (j2 < sortedRanges.length && sortedRanges[j2].start <= range.endExclusive) {
        j2++;
      }
      if (i === j2) {
        sortedRanges.splice(i, 0, range);
      } else {
        const start = Math.min(range.start, sortedRanges[i].start);
        const end = Math.max(range.endExclusive, sortedRanges[j2 - 1].endExclusive);
        sortedRanges.splice(i, j2 - i, new _OffsetRange(start, end));
      }
    }
    static tryCreate(start, endExclusive) {
      if (start > endExclusive) {
        return void 0;
      }
      return new _OffsetRange(start, endExclusive);
    }
    static ofLength(length) {
      return new _OffsetRange(0, length);
    }
    static ofStartAndLength(start, length) {
      return new _OffsetRange(start, start + length);
    }
    constructor(start, endExclusive) {
      this.start = start;
      this.endExclusive = endExclusive;
      if (start > endExclusive) {
        throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
      }
    }
    get isEmpty() {
      return this.start === this.endExclusive;
    }
    delta(offset) {
      return new _OffsetRange(this.start + offset, this.endExclusive + offset);
    }
    deltaStart(offset) {
      return new _OffsetRange(this.start + offset, this.endExclusive);
    }
    deltaEnd(offset) {
      return new _OffsetRange(this.start, this.endExclusive + offset);
    }
    get length() {
      return this.endExclusive - this.start;
    }
    toString() {
      return `[${this.start}, ${this.endExclusive})`;
    }
    contains(offset) {
      return this.start <= offset && offset < this.endExclusive;
    }
    /**
     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
     * The joined range is the smallest range that contains both ranges.
     */
    join(other) {
      return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
    }
    /**
     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
     *
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const start = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      if (start <= end) {
        return new _OffsetRange(start, end);
      }
      return void 0;
    }
    intersects(other) {
      const start = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      return start < end;
    }
    isBefore(other) {
      return this.endExclusive <= other.start;
    }
    isAfter(other) {
      return this.start >= other.endExclusive;
    }
    slice(arr) {
      return arr.slice(this.start, this.endExclusive);
    }
    substring(str) {
      return str.substring(this.start, this.endExclusive);
    }
    /**
     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
     * The range must not be empty.
     */
    clip(value) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      return Math.max(this.start, Math.min(this.endExclusive - 1, value));
    }
    /**
     * Returns `r := value + k * length` such that `r` is contained in this range.
     * The range must not be empty.
     *
     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
     */
    clipCyclic(value) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      if (value < this.start) {
        return this.endExclusive - (this.start - value) % this.length;
      }
      if (value >= this.endExclusive) {
        return this.start + (value - this.start) % this.length;
      }
      return value;
    }
    forEach(f) {
      for (let i = this.start; i < this.endExclusive; i++) {
        f(i);
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/arraysFind.js
  function findLastMonotonous(array, predicate) {
    const idx = findLastIdxMonotonous(array, predicate);
    return idx === -1 ? void 0 : array[idx];
  }
  function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j2 = endIdxEx;
    while (i < j2) {
      const k2 = Math.floor((i + j2) / 2);
      if (predicate(array[k2])) {
        i = k2 + 1;
      } else {
        j2 = k2;
      }
    }
    return i - 1;
  }
  function findFirstMonotonous(array, predicate) {
    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
    return idx === array.length ? void 0 : array[idx];
  }
  function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j2 = endIdxEx;
    while (i < j2) {
      const k2 = Math.floor((i + j2) / 2);
      if (predicate(array[k2])) {
        j2 = k2;
      } else {
        i = k2 + 1;
      }
    }
    return i;
  }
  var MonotonousArray = class _MonotonousArray {
    static {
      this.assertInvariants = false;
    }
    constructor(_array) {
      this._array = _array;
      this._findLastMonotonousLastIdx = 0;
    }
    /**
     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
     */
    findLastMonotonous(predicate) {
      if (_MonotonousArray.assertInvariants) {
        if (this._prevFindLastPredicate) {
          for (const item of this._array) {
            if (this._prevFindLastPredicate(item) && !predicate(item)) {
              throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
            }
          }
        }
        this._prevFindLastPredicate = predicate;
      }
      const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
      this._findLastMonotonousLastIdx = idx + 1;
      return idx === -1 ? void 0 : this._array[idx];
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js
  var LineRange = class _LineRange {
    static fromRangeInclusive(range) {
      return new _LineRange(range.startLineNumber, range.endLineNumber + 1);
    }
    /**
     * @param lineRanges An array of sorted line ranges.
     */
    static joinMany(lineRanges) {
      if (lineRanges.length === 0) {
        return [];
      }
      let result = new LineRangeSet(lineRanges[0].slice());
      for (let i = 1; i < lineRanges.length; i++) {
        result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
      }
      return result.ranges;
    }
    static join(lineRanges) {
      if (lineRanges.length === 0) {
        throw new BugIndicatingError("lineRanges cannot be empty");
      }
      let startLineNumber = lineRanges[0].startLineNumber;
      let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;
      for (let i = 1; i < lineRanges.length; i++) {
        startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);
        endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);
      }
      return new _LineRange(startLineNumber, endLineNumberExclusive);
    }
    static ofLength(startLineNumber, length) {
      return new _LineRange(startLineNumber, startLineNumber + length);
    }
    /**
     * @internal
     */
    static deserialize(lineRange) {
      return new _LineRange(lineRange[0], lineRange[1]);
    }
    constructor(startLineNumber, endLineNumberExclusive) {
      if (startLineNumber > endLineNumberExclusive) {
        throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
      }
      this.startLineNumber = startLineNumber;
      this.endLineNumberExclusive = endLineNumberExclusive;
    }
    /**
     * Indicates if this line range contains the given line number.
     */
    contains(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty() {
      return this.startLineNumber === this.endLineNumberExclusive;
    }
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset) {
      return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
    }
    deltaLength(offset) {
      return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
    }
    /**
     * The number of lines this line range spans.
     */
    get length() {
      return this.endLineNumberExclusive - this.startLineNumber;
    }
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other) {
      return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    toString() {
      return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    /**
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
      const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
      if (startLineNumber <= endLineNumberExclusive) {
        return new _LineRange(startLineNumber, endLineNumberExclusive);
      }
      return void 0;
    }
    intersectsStrict(other) {
      return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
    }
    overlapOrTouch(other) {
      return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    equals(b2) {
      return this.startLineNumber === b2.startLineNumber && this.endLineNumberExclusive === b2.endLineNumberExclusive;
    }
    toInclusiveRange() {
      if (this.isEmpty) {
        return null;
      }
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
    }
    /**
     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
    */
    toExclusiveRange() {
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
    }
    mapToLineArray(f) {
      const result = [];
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        result.push(f(lineNumber));
      }
      return result;
    }
    forEach(f) {
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        f(lineNumber);
      }
    }
    /**
     * @internal
     */
    serialize() {
      return [this.startLineNumber, this.endLineNumberExclusive];
    }
    includes(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
     * @internal
     */
    toOffsetRange() {
      return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
    }
  };
  var LineRangeSet = class _LineRangeSet {
    constructor(_normalizedRanges = []) {
      this._normalizedRanges = _normalizedRanges;
    }
    get ranges() {
      return this._normalizedRanges;
    }
    addRange(range) {
      if (range.length === 0) {
        return;
      }
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
      } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
        const joinRange = this._normalizedRanges[joinRangeStartIdx];
        this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
      } else {
        const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
        this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
      }
    }
    contains(lineNumber) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= lineNumber);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
    }
    intersects(range) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber < range.endLineNumberExclusive);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
    }
    getUnion(other) {
      if (this._normalizedRanges.length === 0) {
        return other;
      }
      if (other._normalizedRanges.length === 0) {
        return this;
      }
      const result = [];
      let i1 = 0;
      let i2 = 0;
      let current = null;
      while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
        let next = null;
        if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
          const lineRange1 = this._normalizedRanges[i1];
          const lineRange2 = other._normalizedRanges[i2];
          if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
            next = lineRange1;
            i1++;
          } else {
            next = lineRange2;
            i2++;
          }
        } else if (i1 < this._normalizedRanges.length) {
          next = this._normalizedRanges[i1];
          i1++;
        } else {
          next = other._normalizedRanges[i2];
          i2++;
        }
        if (current === null) {
          current = next;
        } else {
          if (current.endLineNumberExclusive >= next.startLineNumber) {
            current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
          } else {
            result.push(current);
            current = next;
          }
        }
      }
      if (current !== null) {
        result.push(current);
      }
      return new _LineRangeSet(result);
    }
    /**
     * Subtracts all ranges in this set from `range` and returns the result.
     */
    subtractFrom(range) {
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        return new _LineRangeSet([range]);
      }
      const result = [];
      let startLineNumber = range.startLineNumber;
      for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {
        const r = this._normalizedRanges[i];
        if (r.startLineNumber > startLineNumber) {
          result.push(new LineRange(startLineNumber, r.startLineNumber));
        }
        startLineNumber = r.endLineNumberExclusive;
      }
      if (startLineNumber < range.endLineNumberExclusive) {
        result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
      }
      return new _LineRangeSet(result);
    }
    toString() {
      return this._normalizedRanges.map((r) => r.toString()).join(", ");
    }
    getIntersection(other) {
      const result = [];
      let i1 = 0;
      let i2 = 0;
      while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
        const r1 = this._normalizedRanges[i1];
        const r2 = other._normalizedRanges[i2];
        const i = r1.intersect(r2);
        if (i && !i.isEmpty) {
          result.push(i);
        }
        if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {
          i1++;
        } else {
          i2++;
        }
      }
      return new _LineRangeSet(result);
    }
    getWithDelta(value) {
      return new _LineRangeSet(this._normalizedRanges.map((r) => r.delta(value)));
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js
  var TextLength = class _TextLength {
    static {
      this.zero = new _TextLength(0, 0);
    }
    static betweenPositions(position1, position2) {
      if (position1.lineNumber === position2.lineNumber) {
        return new _TextLength(0, position2.column - position1.column);
      } else {
        return new _TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);
      }
    }
    static ofRange(range) {
      return _TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());
    }
    static ofText(text3) {
      let line = 0;
      let column = 0;
      for (const c of text3) {
        if (c === "\n") {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      return new _TextLength(line, column);
    }
    constructor(lineCount, columnCount) {
      this.lineCount = lineCount;
      this.columnCount = columnCount;
    }
    isGreaterThanOrEqualTo(other) {
      if (this.lineCount !== other.lineCount) {
        return this.lineCount > other.lineCount;
      }
      return this.columnCount >= other.columnCount;
    }
    createRange(startPosition) {
      if (this.lineCount === 0) {
        return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);
      } else {
        return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    addToPosition(position) {
      if (this.lineCount === 0) {
        return new Position(position.lineNumber, position.column + this.columnCount);
      } else {
        return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    toString() {
      return `${this.lineCount},${this.columnCount}`;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js
  var SingleTextEdit = class {
    constructor(range, text3) {
      this.range = range;
      this.text = text3;
    }
    toSingleEditOperation() {
      return {
        range: this.range,
        text: this.text
      };
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js
  var LineRangeMapping = class _LineRangeMapping {
    static inverse(mapping, originalLineCount, modifiedLineCount) {
      const result = [];
      let lastOriginalEndLineNumber = 1;
      let lastModifiedEndLineNumber = 1;
      for (const m of mapping) {
        const r2 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));
        if (!r2.modified.isEmpty) {
          result.push(r2);
        }
        lastOriginalEndLineNumber = m.original.endLineNumberExclusive;
        lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;
      }
      const r = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));
      if (!r.modified.isEmpty) {
        result.push(r);
      }
      return result;
    }
    static clip(mapping, originalRange, modifiedRange) {
      const result = [];
      for (const m of mapping) {
        const original = m.original.intersect(originalRange);
        const modified = m.modified.intersect(modifiedRange);
        if (original && !original.isEmpty && modified && !modified.isEmpty) {
          result.push(new _LineRangeMapping(original, modified));
        }
      }
      return result;
    }
    constructor(originalRange, modifiedRange) {
      this.original = originalRange;
      this.modified = modifiedRange;
    }
    toString() {
      return `{${this.original.toString()}->${this.modified.toString()}}`;
    }
    flip() {
      return new _LineRangeMapping(this.modified, this.original);
    }
    join(other) {
      return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
    }
    /**
     * This method assumes that the LineRangeMapping describes a valid diff!
     * I.e. if one range is empty, the other range cannot be the entire document.
     * It avoids various problems when the line range points to non-existing line-numbers.
    */
    toRangeMapping() {
      const origInclusiveRange = this.original.toInclusiveRange();
      const modInclusiveRange = this.modified.toInclusiveRange();
      if (origInclusiveRange && modInclusiveRange) {
        return new RangeMapping(origInclusiveRange, modInclusiveRange);
      } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
        if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {
          throw new BugIndicatingError("not a valid diff");
        }
        return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
      } else {
        return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
      }
    }
    /**
     * This method assumes that the LineRangeMapping describes a valid diff!
     * I.e. if one range is empty, the other range cannot be the entire document.
     * It avoids various problems when the line range points to non-existing line-numbers.
    */
    toRangeMapping2(original, modified) {
      if (isValidLineNumber(this.original.endLineNumberExclusive, original) && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {
        return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
      }
      if (!this.original.isEmpty && !this.modified.isEmpty) {
        return new RangeMapping(Range.fromPositions(new Position(this.original.startLineNumber, 1), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(new Position(this.modified.startLineNumber, 1), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));
      }
      if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {
        return new RangeMapping(Range.fromPositions(normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));
      }
      throw new BugIndicatingError();
    }
  };
  function normalizePosition(position, content) {
    if (position.lineNumber < 1) {
      return new Position(1, 1);
    }
    if (position.lineNumber > content.length) {
      return new Position(content.length, content[content.length - 1].length + 1);
    }
    const line = content[position.lineNumber - 1];
    if (position.column > line.length + 1) {
      return new Position(position.lineNumber, line.length + 1);
    }
    return position;
  }
  function isValidLineNumber(lineNumber, lines) {
    return lineNumber >= 1 && lineNumber <= lines.length;
  }
  var DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {
    static fromRangeMappings(rangeMappings) {
      const originalRange = LineRange.join(rangeMappings.map((r) => LineRange.fromRangeInclusive(r.originalRange)));
      const modifiedRange = LineRange.join(rangeMappings.map((r) => LineRange.fromRangeInclusive(r.modifiedRange)));
      return new _DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);
    }
    constructor(originalRange, modifiedRange, innerChanges) {
      super(originalRange, modifiedRange);
      this.innerChanges = innerChanges;
    }
    flip() {
      return new _DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map((c) => c.flip()));
    }
    withInnerChangesFromLineRanges() {
      return new _DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);
    }
  };
  var RangeMapping = class _RangeMapping {
    static assertSorted(rangeMappings) {
      for (let i = 1; i < rangeMappings.length; i++) {
        const previous = rangeMappings[i - 1];
        const current = rangeMappings[i];
        if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition()) && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {
          throw new BugIndicatingError("Range mappings must be sorted");
        }
      }
    }
    constructor(originalRange, modifiedRange) {
      this.originalRange = originalRange;
      this.modifiedRange = modifiedRange;
    }
    toString() {
      return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    flip() {
      return new _RangeMapping(this.modifiedRange, this.originalRange);
    }
    /**
     * Creates a single text edit that describes the change from the original to the modified text.
    */
    toTextEdit(modified) {
      const newText = modified.getValueOfRange(this.modifiedRange);
      return new SingleTextEdit(this.originalRange, newText);
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js
  var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
  var LegacyLinesDiffComputer = class {
    computeDiff(originalLines, modifiedLines, options) {
      const diffComputer = new DiffComputer(originalLines, modifiedLines, {
        maxComputationTime: options.maxComputationTimeMs,
        shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
        shouldComputeCharChanges: true,
        shouldMakePrettyDiff: true,
        shouldPostProcessCharChanges: true
      });
      const result = diffComputer.computeDiff();
      const changes = [];
      let lastChange = null;
      for (const c of result.changes) {
        let originalRange;
        if (c.originalEndLineNumber === 0) {
          originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
        } else {
          originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
        }
        let modifiedRange;
        if (c.modifiedEndLineNumber === 0) {
          modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
        } else {
          modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
        }
        let change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map((c2) => new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));
        if (lastChange) {
          if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
            change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
            changes.pop();
          }
        }
        changes.push(change);
        lastChange = change;
      }
      assertFn(() => {
        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
        m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
      });
      return new LinesDiff(changes, [], result.quitEarly);
    }
  };
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  var LineSequence = class {
    constructor(lines) {
      const startColumns = [];
      const endColumns = [];
      for (let i = 0, length = lines.length; i < length; i++) {
        startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
        endColumns[i] = getLastNonBlankColumn(lines[i], 1);
      }
      this.lines = lines;
      this._startColumns = startColumns;
      this._endColumns = endColumns;
    }
    getElements() {
      const elements = [];
      for (let i = 0, len = this.lines.length; i < len; i++) {
        elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
      }
      return elements;
    }
    getStrictElement(index) {
      return this.lines[index];
    }
    getStartLineNumber(i) {
      return i + 1;
    }
    getEndLineNumber(i) {
      return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
      const charCodes = [];
      const lineNumbers = [];
      const columns = [];
      let len = 0;
      for (let index = startIndex; index <= endIndex; index++) {
        const lineContent = this.lines[index];
        const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
        const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
        for (let col = startColumn; col < endColumn; col++) {
          charCodes[len] = lineContent.charCodeAt(col - 1);
          lineNumbers[len] = index + 1;
          columns[len] = col;
          len++;
        }
        if (!shouldIgnoreTrimWhitespace && index < endIndex) {
          charCodes[len] = 10;
          lineNumbers[len] = index + 1;
          columns[len] = lineContent.length + 1;
          len++;
        }
      }
      return new CharSequence(charCodes, lineNumbers, columns);
    }
  };
  var CharSequence = class {
    constructor(charCodes, lineNumbers, columns) {
      this._charCodes = charCodes;
      this._lineNumbers = lineNumbers;
      this._columns = columns;
    }
    toString() {
      return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
    }
    _assertIndex(index, arr) {
      if (index < 0 || index >= arr.length) {
        throw new Error(`Illegal index`);
      }
    }
    getElements() {
      return this._charCodes;
    }
    getStartLineNumber(i) {
      if (i > 0 && i === this._lineNumbers.length) {
        return this.getEndLineNumber(i - 1);
      }
      this._assertIndex(i, this._lineNumbers);
      return this._lineNumbers[i];
    }
    getEndLineNumber(i) {
      if (i === -1) {
        return this.getStartLineNumber(i + 1);
      }
      this._assertIndex(i, this._lineNumbers);
      if (this._charCodes[i] === 10) {
        return this._lineNumbers[i] + 1;
      }
      return this._lineNumbers[i];
    }
    getStartColumn(i) {
      if (i > 0 && i === this._columns.length) {
        return this.getEndColumn(i - 1);
      }
      this._assertIndex(i, this._columns);
      return this._columns[i];
    }
    getEndColumn(i) {
      if (i === -1) {
        return this.getStartColumn(i + 1);
      }
      this._assertIndex(i, this._columns);
      if (this._charCodes[i] === 10) {
        return 1;
      }
      return this._columns[i] + 1;
    }
  };
  var CharChange = class _CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalStartColumn = originalStartColumn;
      this.originalEndLineNumber = originalEndLineNumber;
      this.originalEndColumn = originalEndColumn;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedStartColumn = modifiedStartColumn;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
      const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
      const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
      const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
      const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
      const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
  };
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
      const currChange = rawChanges[i];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  var LineChange = class _LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalEndLineNumber = originalEndLineNumber;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
      let originalStartLineNumber;
      let originalEndLineNumber;
      let modifiedStartLineNumber;
      let modifiedEndLineNumber;
      let charChanges = void 0;
      if (diffChange.originalLength === 0) {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
        originalEndLineNumber = 0;
      } else {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
        originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      }
      if (diffChange.modifiedLength === 0) {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
        modifiedEndLineNumber = 0;
      } else {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
        modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      }
      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
        const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
        if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
          let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
          if (shouldPostProcessCharChanges) {
            rawChanges = postProcessCharChanges(rawChanges);
          }
          charChanges = [];
          for (let i = 0, length = rawChanges.length; i < length; i++) {
            charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
          }
        }
      }
      return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
  };
  var DiffComputer = class {
    constructor(originalLines, modifiedLines, opts) {
      this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
      this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
      this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
      this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
      this.originalLines = originalLines;
      this.modifiedLines = modifiedLines;
      this.original = new LineSequence(originalLines);
      this.modified = new LineSequence(modifiedLines);
      this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
      this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
    }
    computeDiff() {
      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
          return {
            quitEarly: false,
            changes: []
          };
        }
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: 1,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: this.modified.lines.length,
            charChanges: void 0
          }]
        };
      }
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: this.original.lines.length,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: 1,
            charChanges: void 0
          }]
        };
      }
      const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
      const rawChanges = diffResult.changes;
      const quitEarly = diffResult.quitEarly;
      if (this.shouldIgnoreTrimWhitespace) {
        const lineChanges = [];
        for (let i = 0, length = rawChanges.length; i < length; i++) {
          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        }
        return {
          quitEarly,
          changes: lineChanges
        };
      }
      const result = [];
      let originalLineIndex = 0;
      let modifiedLineIndex = 0;
      for (let i = -1, len = rawChanges.length; i < len; i++) {
        const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
        const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
        const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
        while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
          const originalLine = this.originalLines[originalLineIndex];
          const modifiedLine = this.modifiedLines[modifiedLineIndex];
          if (originalLine !== modifiedLine) {
            {
              let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
              let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
              while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalStartColumn--;
                modifiedStartColumn--;
              }
              if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
              }
            }
            {
              let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
              let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
              const originalMaxColumn = originalLine.length + 1;
              const modifiedMaxColumn = modifiedLine.length + 1;
              while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalEndColumn++;
                modifiedEndColumn++;
              }
              if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
              }
            }
          }
          originalLineIndex++;
          modifiedLineIndex++;
        }
        if (nextChange) {
          result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
          originalLineIndex += nextChange.originalLength;
          modifiedLineIndex += nextChange.modifiedLength;
        }
      }
      return {
        quitEarly,
        changes: result
      };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
        return;
      }
      let charChanges = void 0;
      if (this.shouldComputeCharChanges) {
        charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
      }
      result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      const len = result.length;
      if (len === 0) {
        return false;
      }
      const prevChange = result[len - 1];
      if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
        return false;
      }
      if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
        prevChange.originalEndLineNumber = originalLineNumber;
        prevChange.modifiedEndLineNumber = modifiedLineNumber;
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      return false;
    }
  };
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r = firstNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r = lastNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }

  // node_modules/monaco-editor/esm/vs/base/common/arrays.js
  function equals2(one, other, itemEquals = (a, b2) => a === b2) {
    if (one === other) {
      return true;
    }
    if (!one || !other) {
      return false;
    }
    if (one.length !== other.length) {
      return false;
    }
    for (let i = 0, len = one.length; i < len; i++) {
      if (!itemEquals(one[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function* groupAdjacentBy(items, shouldBeGrouped) {
    let currentGroup;
    let last;
    for (const item of items) {
      if (last !== void 0 && shouldBeGrouped(last, item)) {
        currentGroup.push(item);
      } else {
        if (currentGroup) {
          yield currentGroup;
        }
        currentGroup = [item];
      }
      last = item;
    }
    if (currentGroup) {
      yield currentGroup;
    }
  }
  function forEachAdjacent(arr, f) {
    for (let i = 0; i <= arr.length; i++) {
      f(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);
    }
  }
  function forEachWithNeighbors(arr, f) {
    for (let i = 0; i < arr.length; i++) {
      f(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);
    }
  }
  function pushMany(arr, items) {
    for (const item of items) {
      arr.push(item);
    }
  }
  var CompareResult;
  (function(CompareResult2) {
    function isLessThan(result) {
      return result < 0;
    }
    CompareResult2.isLessThan = isLessThan;
    function isLessThanOrEqual(result) {
      return result <= 0;
    }
    CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
    function isGreaterThan(result) {
      return result > 0;
    }
    CompareResult2.isGreaterThan = isGreaterThan;
    function isNeitherLessOrGreaterThan(result) {
      return result === 0;
    }
    CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
    CompareResult2.greaterThan = 1;
    CompareResult2.lessThan = -1;
    CompareResult2.neitherLessOrGreaterThan = 0;
  })(CompareResult || (CompareResult = {}));
  function compareBy(selector, comparator) {
    return (a, b2) => comparator(selector(a), selector(b2));
  }
  var numberComparator = (a, b2) => a - b2;
  function reverseOrder(comparator) {
    return (a, b2) => -comparator(a, b2);
  }
  var CallbackIterable = class _CallbackIterable {
    static {
      this.empty = new _CallbackIterable((_callback) => {
      });
    }
    constructor(iterate) {
      this.iterate = iterate;
    }
    toArray() {
      const result = [];
      this.iterate((item) => {
        result.push(item);
        return true;
      });
      return result;
    }
    filter(predicate) {
      return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
    }
    map(mapFn) {
      return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
    }
    findLast(predicate) {
      let result;
      this.iterate((item) => {
        if (predicate(item)) {
          result = item;
        }
        return true;
      });
      return result;
    }
    findLastMaxBy(comparator) {
      let result;
      let first = true;
      this.iterate((item) => {
        if (first || CompareResult.isGreaterThan(comparator(item, result))) {
          first = false;
          result = item;
        }
        return true;
      });
      return result;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
  var DiffAlgorithmResult = class _DiffAlgorithmResult {
    static trivial(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);
    }
    static trivialTimedOut(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);
    }
    constructor(diffs, hitTimeout) {
      this.diffs = diffs;
      this.hitTimeout = hitTimeout;
    }
  };
  var SequenceDiff = class _SequenceDiff {
    static invert(sequenceDiffs, doc1Length) {
      const result = [];
      forEachAdjacent(sequenceDiffs, (a, b2) => {
        result.push(_SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b2 ? b2.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));
      });
      return result;
    }
    static fromOffsetPairs(start, endExclusive) {
      return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));
    }
    static assertSorted(sequenceDiffs) {
      let last = void 0;
      for (const cur of sequenceDiffs) {
        if (last) {
          if (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {
            throw new BugIndicatingError("Sequence diffs must be sorted");
          }
        }
        last = cur;
      }
    }
    constructor(seq1Range, seq2Range) {
      this.seq1Range = seq1Range;
      this.seq2Range = seq2Range;
    }
    swap() {
      return new _SequenceDiff(this.seq2Range, this.seq1Range);
    }
    toString() {
      return `${this.seq1Range} <-> ${this.seq2Range}`;
    }
    join(other) {
      return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
    }
    delta(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
    }
    deltaStart(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));
    }
    deltaEnd(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
    }
    intersect(other) {
      const i1 = this.seq1Range.intersect(other.seq1Range);
      const i2 = this.seq2Range.intersect(other.seq2Range);
      if (!i1 || !i2) {
        return void 0;
      }
      return new _SequenceDiff(i1, i2);
    }
    getStarts() {
      return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
    }
    getEndExclusives() {
      return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
    }
  };
  var OffsetPair = class _OffsetPair {
    static {
      this.zero = new _OffsetPair(0, 0);
    }
    static {
      this.max = new _OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    }
    constructor(offset1, offset2) {
      this.offset1 = offset1;
      this.offset2 = offset2;
    }
    toString() {
      return `${this.offset1} <-> ${this.offset2}`;
    }
    delta(offset) {
      if (offset === 0) {
        return this;
      }
      return new _OffsetPair(this.offset1 + offset, this.offset2 + offset);
    }
    equals(other) {
      return this.offset1 === other.offset1 && this.offset2 === other.offset2;
    }
  };
  var InfiniteTimeout = class _InfiniteTimeout {
    static {
      this.instance = new _InfiniteTimeout();
    }
    isValid() {
      return true;
    }
  };
  var DateTimeout = class {
    constructor(timeout) {
      this.timeout = timeout;
      this.startTime = Date.now();
      this.valid = true;
      if (timeout <= 0) {
        throw new BugIndicatingError("timeout must be positive");
      }
    }
    // Recommendation: Set a log-point `{this.disable()}` in the body
    isValid() {
      const valid = Date.now() - this.startTime < this.timeout;
      if (!valid && this.valid) {
        this.valid = false;
        debugger;
      }
      return this.valid;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
  var Array2D = class {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.array = [];
      this.array = new Array(width * height);
    }
    get(x2, y) {
      return this.array[x2 + y * this.width];
    }
    set(x2, y, value) {
      this.array[x2 + y * this.width] = value;
    }
  };
  function isSpace(charCode) {
    return charCode === 32 || charCode === 9;
  }
  var LineRangeFragment = class _LineRangeFragment {
    static {
      this.chrKeys = /* @__PURE__ */ new Map();
    }
    static getKey(chr) {
      let key = this.chrKeys.get(chr);
      if (key === void 0) {
        key = this.chrKeys.size;
        this.chrKeys.set(chr, key);
      }
      return key;
    }
    constructor(range, lines, source) {
      this.range = range;
      this.lines = lines;
      this.source = source;
      this.histogram = [];
      let counter = 0;
      for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {
        const line = lines[i];
        for (let j2 = 0; j2 < line.length; j2++) {
          counter++;
          const chr = line[j2];
          const key2 = _LineRangeFragment.getKey(chr);
          this.histogram[key2] = (this.histogram[key2] || 0) + 1;
        }
        counter++;
        const key = _LineRangeFragment.getKey("\n");
        this.histogram[key] = (this.histogram[key] || 0) + 1;
      }
      this.totalCount = counter;
    }
    computeSimilarity(other) {
      let sumDifferences = 0;
      const maxLength = Math.max(this.histogram.length, other.histogram.length);
      for (let i = 0; i < maxLength; i++) {
        sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));
      }
      return 1 - sumDifferences / (this.totalCount + other.totalCount);
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
  var DynamicProgrammingDiffing = class {
    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {
      if (sequence1.length === 0 || sequence2.length === 0) {
        return DiffAlgorithmResult.trivial(sequence1, sequence2);
      }
      const lcsLengths = new Array2D(sequence1.length, sequence2.length);
      const directions = new Array2D(sequence1.length, sequence2.length);
      const lengths = new Array2D(sequence1.length, sequence2.length);
      for (let s12 = 0; s12 < sequence1.length; s12++) {
        for (let s22 = 0; s22 < sequence2.length; s22++) {
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
          }
          const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
          const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
          let extendedSeqScore;
          if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
            if (s12 === 0 || s22 === 0) {
              extendedSeqScore = 0;
            } else {
              extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
            }
            if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
              extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
            }
            extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
          } else {
            extendedSeqScore = -1;
          }
          const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
          if (newValue === extendedSeqScore) {
            const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
            lengths.set(s12, s22, prevLen + 1);
            directions.set(s12, s22, 3);
          } else if (newValue === horizontalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 1);
          } else if (newValue === verticalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 2);
          }
          lcsLengths.set(s12, s22, newValue);
        }
      }
      const result = [];
      let lastAligningPosS1 = sequence1.length;
      let lastAligningPosS2 = sequence2.length;
      function reportDecreasingAligningPositions(s12, s22) {
        if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
        }
        lastAligningPosS1 = s12;
        lastAligningPosS2 = s22;
      }
      let s1 = sequence1.length - 1;
      let s2 = sequence2.length - 1;
      while (s1 >= 0 && s2 >= 0) {
        if (directions.get(s1, s2) === 3) {
          reportDecreasingAligningPositions(s1, s2);
          s1--;
          s2--;
        } else {
          if (directions.get(s1, s2) === 1) {
            s1--;
          } else {
            s2--;
          }
        }
      }
      reportDecreasingAligningPositions(-1, -1);
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js
  var MyersDiffAlgorithm = class {
    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {
      if (seq1.length === 0 || seq2.length === 0) {
        return DiffAlgorithmResult.trivial(seq1, seq2);
      }
      const seqX = seq1;
      const seqY = seq2;
      function getXAfterSnake(x2, y) {
        while (x2 < seqX.length && y < seqY.length && seqX.getElement(x2) === seqY.getElement(y)) {
          x2++;
          y++;
        }
        return x2;
      }
      let d = 0;
      const V2 = new FastInt32Array();
      V2.set(0, getXAfterSnake(0, 0));
      const paths = new FastArrayNegativeIndices();
      paths.set(0, V2.get(0) === 0 ? null : new SnakePath(null, 0, 0, V2.get(0)));
      let k2 = 0;
      loop: while (true) {
        d++;
        if (!timeout.isValid()) {
          return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
        }
        const lowerBound = -Math.min(d, seqY.length + d % 2);
        const upperBound = Math.min(d, seqX.length + d % 2);
        for (k2 = lowerBound; k2 <= upperBound; k2 += 2) {
          let step = 0;
          const maxXofDLineTop = k2 === upperBound ? -1 : V2.get(k2 + 1);
          const maxXofDLineLeft = k2 === lowerBound ? -1 : V2.get(k2 - 1) + 1;
          step++;
          const x2 = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
          const y = x2 - k2;
          step++;
          if (x2 > seqX.length || y > seqY.length) {
            continue;
          }
          const newMaxX = getXAfterSnake(x2, y);
          V2.set(k2, newMaxX);
          const lastPath = x2 === maxXofDLineTop ? paths.get(k2 + 1) : paths.get(k2 - 1);
          paths.set(k2, newMaxX !== x2 ? new SnakePath(lastPath, x2, y, newMaxX - x2) : lastPath);
          if (V2.get(k2) === seqX.length && V2.get(k2) - k2 === seqY.length) {
            break loop;
          }
        }
      }
      let path = paths.get(k2);
      const result = [];
      let lastAligningPosS1 = seqX.length;
      let lastAligningPosS2 = seqY.length;
      while (true) {
        const endX = path ? path.x + path.length : 0;
        const endY = path ? path.y + path.length : 0;
        if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
        }
        if (!path) {
          break;
        }
        lastAligningPosS1 = path.x;
        lastAligningPosS2 = path.y;
        path = path.prev;
      }
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };
  var SnakePath = class {
    constructor(prev, x2, y, length) {
      this.prev = prev;
      this.x = x2;
      this.y = y;
      this.length = length;
    }
  };
  var FastInt32Array = class {
    constructor() {
      this.positiveArr = new Int32Array(10);
      this.negativeArr = new Int32Array(10);
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value) {
      if (idx < 0) {
        idx = -idx - 1;
        if (idx >= this.negativeArr.length) {
          const arr = this.negativeArr;
          this.negativeArr = new Int32Array(arr.length * 2);
          this.negativeArr.set(arr);
        }
        this.negativeArr[idx] = value;
      } else {
        if (idx >= this.positiveArr.length) {
          const arr = this.positiveArr;
          this.positiveArr = new Int32Array(arr.length * 2);
          this.positiveArr.set(arr);
        }
        this.positiveArr[idx] = value;
      }
    }
  };
  var FastArrayNegativeIndices = class {
    constructor() {
      this.positiveArr = [];
      this.negativeArr = [];
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value) {
      if (idx < 0) {
        idx = -idx - 1;
        this.negativeArr[idx] = value;
      } else {
        this.positiveArr[idx] = value;
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
  var LinesSliceCharSequence = class {
    constructor(lines, range, considerWhitespaceChanges) {
      this.lines = lines;
      this.range = range;
      this.considerWhitespaceChanges = considerWhitespaceChanges;
      this.elements = [];
      this.firstElementOffsetByLineIdx = [];
      this.lineStartOffsets = [];
      this.trimmedWsLengthsByLineIdx = [];
      this.firstElementOffsetByLineIdx.push(0);
      for (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {
        let line = lines[lineNumber - 1];
        let lineStartOffset = 0;
        if (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {
          lineStartOffset = this.range.startColumn - 1;
          line = line.substring(lineStartOffset);
        }
        this.lineStartOffsets.push(lineStartOffset);
        let trimmedWsLength = 0;
        if (!considerWhitespaceChanges) {
          const trimmedStartLine = line.trimStart();
          trimmedWsLength = line.length - trimmedStartLine.length;
          line = trimmedStartLine.trimEnd();
        }
        this.trimmedWsLengthsByLineIdx.push(trimmedWsLength);
        const lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;
        for (let i = 0; i < lineLength; i++) {
          this.elements.push(line.charCodeAt(i));
        }
        if (lineNumber < this.range.endLineNumber) {
          this.elements.push("\n".charCodeAt(0));
          this.firstElementOffsetByLineIdx.push(this.elements.length);
        }
      }
    }
    toString() {
      return `Slice: "${this.text}"`;
    }
    get text() {
      return this.getText(new OffsetRange(0, this.length));
    }
    getText(range) {
      return this.elements.slice(range.start, range.endExclusive).map((e) => String.fromCharCode(e)).join("");
    }
    getElement(offset) {
      return this.elements[offset];
    }
    get length() {
      return this.elements.length;
    }
    getBoundaryScore(length) {
      const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
      const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
      if (prevCategory === 7 && nextCategory === 8) {
        return 0;
      }
      if (prevCategory === 8) {
        return 150;
      }
      let score2 = 0;
      if (prevCategory !== nextCategory) {
        score2 += 10;
        if (prevCategory === 0 && nextCategory === 1) {
          score2 += 1;
        }
      }
      score2 += getCategoryBoundaryScore(prevCategory);
      score2 += getCategoryBoundaryScore(nextCategory);
      return score2;
    }
    translateOffset(offset, preference = "right") {
      const i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);
      const lineOffset = offset - this.firstElementOffsetByLineIdx[i];
      return new Position(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + lineOffset + (lineOffset === 0 && preference === "left" ? 0 : this.trimmedWsLengthsByLineIdx[i]));
    }
    translateRange(range) {
      const pos1 = this.translateOffset(range.start, "right");
      const pos2 = this.translateOffset(range.endExclusive, "left");
      if (pos2.isBefore(pos1)) {
        return Range.fromPositions(pos2, pos2);
      }
      return Range.fromPositions(pos1, pos2);
    }
    /**
     * Finds the word that contains the character at the given offset
     */
    findWordContaining(offset) {
      if (offset < 0 || offset >= this.elements.length) {
        return void 0;
      }
      if (!isWordChar(this.elements[offset])) {
        return void 0;
      }
      let start = offset;
      while (start > 0 && isWordChar(this.elements[start - 1])) {
        start--;
      }
      let end = offset;
      while (end < this.elements.length && isWordChar(this.elements[end])) {
        end++;
      }
      return new OffsetRange(start, end);
    }
    countLinesIn(range) {
      return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
    }
    isStronglyEqual(offset1, offset2) {
      return this.elements[offset1] === this.elements[offset2];
    }
    extendToFullLines(range) {
      const start = findLastMonotonous(this.firstElementOffsetByLineIdx, (x2) => x2 <= range.start) ?? 0;
      const end = findFirstMonotonous(this.firstElementOffsetByLineIdx, (x2) => range.endExclusive <= x2) ?? this.elements.length;
      return new OffsetRange(start, end);
    }
  };
  function isWordChar(charCode) {
    return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
  }
  var score = {
    [
      0
      /* CharBoundaryCategory.WordLower */
    ]: 0,
    [
      1
      /* CharBoundaryCategory.WordUpper */
    ]: 0,
    [
      2
      /* CharBoundaryCategory.WordNumber */
    ]: 0,
    [
      3
      /* CharBoundaryCategory.End */
    ]: 10,
    [
      4
      /* CharBoundaryCategory.Other */
    ]: 2,
    [
      5
      /* CharBoundaryCategory.Separator */
    ]: 30,
    [
      6
      /* CharBoundaryCategory.Space */
    ]: 3,
    [
      7
      /* CharBoundaryCategory.LineBreakCR */
    ]: 10,
    [
      8
      /* CharBoundaryCategory.LineBreakLF */
    ]: 10
  };
  function getCategoryBoundaryScore(category) {
    return score[category];
  }
  function getCategory(charCode) {
    if (charCode === 10) {
      return 8;
    } else if (charCode === 13) {
      return 7;
    } else if (isSpace(charCode)) {
      return 6;
    } else if (charCode >= 97 && charCode <= 122) {
      return 0;
    } else if (charCode >= 65 && charCode <= 90) {
      return 1;
    } else if (charCode >= 48 && charCode <= 57) {
      return 2;
    } else if (charCode === -1) {
      return 3;
    } else if (charCode === 44 || charCode === 59) {
      return 5;
    } else {
      return 4;
    }
  }

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
  function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {
    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);
    if (!timeout.isValid()) {
      return [];
    }
    const filteredChanges = changes.filter((c) => !excludedChanges.has(c));
    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);
    pushMany(moves, unchangedMoves);
    moves = joinCloseConsecutiveMoves(moves);
    moves = moves.filter((current) => {
      const lines = current.original.toOffsetRange().slice(originalLines).map((l) => l.trim());
      const originalText = lines.join("\n");
      return originalText.length >= 15 && countWhere(lines, (l) => l.length >= 2) >= 2;
    });
    moves = removeMovesInSameDiff(changes, moves);
    return moves;
  }
  function countWhere(arr, predicate) {
    let count = 0;
    for (const t2 of arr) {
      if (predicate(t2)) {
        count++;
      }
    }
    return count;
  }
  function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {
    const moves = [];
    const deletions = changes.filter((c) => c.modified.isEmpty && c.original.length >= 3).map((d) => new LineRangeFragment(d.original, originalLines, d));
    const insertions = new Set(changes.filter((c) => c.original.isEmpty && c.modified.length >= 3).map((d) => new LineRangeFragment(d.modified, modifiedLines, d)));
    const excludedChanges = /* @__PURE__ */ new Set();
    for (const deletion of deletions) {
      let highestSimilarity = -1;
      let best;
      for (const insertion of insertions) {
        const similarity = deletion.computeSimilarity(insertion);
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          best = insertion;
        }
      }
      if (highestSimilarity > 0.9 && best) {
        insertions.delete(best);
        moves.push(new LineRangeMapping(deletion.range, best.range));
        excludedChanges.add(deletion.source);
        excludedChanges.add(best.source);
      }
      if (!timeout.isValid()) {
        return { moves, excludedChanges };
      }
    }
    return { moves, excludedChanges };
  }
  function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {
    const moves = [];
    const original3LineHashes = new SetMap();
    for (const change of changes) {
      for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
        const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;
        original3LineHashes.add(key, { range: new LineRange(i, i + 3) });
      }
    }
    const possibleMappings = [];
    changes.sort(compareBy((c) => c.modified.startLineNumber, numberComparator));
    for (const change of changes) {
      let lastMappings = [];
      for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {
        const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;
        const currentModifiedRange = new LineRange(i, i + 3);
        const nextMappings = [];
        original3LineHashes.forEach(key, ({ range }) => {
          for (const lastMapping of lastMappings) {
            if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
              lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
              lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
              nextMappings.push(lastMapping);
              return;
            }
          }
          const mapping = {
            modifiedLineRange: currentModifiedRange,
            originalLineRange: range
          };
          possibleMappings.push(mapping);
          nextMappings.push(mapping);
        });
        lastMappings = nextMappings;
      }
      if (!timeout.isValid()) {
        return [];
      }
    }
    possibleMappings.sort(reverseOrder(compareBy((m) => m.modifiedLineRange.length, numberComparator)));
    const modifiedSet = new LineRangeSet();
    const originalSet = new LineRangeSet();
    for (const mapping of possibleMappings) {
      const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
      const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
      const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
      const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
      for (const s of modifiedIntersectedSections.ranges) {
        if (s.length < 3) {
          continue;
        }
        const modifiedLineRange = s;
        const originalLineRange = s.delta(-diffOrigToMod);
        moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));
        modifiedSet.addRange(modifiedLineRange);
        originalSet.addRange(originalLineRange);
      }
    }
    moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
    const monotonousChanges = new MonotonousArray(changes);
    for (let i = 0; i < moves.length; i++) {
      const move = moves[i];
      const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber <= move.original.startLineNumber);
      const firstTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber <= move.modified.startLineNumber);
      const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
      const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber < move.original.endLineNumberExclusive);
      const lastTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber < move.modified.endLineNumberExclusive);
      const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
      let extendToTop;
      for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
        const origLine = move.original.startLineNumber - extendToTop - 1;
        const modLine = move.modified.startLineNumber - extendToTop - 1;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToTop > 0) {
        originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
        modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
      }
      let extendToBottom;
      for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
        const origLine = move.original.endLineNumberExclusive + extendToBottom;
        const modLine = move.modified.endLineNumberExclusive + extendToBottom;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToBottom > 0) {
        originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
        modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
      }
      if (extendToTop > 0 || extendToBottom > 0) {
        moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
      }
    }
    return moves;
  }
  function areLinesSimilar(line1, line2, timeout) {
    if (line1.trim() === line2.trim()) {
      return true;
    }
    if (line1.length > 300 && line2.length > 300) {
      return false;
    }
    const myersDiffingAlgorithm = new MyersDiffAlgorithm();
    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false), new LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false), timeout);
    let commonNonSpaceCharCount = 0;
    const inverted = SequenceDiff.invert(result.diffs, line1.length);
    for (const seq of inverted) {
      seq.seq1Range.forEach((idx) => {
        if (!isSpace(line1.charCodeAt(idx))) {
          commonNonSpaceCharCount++;
        }
      });
    }
    function countNonWsChars(str) {
      let count = 0;
      for (let i = 0; i < line1.length; i++) {
        if (!isSpace(str.charCodeAt(i))) {
          count++;
        }
      }
      return count;
    }
    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
    return r;
  }
  function joinCloseConsecutiveMoves(moves) {
    if (moves.length === 0) {
      return moves;
    }
    moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
    const result = [moves[0]];
    for (let i = 1; i < moves.length; i++) {
      const last = result[result.length - 1];
      const current = moves[i];
      const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
      const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
      const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
      if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
        result[result.length - 1] = last.join(current);
        continue;
      }
      result.push(current);
    }
    return result;
  }
  function removeMovesInSameDiff(changes, moves) {
    const changesMonotonous = new MonotonousArray(changes);
    moves = moves.filter((m) => {
      const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) => c.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));
      const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) => c.modified.startLineNumber < m.modified.endLineNumberExclusive);
      const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
      return differentDiffs;
    });
    return moves;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
  function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    let result = sequenceDiffs;
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = shiftSequenceDiffs(sequence1, sequence2, result);
    return result;
  }
  function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
    if (sequenceDiffs.length === 0) {
      return sequenceDiffs;
    }
    const result = [];
    result.push(sequenceDiffs[0]);
    for (let i = 1; i < sequenceDiffs.length; i++) {
      const prevResult = result[result.length - 1];
      let cur = sequenceDiffs[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
        let d;
        for (d = 1; d <= length; d++) {
          if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
            break;
          }
        }
        d--;
        if (d === length) {
          result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
          continue;
        }
        cur = cur.delta(-d);
      }
      result.push(cur);
    }
    const result2 = [];
    for (let i = 0; i < result.length - 1; i++) {
      const nextResult = result[i + 1];
      let cur = result[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
        let d;
        for (d = 0; d < length; d++) {
          if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {
            break;
          }
        }
        if (d === length) {
          result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
          continue;
        }
        if (d > 0) {
          cur = cur.delta(d);
        }
      }
      result2.push(cur);
    }
    if (result.length > 0) {
      result2.push(result[result.length - 1]);
    }
    return result2;
  }
  function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
      return sequenceDiffs;
    }
    for (let i = 0; i < sequenceDiffs.length; i++) {
      const prevDiff = i > 0 ? sequenceDiffs[i - 1] : void 0;
      const diff = sequenceDiffs[i];
      const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;
      const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);
      const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);
      if (diff.seq1Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
      } else if (diff.seq2Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
      }
    }
    return sequenceDiffs;
  }
  function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
    const maxShiftLimit = 100;
    let deltaBefore = 1;
    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
      deltaBefore++;
    }
    deltaBefore--;
    let deltaAfter = 0;
    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
      deltaAfter++;
    }
    if (deltaBefore === 0 && deltaAfter === 0) {
      return diff;
    }
    let bestDelta = 0;
    let bestScore = -1;
    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
      const seq2OffsetStart = diff.seq2Range.start + delta;
      const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
      const seq1Offset = diff.seq1Range.start + delta;
      const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
      if (score2 > bestScore) {
        bestScore = score2;
        bestDelta = delta;
      }
    }
    return diff.delta(bestDelta);
  }
  function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    for (const s of sequenceDiffs) {
      const last = result[result.length - 1];
      if (!last) {
        result.push(s);
        continue;
      }
      if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
        result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
      } else {
        result.push(s);
      }
    }
    return result;
  }
  function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);
    const additional = [];
    let lastPoint = new OffsetPair(0, 0);
    function scanWord(pair, equalMapping) {
      if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {
        return;
      }
      const w1 = sequence1.findWordContaining(pair.offset1);
      const w2 = sequence2.findWordContaining(pair.offset2);
      if (!w1 || !w2) {
        return;
      }
      let w3 = new SequenceDiff(w1, w2);
      const equalPart = w3.intersect(equalMapping);
      let equalChars1 = equalPart.seq1Range.length;
      let equalChars2 = equalPart.seq2Range.length;
      while (equalMappings.length > 0) {
        const next = equalMappings[0];
        const intersects = next.seq1Range.intersects(w3.seq1Range) || next.seq2Range.intersects(w3.seq2Range);
        if (!intersects) {
          break;
        }
        const v1 = sequence1.findWordContaining(next.seq1Range.start);
        const v2 = sequence2.findWordContaining(next.seq2Range.start);
        const v3 = new SequenceDiff(v1, v2);
        const equalPart2 = v3.intersect(next);
        equalChars1 += equalPart2.seq1Range.length;
        equalChars2 += equalPart2.seq2Range.length;
        w3 = w3.join(v3);
        if (w3.seq1Range.endExclusive >= next.seq1Range.endExclusive) {
          equalMappings.shift();
        } else {
          break;
        }
      }
      if (equalChars1 + equalChars2 < (w3.seq1Range.length + w3.seq2Range.length) * 2 / 3) {
        additional.push(w3);
      }
      lastPoint = w3.getEndExclusives();
    }
    while (equalMappings.length > 0) {
      const next = equalMappings.shift();
      if (next.seq1Range.isEmpty) {
        continue;
      }
      scanWord(next.getStarts(), next);
      scanWord(next.getEndExclusives().delta(-1), next);
    }
    const merged = mergeSequenceDiffs(sequenceDiffs, additional);
    return merged;
  }
  function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
    const result = [];
    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
      const sd1 = sequenceDiffs1[0];
      const sd2 = sequenceDiffs2[0];
      let next;
      if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
        next = sequenceDiffs1.shift();
      } else {
        next = sequenceDiffs2.shift();
      }
      if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
        result[result.length - 1] = result[result.length - 1].join(next);
      } else {
        result.push(next);
      }
    }
    return result;
  }
  function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i = 1; i < diffs.length; i++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedText = sequence1.getText(unchangedRange);
          const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
          if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
            return true;
          }
          return false;
        };
        const cur = diffs[i];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    return diffs;
  }
  function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i = 1; i < diffs.length; i++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
          if (unchangedLineCount > 5 || unchangedRange.length > 500) {
            return false;
          }
          const unchangedText = sequence1.getText(unchangedRange).trim();
          if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
            return false;
          }
          const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
          const beforeSeq1Length = before.seq1Range.length;
          const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
          const beforeSeq2Length = before.seq2Range.length;
          const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
          const afterSeq1Length = after.seq1Range.length;
          const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
          const afterSeq2Length = after.seq2Range.length;
          const max = 2 * 40 + 50;
          function cap(v2) {
            return Math.min(v2, max);
          }
          if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {
            return true;
          }
          return false;
        };
        const cur = diffs[i];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    const newDiffs = [];
    forEachWithNeighbors(diffs, (prev, cur, next) => {
      let newDiff = cur;
      function shouldMarkAsChanged(text3) {
        return text3.length > 0 && text3.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
      }
      const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
      const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));
      if (shouldMarkAsChanged(prefix)) {
        newDiff = newDiff.deltaStart(-prefix.length);
      }
      const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
      if (shouldMarkAsChanged(suffix)) {
        newDiff = newDiff.deltaEnd(suffix.length);
      }
      const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);
      const result = newDiff.intersect(availableSpace);
      if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {
        newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);
      } else {
        newDiffs.push(result);
      }
    });
    return newDiffs;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js
  var LineSequence2 = class {
    constructor(trimmedHash, lines) {
      this.trimmedHash = trimmedHash;
      this.lines = lines;
    }
    getElement(offset) {
      return this.trimmedHash[offset];
    }
    get length() {
      return this.trimmedHash.length;
    }
    getBoundaryScore(length) {
      const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
      const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
      return 1e3 - (indentationBefore + indentationAfter);
    }
    getText(range) {
      return this.lines.slice(range.start, range.endExclusive).join("\n");
    }
    isStronglyEqual(offset1, offset2) {
      return this.lines[offset1] === this.lines[offset2];
    }
  };
  function getIndentation(str) {
    let i = 0;
    while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
      i++;
    }
    return i;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
  var DefaultLinesDiffComputer = class {
    constructor() {
      this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
      this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
    }
    computeDiff(originalLines, modifiedLines, options) {
      if (originalLines.length <= 1 && equals2(originalLines, modifiedLines, (a, b2) => a === b2)) {
        return new LinesDiff([], [], false);
      }
      if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
        return new LinesDiff([
          new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [
            new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))
          ])
        ], [], false);
      }
      const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);
      const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
      const perfectHashes = /* @__PURE__ */ new Map();
      function getOrCreateHash(text3) {
        let hash = perfectHashes.get(text3);
        if (hash === void 0) {
          hash = perfectHashes.size;
          perfectHashes.set(text3, hash);
        }
        return hash;
      }
      const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));
      const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));
      const sequence1 = new LineSequence2(originalLinesHashes, originalLines);
      const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);
      const lineAlignmentResult = (() => {
        if (sequence1.length + sequence2.length < 1700) {
          return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
        }
        return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);
      })();
      let lineAlignments = lineAlignmentResult.diffs;
      let hitTimeout = lineAlignmentResult.hitTimeout;
      lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
      lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);
      const alignments = [];
      const scanForWhitespaceChanges = (equalLinesCount) => {
        if (!considerWhitespaceChanges) {
          return;
        }
        for (let i = 0; i < equalLinesCount; i++) {
          const seq1Offset = seq1LastStart + i;
          const seq2Offset = seq2LastStart + i;
          if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
            const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
            for (const a of characterDiffs.mappings) {
              alignments.push(a);
            }
            if (characterDiffs.hitTimeout) {
              hitTimeout = true;
            }
          }
        }
      };
      let seq1LastStart = 0;
      let seq2LastStart = 0;
      for (const diff of lineAlignments) {
        assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
        const equalLinesCount = diff.seq1Range.start - seq1LastStart;
        scanForWhitespaceChanges(equalLinesCount);
        seq1LastStart = diff.seq1Range.endExclusive;
        seq2LastStart = diff.seq2Range.endExclusive;
        const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
        if (characterDiffs.hitTimeout) {
          hitTimeout = true;
        }
        for (const a of characterDiffs.mappings) {
          alignments.push(a);
        }
      }
      scanForWhitespaceChanges(originalLines.length - seq1LastStart);
      const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
      let moves = [];
      if (options.computeMoves) {
        moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);
      }
      assertFn(() => {
        function validatePosition(pos, lines) {
          if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
            return false;
          }
          const line = lines[pos.lineNumber - 1];
          if (pos.column < 1 || pos.column > line.length + 1) {
            return false;
          }
          return true;
        }
        function validateRange(range, lines) {
          if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
            return false;
          }
          if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
            return false;
          }
          return true;
        }
        for (const c of changes) {
          if (!c.innerChanges) {
            return false;
          }
          for (const ic of c.innerChanges) {
            const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
            if (!valid) {
              return false;
            }
          }
          if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {
            return false;
          }
        }
        return true;
      });
      return new LinesDiff(changes, moves, hitTimeout);
    }
    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
      const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);
      const movesWithDiffs = moves.map((m) => {
        const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
        const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
        return new MovedText(m, mappings);
      });
      return movesWithDiffs;
    }
    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
      const lineRangeMapping = toLineRangeMapping(diff);
      const rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);
      const slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);
      const slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);
      const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
      const check = false;
      let diffs = diffResult.diffs;
      if (check) {
        SequenceDiff.assertSorted(diffs);
      }
      diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
      if (check) {
        SequenceDiff.assertSorted(diffs);
      }
      diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);
      if (check) {
        SequenceDiff.assertSorted(diffs);
      }
      diffs = removeShortMatches(slice1, slice2, diffs);
      if (check) {
        SequenceDiff.assertSorted(diffs);
      }
      diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);
      if (check) {
        SequenceDiff.assertSorted(diffs);
      }
      const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
      if (check) {
        RangeMapping.assertSorted(result);
      }
      return {
        mappings: result,
        hitTimeout: diffResult.hitTimeout
      };
    }
  };
  function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
    const changes = [];
    for (const g of groupAdjacentBy(alignments.map((a) => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
      const first = g[0];
      const last = g[g.length - 1];
      changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a) => a.innerChanges[0])));
    }
    assertFn(() => {
      if (!dontAssertStartLine && changes.length > 0) {
        if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {
          return false;
        }
        if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {
          return false;
        }
      }
      return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return changes;
  }
  function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
    let lineStartDelta = 0;
    let lineEndDelta = 0;
    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
      lineEndDelta = -1;
    }
    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
      lineStartDelta = 1;
    }
    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
  }
  function toLineRangeMapping(sequenceDiff) {
    return new LineRangeMapping(new LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1), new LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1));
  }

  // node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
  var linesDiffComputers = {
    getLegacy: () => new LegacyLinesDiffComputer(),
    getDefault: () => new DefaultLinesDiffComputer()
  };

  // node_modules/monaco-editor/esm/vs/base/common/color.js
  function roundFloat(number, decimalPoints) {
    const decimal = Math.pow(10, decimalPoints);
    return Math.round(number * decimal) / decimal;
  }
  var RGBA = class {
    constructor(r, g, b2, a = 1) {
      this._rgbaBrand = void 0;
      this.r = Math.min(255, Math.max(0, r)) | 0;
      this.g = Math.min(255, Math.max(0, g)) | 0;
      this.b = Math.min(255, Math.max(0, b2)) | 0;
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b2) {
      return a.r === b2.r && a.g === b2.g && a.b === b2.b && a.a === b2.a;
    }
  };
  var HSLA = class _HSLA {
    constructor(h, s, l, a) {
      this._hslaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b2) {
      return a.h === b2.h && a.s === b2.s && a.l === b2.l && a.a === b2.a;
    }
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba) {
      const r = rgba.r / 255;
      const g = rgba.g / 255;
      const b2 = rgba.b / 255;
      const a = rgba.a;
      const max = Math.max(r, g, b2);
      const min = Math.min(r, g, b2);
      let h = 0;
      let s = 0;
      const l = (min + max) / 2;
      const chroma = max - min;
      if (chroma > 0) {
        s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
        switch (max) {
          case r:
            h = (g - b2) / chroma + (g < b2 ? 6 : 0);
            break;
          case g:
            h = (b2 - r) / chroma + 2;
            break;
          case b2:
            h = (r - g) / chroma + 4;
            break;
        }
        h *= 60;
        h = Math.round(h);
      }
      return new _HSLA(h, s, l, a);
    }
    static _hue2rgb(p2, q2, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p2 + (q2 - p2) * 6 * t2;
      }
      if (t2 < 1 / 2) {
        return q2;
      }
      if (t2 < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      }
      return p2;
    }
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla) {
      const h = hsla.h / 360;
      const { s, l, a } = hsla;
      let r, g, b2;
      if (s === 0) {
        r = g = b2 = l;
      } else {
        const q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p2 = 2 * l - q2;
        r = _HSLA._hue2rgb(p2, q2, h + 1 / 3);
        g = _HSLA._hue2rgb(p2, q2, h);
        b2 = _HSLA._hue2rgb(p2, q2, h - 1 / 3);
      }
      return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b2 * 255), a);
    }
  };
  var HSVA = class _HSVA {
    constructor(h, s, v2, a) {
      this._hsvaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.v = roundFloat(Math.max(Math.min(1, v2), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b2) {
      return a.h === b2.h && a.s === b2.s && a.v === b2.v && a.a === b2.a;
    }
    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    static fromRGBA(rgba) {
      const r = rgba.r / 255;
      const g = rgba.g / 255;
      const b2 = rgba.b / 255;
      const cmax = Math.max(r, g, b2);
      const cmin = Math.min(r, g, b2);
      const delta = cmax - cmin;
      const s = cmax === 0 ? 0 : delta / cmax;
      let m;
      if (delta === 0) {
        m = 0;
      } else if (cmax === r) {
        m = ((g - b2) / delta % 6 + 6) % 6;
      } else if (cmax === g) {
        m = (b2 - r) / delta + 2;
      } else {
        m = (r - g) / delta + 4;
      }
      return new _HSVA(Math.round(m * 60), s, cmax, rgba.a);
    }
    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    static toRGBA(hsva) {
      const { h, s, v: v2, a } = hsva;
      const c = v2 * s;
      const x2 = c * (1 - Math.abs(h / 60 % 2 - 1));
      const m = v2 - c;
      let [r, g, b2] = [0, 0, 0];
      if (h < 60) {
        r = c;
        g = x2;
      } else if (h < 120) {
        r = x2;
        g = c;
      } else if (h < 180) {
        g = c;
        b2 = x2;
      } else if (h < 240) {
        g = x2;
        b2 = c;
      } else if (h < 300) {
        r = x2;
        b2 = c;
      } else if (h <= 360) {
        r = c;
        b2 = x2;
      }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b2 = Math.round((b2 + m) * 255);
      return new RGBA(r, g, b2, a);
    }
  };
  var Color = class _Color {
    static fromHex(hex) {
      return _Color.Format.CSS.parseHex(hex) || _Color.red;
    }
    static equals(a, b2) {
      if (!a && !b2) {
        return true;
      }
      if (!a || !b2) {
        return false;
      }
      return a.equals(b2);
    }
    get hsla() {
      if (this._hsla) {
        return this._hsla;
      } else {
        return HSLA.fromRGBA(this.rgba);
      }
    }
    get hsva() {
      if (this._hsva) {
        return this._hsva;
      }
      return HSVA.fromRGBA(this.rgba);
    }
    constructor(arg) {
      if (!arg) {
        throw new Error("Color needs a value");
      } else if (arg instanceof RGBA) {
        this.rgba = arg;
      } else if (arg instanceof HSLA) {
        this._hsla = arg;
        this.rgba = HSLA.toRGBA(arg);
      } else if (arg instanceof HSVA) {
        this._hsva = arg;
        this.rgba = HSVA.toRGBA(arg);
      } else {
        throw new Error("Invalid color ctor argument");
      }
    }
    equals(other) {
      return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    }
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance() {
      const R2 = _Color._relativeLuminanceForComponent(this.rgba.r);
      const G2 = _Color._relativeLuminanceForComponent(this.rgba.g);
      const B2 = _Color._relativeLuminanceForComponent(this.rgba.b);
      const luminance = 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      return roundFloat(luminance, 4);
    }
    static _relativeLuminanceForComponent(color) {
      const c = color / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    }
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter() {
      const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
      return yiq >= 128;
    }
    isLighterThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 > lum2;
    }
    isDarkerThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 < lum2;
    }
    lighten(factor) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
    }
    darken(factor) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
    }
    transparent(factor) {
      const { r, g, b: b2, a } = this.rgba;
      return new _Color(new RGBA(r, g, b2, a * factor));
    }
    isTransparent() {
      return this.rgba.a === 0;
    }
    isOpaque() {
      return this.rgba.a === 1;
    }
    opposite() {
      return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    makeOpaque(opaqueBackground) {
      if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
        return this;
      }
      const { r, g, b: b2, a } = this.rgba;
      return new _Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b2), 1));
    }
    toString() {
      if (!this._toString) {
        this._toString = _Color.Format.CSS.format(this);
      }
      return this._toString;
    }
    static getLighterColor(of, relative2, factor) {
      if (of.isLighterThan(relative2)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor = factor * (lum2 - lum1) / lum2;
      return of.lighten(factor);
    }
    static getDarkerColor(of, relative2, factor) {
      if (of.isDarkerThan(relative2)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor = factor * (lum1 - lum2) / lum1;
      return of.darken(factor);
    }
    static {
      this.white = new _Color(new RGBA(255, 255, 255, 1));
    }
    static {
      this.black = new _Color(new RGBA(0, 0, 0, 1));
    }
    static {
      this.red = new _Color(new RGBA(255, 0, 0, 1));
    }
    static {
      this.blue = new _Color(new RGBA(0, 0, 255, 1));
    }
    static {
      this.green = new _Color(new RGBA(0, 255, 0, 1));
    }
    static {
      this.cyan = new _Color(new RGBA(0, 255, 255, 1));
    }
    static {
      this.lightgrey = new _Color(new RGBA(211, 211, 211, 1));
    }
    static {
      this.transparent = new _Color(new RGBA(0, 0, 0, 0));
    }
  };
  (function(Color3) {
    let Format;
    (function(Format2) {
      let CSS;
      (function(CSS2) {
        function formatRGB(color) {
          if (color.rgba.a === 1) {
            return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
          }
          return Color3.Format.CSS.formatRGBA(color);
        }
        CSS2.formatRGB = formatRGB;
        function formatRGBA(color) {
          return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
        }
        CSS2.formatRGBA = formatRGBA;
        function formatHSL(color) {
          if (color.hsla.a === 1) {
            return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
          }
          return Color3.Format.CSS.formatHSLA(color);
        }
        CSS2.formatHSL = formatHSL;
        function formatHSLA(color) {
          return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
        }
        CSS2.formatHSLA = formatHSLA;
        function _toTwoDigitHex(n) {
          const r = n.toString(16);
          return r.length !== 2 ? "0" + r : r;
        }
        function formatHex(color) {
          return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
        }
        CSS2.formatHex = formatHex;
        function formatHexA(color, compact = false) {
          if (compact && color.rgba.a === 1) {
            return Color3.Format.CSS.formatHex(color);
          }
          return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
        }
        CSS2.formatHexA = formatHexA;
        function format(color) {
          if (color.isOpaque()) {
            return Color3.Format.CSS.formatHex(color);
          }
          return Color3.Format.CSS.formatRGBA(color);
        }
        CSS2.format = format;
        function parseHex(hex) {
          const length = hex.length;
          if (length === 0) {
            return null;
          }
          if (hex.charCodeAt(0) !== 35) {
            return null;
          }
          if (length === 7) {
            const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            const b2 = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            return new Color3(new RGBA(r, g, b2, 1));
          }
          if (length === 9) {
            const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            const b2 = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
            return new Color3(new RGBA(r, g, b2, a / 255));
          }
          if (length === 4) {
            const r = _parseHexDigit(hex.charCodeAt(1));
            const g = _parseHexDigit(hex.charCodeAt(2));
            const b2 = _parseHexDigit(hex.charCodeAt(3));
            return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b2 + b2));
          }
          if (length === 5) {
            const r = _parseHexDigit(hex.charCodeAt(1));
            const g = _parseHexDigit(hex.charCodeAt(2));
            const b2 = _parseHexDigit(hex.charCodeAt(3));
            const a = _parseHexDigit(hex.charCodeAt(4));
            return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b2 + b2, (16 * a + a) / 255));
          }
          return null;
        }
        CSS2.parseHex = parseHex;
        function _parseHexDigit(charCode) {
          switch (charCode) {
            case 48:
              return 0;
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case 97:
              return 10;
            case 65:
              return 10;
            case 98:
              return 11;
            case 66:
              return 11;
            case 99:
              return 12;
            case 67:
              return 12;
            case 100:
              return 13;
            case 68:
              return 13;
            case 101:
              return 14;
            case 69:
              return 14;
            case 102:
              return 15;
            case 70:
              return 15;
          }
          return 0;
        }
      })(CSS = Format2.CSS || (Format2.CSS = {}));
    })(Format = Color3.Format || (Color3.Format = {}));
  })(Color || (Color = {}));

  // node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
  function _parseCaptureGroups(captureGroups) {
    const values = [];
    for (const captureGroup of captureGroups) {
      const parsedNumber = Number(captureGroup);
      if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
        values.push(parsedNumber);
      }
    }
    return values;
  }
  function _toIColor(r, g, b2, a) {
    return {
      red: r / 255,
      blue: b2 / 255,
      green: g / 255,
      alpha: a
    };
  }
  function _findRange(model, match) {
    const index = match.index;
    const length = match[0].length;
    if (!index) {
      return;
    }
    const startPosition = model.positionAt(index);
    const range = {
      startLineNumber: startPosition.lineNumber,
      startColumn: startPosition.column,
      endLineNumber: startPosition.lineNumber,
      endColumn: startPosition.column + length
    };
    return range;
  }
  function _findHexColorInformation(range, hexValue) {
    if (!range) {
      return;
    }
    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);
    if (!parsedHexColor) {
      return;
    }
    return {
      range,
      color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
    };
  }
  function _findRGBColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    return {
      range,
      color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
    };
  }
  function _findHSLColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
    return {
      range,
      color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
    };
  }
  function _findMatches(model, regex) {
    if (typeof model === "string") {
      return [...model.matchAll(regex)];
    } else {
      return model.findMatches(regex);
    }
  }
  function computeColors(model) {
    const result = [];
    const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
    const initialValidationMatches = _findMatches(model, initialValidationRegex);
    if (initialValidationMatches.length > 0) {
      for (const initialMatch of initialValidationMatches) {
        const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
        const colorScheme = initialCaptureGroups[1];
        const colorParameters = initialCaptureGroups[2];
        if (!colorParameters) {
          continue;
        }
        let colorInformation;
        if (colorScheme === "rgb") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "rgba") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "hsl") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "hsla") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "#") {
          colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
        }
        if (colorInformation) {
          result.push(colorInformation);
        }
      }
    }
    return result;
  }
  function computeDefaultDocumentColors(model) {
    if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
      return [];
    }
    return computeColors(model);
  }

  // node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js
  var markRegex = new RegExp("\\bMARK:\\s*(.*)$", "d");
  var trimDashesRegex = /^-+|-+$/g;
  function findSectionHeaders(model, options) {
    let headers = [];
    if (options.findRegionSectionHeaders && options.foldingRules?.markers) {
      const regionHeaders = collectRegionHeaders(model, options);
      headers = headers.concat(regionHeaders);
    }
    if (options.findMarkSectionHeaders) {
      const markHeaders = collectMarkHeaders(model);
      headers = headers.concat(markHeaders);
    }
    return headers;
  }
  function collectRegionHeaders(model, options) {
    const regionHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      const match = lineContent.match(options.foldingRules.markers.start);
      if (match) {
        const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };
        if (range.endColumn > range.startColumn) {
          const sectionHeader = {
            range,
            ...getHeaderText(lineContent.substring(match[0].length)),
            shouldBeInComments: false
          };
          if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
            regionHeaders.push(sectionHeader);
          }
        }
      }
    }
    return regionHeaders;
  }
  function collectMarkHeaders(model) {
    const markHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);
    }
    return markHeaders;
  }
  function addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {
    markRegex.lastIndex = 0;
    const match = markRegex.exec(lineContent);
    if (match) {
      const column = match.indices[1][0] + 1;
      const endColumn = match.indices[1][1] + 1;
      const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn };
      if (range.endColumn > range.startColumn) {
        const sectionHeader = {
          range,
          ...getHeaderText(match[1]),
          shouldBeInComments: true
        };
        if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
          sectionHeaders.push(sectionHeader);
        }
      }
    }
  }
  function getHeaderText(text3) {
    text3 = text3.trim();
    const hasSeparatorLine = text3.startsWith("-");
    text3 = text3.replace(trimDashesRegex, "");
    return { text: text3, hasSeparatorLine };
  }

  // node_modules/monaco-editor/esm/vs/base/common/symbols.js
  var MicrotaskDelay = Symbol("MicrotaskDelay");

  // node_modules/monaco-editor/esm/vs/base/common/async.js
  var runWhenGlobalIdle;
  var _runWhenIdle;
  (function() {
    if (typeof globalThis.requestIdleCallback !== "function" || typeof globalThis.cancelIdleCallback !== "function") {
      _runWhenIdle = (_targetWindow, runner) => {
        setTimeout0(() => {
          if (disposed) {
            return;
          }
          const end = Date.now() + 15;
          const deadline = {
            didTimeout: true,
            timeRemaining() {
              return Math.max(0, end - Date.now());
            }
          };
          runner(Object.freeze(deadline));
        });
        let disposed = false;
        return {
          dispose() {
            if (disposed) {
              return;
            }
            disposed = true;
          }
        };
      };
    } else {
      _runWhenIdle = (targetWindow, runner, timeout) => {
        const handle = targetWindow.requestIdleCallback(runner, typeof timeout === "number" ? { timeout } : void 0);
        let disposed = false;
        return {
          dispose() {
            if (disposed) {
              return;
            }
            disposed = true;
            targetWindow.cancelIdleCallback(handle);
          }
        };
      };
    }
    runWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);
  })();
  var Promises;
  (function(Promises2) {
    async function settled(promises) {
      let firstError = void 0;
      const result = await Promise.all(promises.map((promise) => promise.then((value) => value, (error) => {
        if (!firstError) {
          firstError = error;
        }
        return void 0;
      })));
      if (typeof firstError !== "undefined") {
        throw firstError;
      }
      return result;
    }
    Promises2.settled = settled;
    function withAsyncBody(bodyFn) {
      return new Promise(async (resolve2, reject) => {
        try {
          await bodyFn(resolve2, reject);
        } catch (error) {
          reject(error);
        }
      });
    }
    Promises2.withAsyncBody = withAsyncBody;
  })(Promises || (Promises = {}));
  var AsyncIterableObject = class _AsyncIterableObject {
    static fromArray(items) {
      return new _AsyncIterableObject((writer) => {
        writer.emitMany(items);
      });
    }
    static fromPromise(promise) {
      return new _AsyncIterableObject(async (emitter) => {
        emitter.emitMany(await promise);
      });
    }
    static fromPromises(promises) {
      return new _AsyncIterableObject(async (emitter) => {
        await Promise.all(promises.map(async (p2) => emitter.emitOne(await p2)));
      });
    }
    static merge(iterables) {
      return new _AsyncIterableObject(async (emitter) => {
        await Promise.all(iterables.map(async (iterable) => {
          for await (const item of iterable) {
            emitter.emitOne(item);
          }
        }));
      });
    }
    static {
      this.EMPTY = _AsyncIterableObject.fromArray([]);
    }
    constructor(executor, onReturn) {
      this._state = 0;
      this._results = [];
      this._error = null;
      this._onReturn = onReturn;
      this._onStateChanged = new Emitter();
      queueMicrotask(async () => {
        const writer = {
          emitOne: (item) => this.emitOne(item),
          emitMany: (items) => this.emitMany(items),
          reject: (error) => this.reject(error)
        };
        try {
          await Promise.resolve(executor(writer));
          this.resolve();
        } catch (err) {
          this.reject(err);
        } finally {
          writer.emitOne = void 0;
          writer.emitMany = void 0;
          writer.reject = void 0;
        }
      });
    }
    [Symbol.asyncIterator]() {
      let i = 0;
      return {
        next: async () => {
          do {
            if (this._state === 2) {
              throw this._error;
            }
            if (i < this._results.length) {
              return { done: false, value: this._results[i++] };
            }
            if (this._state === 1) {
              return { done: true, value: void 0 };
            }
            await Event.toPromise(this._onStateChanged.event);
          } while (true);
        },
        return: async () => {
          this._onReturn?.();
          return { done: true, value: void 0 };
        }
      };
    }
    static map(iterable, mapFn) {
      return new _AsyncIterableObject(async (emitter) => {
        for await (const item of iterable) {
          emitter.emitOne(mapFn(item));
        }
      });
    }
    map(mapFn) {
      return _AsyncIterableObject.map(this, mapFn);
    }
    static filter(iterable, filterFn) {
      return new _AsyncIterableObject(async (emitter) => {
        for await (const item of iterable) {
          if (filterFn(item)) {
            emitter.emitOne(item);
          }
        }
      });
    }
    filter(filterFn) {
      return _AsyncIterableObject.filter(this, filterFn);
    }
    static coalesce(iterable) {
      return _AsyncIterableObject.filter(iterable, (item) => !!item);
    }
    coalesce() {
      return _AsyncIterableObject.coalesce(this);
    }
    static async toPromise(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return result;
    }
    toPromise() {
      return _AsyncIterableObject.toPromise(this);
    }
    /**
     * The value will be appended at the end.
     *
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    emitOne(value) {
      if (this._state !== 0) {
        return;
      }
      this._results.push(value);
      this._onStateChanged.fire();
    }
    /**
     * The values will be appended at the end.
     *
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    emitMany(values) {
      if (this._state !== 0) {
        return;
      }
      this._results = this._results.concat(values);
      this._onStateChanged.fire();
    }
    /**
     * Calling `resolve()` will mark the result array as complete.
     *
     * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    resolve() {
      if (this._state !== 0) {
        return;
      }
      this._state = 1;
      this._onStateChanged.fire();
    }
    /**
     * Writing an error will permanently invalidate this iterable.
     * The current users will receive an error thrown, as will all future users.
     *
     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
     */
    reject(error) {
      if (this._state !== 0) {
        return;
      }
      this._state = 2;
      this._error = error;
      this._onStateChanged.fire();
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer = class {
    constructor(values) {
      this.values = values;
      this.prefixSum = new Uint32Array(values.length);
      this.prefixSumValidIndex = new Int32Array(1);
      this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
      insertIndex = toUint32(insertIndex);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      const insertValuesLen = insertValues.length;
      if (insertValuesLen === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length + insertValuesLen);
      this.values.set(oldValues.subarray(0, insertIndex), 0);
      this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
      this.values.set(insertValues, insertIndex);
      if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = insertIndex - 1;
      }
      this.prefixSum = new Uint32Array(this.values.length);
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    setValue(index, value) {
      index = toUint32(index);
      value = toUint32(value);
      if (this.values[index] === value) {
        return false;
      }
      this.values[index] = value;
      if (index - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = index - 1;
      }
      return true;
    }
    removeValues(startIndex, count) {
      startIndex = toUint32(startIndex);
      count = toUint32(count);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      if (startIndex >= oldValues.length) {
        return false;
      }
      const maxCount = oldValues.length - startIndex;
      if (count >= maxCount) {
        count = maxCount;
      }
      if (count === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length - count);
      this.values.set(oldValues.subarray(0, startIndex), 0);
      this.values.set(oldValues.subarray(startIndex + count), startIndex);
      this.prefixSum = new Uint32Array(this.values.length);
      if (startIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = startIndex - 1;
      }
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    getTotalSum() {
      if (this.values.length === 0) {
        return 0;
      }
      return this._getPrefixSum(this.values.length - 1);
    }
    /**
     * Returns the sum of the first `index + 1` many items.
     * @returns `SUM(0 <= j <= index, values[j])`.
     */
    getPrefixSum(index) {
      if (index < 0) {
        return 0;
      }
      index = toUint32(index);
      return this._getPrefixSum(index);
    }
    _getPrefixSum(index) {
      if (index <= this.prefixSumValidIndex[0]) {
        return this.prefixSum[index];
      }
      let startIndex = this.prefixSumValidIndex[0] + 1;
      if (startIndex === 0) {
        this.prefixSum[0] = this.values[0];
        startIndex++;
      }
      if (index >= this.values.length) {
        index = this.values.length - 1;
      }
      for (let i = startIndex; i <= index; i++) {
        this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
      }
      this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
      return this.prefixSum[index];
    }
    getIndexOf(sum) {
      sum = Math.floor(sum);
      this.getTotalSum();
      let low = 0;
      let high = this.values.length - 1;
      let mid = 0;
      let midStop = 0;
      let midStart = 0;
      while (low <= high) {
        mid = low + (high - low) / 2 | 0;
        midStop = this.prefixSum[mid];
        midStart = midStop - this.values[mid];
        if (sum < midStart) {
          high = mid - 1;
        } else if (sum >= midStop) {
          low = mid + 1;
        } else {
          break;
        }
      }
      return new PrefixSumIndexOfResult(mid, sum - midStart);
    }
  };
  var PrefixSumIndexOfResult = class {
    constructor(index, remainder) {
      this.index = index;
      this.remainder = remainder;
      this._prefixSumIndexOfResultBrand = void 0;
      this.index = index;
      this.remainder = remainder;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel = class {
    constructor(uri, lines, eol, versionId) {
      this._uri = uri;
      this._lines = lines;
      this._eol = eol;
      this._versionId = versionId;
      this._lineStarts = null;
      this._cachedTextValue = null;
    }
    dispose() {
      this._lines.length = 0;
    }
    get version() {
      return this._versionId;
    }
    getText() {
      if (this._cachedTextValue === null) {
        this._cachedTextValue = this._lines.join(this._eol);
      }
      return this._cachedTextValue;
    }
    onEvents(e) {
      if (e.eol && e.eol !== this._eol) {
        this._eol = e.eol;
        this._lineStarts = null;
      }
      const changes = e.changes;
      for (const change of changes) {
        this._acceptDeleteRange(change.range);
        this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
      }
      this._versionId = e.versionId;
      this._cachedTextValue = null;
    }
    _ensureLineStarts() {
      if (!this._lineStarts) {
        const eolLength = this._eol.length;
        const linesLength = this._lines.length;
        const lineStartValues = new Uint32Array(linesLength);
        for (let i = 0; i < linesLength; i++) {
          lineStartValues[i] = this._lines[i].length + eolLength;
        }
        this._lineStarts = new PrefixSumComputer(lineStartValues);
      }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
      this._lines[lineIndex] = newValue;
      if (this._lineStarts) {
        this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
      }
    }
    _acceptDeleteRange(range) {
      if (range.startLineNumber === range.endLineNumber) {
        if (range.startColumn === range.endColumn) {
          return;
        }
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
        return;
      }
      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
      this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      if (this._lineStarts) {
        this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      }
    }
    _acceptInsertText(position, insertText) {
      if (insertText.length === 0) {
        return;
      }
      const insertLines = splitLines(insertText);
      if (insertLines.length === 1) {
        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
        return;
      }
      insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
      const newLengths = new Uint32Array(insertLines.length - 1);
      for (let i = 1; i < insertLines.length; i++) {
        this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
        newLengths[i - 1] = insertLines[i].length + this._eol.length;
      }
      if (this._lineStarts) {
        this._lineStarts.insertValues(position.lineNumber, newLengths);
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js
  var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1e3;
  var WorkerTextModelSyncServer = class {
    constructor() {
      this._models = /* @__PURE__ */ Object.create(null);
    }
    getModel(uri) {
      return this._models[uri];
    }
    getModels() {
      const all = [];
      Object.keys(this._models).forEach((key) => all.push(this._models[key]));
      return all;
    }
    $acceptNewModel(data) {
      this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    $acceptModelChanged(uri, e) {
      if (!this._models[uri]) {
        return;
      }
      const model = this._models[uri];
      model.onEvents(e);
    }
    $acceptRemovedModel(uri) {
      if (!this._models[uri]) {
        return;
      }
      delete this._models[uri];
    }
  };
  var MirrorModel = class extends MirrorTextModel {
    get uri() {
      return this._uri;
    }
    get eol() {
      return this._eol;
    }
    getValue() {
      return this.getText();
    }
    findMatches(regex) {
      const matches = [];
      for (let i = 0; i < this._lines.length; i++) {
        const line = this._lines[i];
        const offsetToAdd = this.offsetAt(new Position(i + 1, 1));
        const iteratorOverMatches = line.matchAll(regex);
        for (const match of iteratorOverMatches) {
          if (match.index || match.index === 0) {
            match.index = match.index + offsetToAdd;
          }
          matches.push(match);
        }
      }
      return matches;
    }
    getLinesContent() {
      return this._lines.slice(0);
    }
    getLineCount() {
      return this._lines.length;
    }
    getLineContent(lineNumber) {
      return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position, wordDefinition) {
      const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
      if (wordAtText) {
        return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
      }
      return null;
    }
    words(wordDefinition) {
      const lines = this._lines;
      const wordenize = this._wordenize.bind(this);
      let lineNumber = 0;
      let lineText = "";
      let wordRangesIdx = 0;
      let wordRanges = [];
      return {
        *[Symbol.iterator]() {
          while (true) {
            if (wordRangesIdx < wordRanges.length) {
              const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
              wordRangesIdx += 1;
              yield value;
            } else {
              if (lineNumber < lines.length) {
                lineText = lines[lineNumber];
                wordRanges = wordenize(lineText, wordDefinition);
                wordRangesIdx = 0;
                lineNumber += 1;
              } else {
                break;
              }
            }
          }
        }
      };
    }
    getLineWords(lineNumber, wordDefinition) {
      const content = this._lines[lineNumber - 1];
      const ranges = this._wordenize(content, wordDefinition);
      const words = [];
      for (const range of ranges) {
        words.push({
          word: content.substring(range.start, range.end),
          startColumn: range.start + 1,
          endColumn: range.end + 1
        });
      }
      return words;
    }
    _wordenize(content, wordDefinition) {
      const result = [];
      let match;
      wordDefinition.lastIndex = 0;
      while (match = wordDefinition.exec(content)) {
        if (match[0].length === 0) {
          break;
        }
        result.push({ start: match.index, end: match.index + match[0].length });
      }
      return result;
    }
    getValueInRange(range) {
      range = this._validateRange(range);
      if (range.startLineNumber === range.endLineNumber) {
        return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
      }
      const lineEnding = this._eol;
      const startLineIndex = range.startLineNumber - 1;
      const endLineIndex = range.endLineNumber - 1;
      const resultLines = [];
      resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
      for (let i = startLineIndex + 1; i < endLineIndex; i++) {
        resultLines.push(this._lines[i]);
      }
      resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
      return resultLines.join(lineEnding);
    }
    offsetAt(position) {
      position = this._validatePosition(position);
      this._ensureLineStarts();
      return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
    }
    positionAt(offset) {
      offset = Math.floor(offset);
      offset = Math.max(0, offset);
      this._ensureLineStarts();
      const out = this._lineStarts.getIndexOf(offset);
      const lineLength = this._lines[out.index].length;
      return {
        lineNumber: 1 + out.index,
        column: 1 + Math.min(out.remainder, lineLength)
      };
    }
    _validateRange(range) {
      const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
      const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
      if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
        return {
          startLineNumber: start.lineNumber,
          startColumn: start.column,
          endLineNumber: end.lineNumber,
          endColumn: end.column
        };
      }
      return range;
    }
    _validatePosition(position) {
      if (!Position.isIPosition(position)) {
        throw new Error("bad position");
      }
      let { lineNumber, column } = position;
      let hasChanged = false;
      if (lineNumber < 1) {
        lineNumber = 1;
        column = 1;
        hasChanged = true;
      } else if (lineNumber > this._lines.length) {
        lineNumber = this._lines.length;
        column = this._lines[lineNumber - 1].length + 1;
        hasChanged = true;
      } else {
        const maxCharacter = this._lines[lineNumber - 1].length + 1;
        if (column < 1) {
          column = 1;
          hasChanged = true;
        } else if (column > maxCharacter) {
          column = maxCharacter;
          hasChanged = true;
        }
      }
      if (!hasChanged) {
        return position;
      } else {
        return { lineNumber, column };
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
  var isESM2 = true;
  var BaseEditorSimpleWorker = class {
    constructor() {
      this._workerTextModelSyncServer = new WorkerTextModelSyncServer();
    }
    dispose() {
    }
    _getModel(uri) {
      return this._workerTextModelSyncServer.getModel(uri);
    }
    _getModels() {
      return this._workerTextModelSyncServer.getModels();
    }
    $acceptNewModel(data) {
      this._workerTextModelSyncServer.$acceptNewModel(data);
    }
    $acceptModelChanged(uri, e) {
      this._workerTextModelSyncServer.$acceptModelChanged(uri, e);
    }
    $acceptRemovedModel(uri) {
      this._workerTextModelSyncServer.$acceptRemovedModel(uri);
    }
    async $computeUnicodeHighlights(url, options, range) {
      const model = this._getModel(url);
      if (!model) {
        return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
      }
      return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
    }
    async $findSectionHeaders(url, options) {
      const model = this._getModel(url);
      if (!model) {
        return [];
      }
      return findSectionHeaders(model, options);
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    async $computeDiff(originalUrl, modifiedUrl, options, algorithm) {
      const original = this._getModel(originalUrl);
      const modified = this._getModel(modifiedUrl);
      if (!original || !modified) {
        return null;
      }
      const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
      return result;
    }
    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
      const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
      const originalLines = originalTextModel.getLinesContent();
      const modifiedLines = modifiedTextModel.getLinesContent();
      const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
      const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
      function getLineChanges(changes) {
        return changes.map((m) => [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map((m2) => [
          m2.originalRange.startLineNumber,
          m2.originalRange.startColumn,
          m2.originalRange.endLineNumber,
          m2.originalRange.endColumn,
          m2.modifiedRange.startLineNumber,
          m2.modifiedRange.startColumn,
          m2.modifiedRange.endLineNumber,
          m2.modifiedRange.endColumn
        ])]);
      }
      return {
        identical,
        quitEarly: result.hitTimeout,
        changes: getLineChanges(result.changes),
        moves: result.moves.map((m) => [
          m.lineRangeMapping.original.startLineNumber,
          m.lineRangeMapping.original.endLineNumberExclusive,
          m.lineRangeMapping.modified.startLineNumber,
          m.lineRangeMapping.modified.endLineNumberExclusive,
          getLineChanges(m.changes)
        ])
      };
    }
    static _modelsAreIdentical(original, modified) {
      const originalLineCount = original.getLineCount();
      const modifiedLineCount = modified.getLineCount();
      if (originalLineCount !== modifiedLineCount) {
        return false;
      }
      for (let line = 1; line <= originalLineCount; line++) {
        const originalLine = original.getLineContent(line);
        const modifiedLine = modified.getLineContent(line);
        if (originalLine !== modifiedLine) {
          return false;
        }
      }
      return true;
    }
    static {
      this._diffLimit = 1e5;
    }
    async $computeMoreMinimalEdits(modelUrl, edits, pretty) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return edits;
      }
      const result = [];
      let lastEol = void 0;
      edits = edits.slice(0).sort((a, b2) => {
        if (a.range && b2.range) {
          return Range.compareRangesUsingStarts(a.range, b2.range);
        }
        const aRng = a.range ? 0 : 1;
        const bRng = b2.range ? 0 : 1;
        return aRng - bRng;
      });
      let writeIndex = 0;
      for (let readIndex = 1; readIndex < edits.length; readIndex++) {
        if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {
          edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));
          edits[writeIndex].text += edits[readIndex].text;
        } else {
          writeIndex++;
          edits[writeIndex] = edits[readIndex];
        }
      }
      edits.length = writeIndex + 1;
      for (let { range, text: text3, eol } of edits) {
        if (typeof eol === "number") {
          lastEol = eol;
        }
        if (Range.isEmpty(range) && !text3) {
          continue;
        }
        const original = model.getValueInRange(range);
        text3 = text3.replace(/\r\n|\n|\r/g, model.eol);
        if (original === text3) {
          continue;
        }
        if (Math.max(text3.length, original.length) > EditorSimpleWorker._diffLimit) {
          result.push({ range, text: text3 });
          continue;
        }
        const changes = stringDiff(original, text3, pretty);
        const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
        for (const change of changes) {
          const start = model.positionAt(editOffset + change.originalStart);
          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
          const newEdit = {
            text: text3.substr(change.modifiedStart, change.modifiedLength),
            range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
          };
          if (model.getValueInRange(newEdit.range) !== newEdit.text) {
            result.push(newEdit);
          }
        }
      }
      if (typeof lastEol === "number") {
        result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
      }
      return result;
    }
    // ---- END minimal edits ---------------------------------------------------------------
    async $computeLinks(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeLinks(model);
    }
    // --- BEGIN default document colors -----------------------------------------------------------
    async $computeDefaultDocumentColors(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeDefaultDocumentColors(model);
    }
    static {
      this._suggestionsLimit = 1e4;
    }
    async $textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
      const sw = new StopWatch();
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const seen = /* @__PURE__ */ new Set();
      outer: for (const url of modelUrls) {
        const model = this._getModel(url);
        if (!model) {
          continue;
        }
        for (const word2 of model.words(wordDefRegExp)) {
          if (word2 === leadingWord || !isNaN(Number(word2))) {
            continue;
          }
          seen.add(word2);
          if (seen.size > EditorSimpleWorker._suggestionsLimit) {
            break outer;
          }
        }
      }
      return { words: Array.from(seen), duration: sw.elapsed() };
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    async $computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return /* @__PURE__ */ Object.create(null);
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const result = /* @__PURE__ */ Object.create(null);
      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
        const words = model.getLineWords(line, wordDefRegExp);
        for (const word2 of words) {
          if (!isNaN(Number(word2.word))) {
            continue;
          }
          let array = result[word2.word];
          if (!array) {
            array = [];
            result[word2.word] = array;
          }
          array.push({
            startLineNumber: line,
            startColumn: word2.startColumn,
            endLineNumber: line,
            endColumn: word2.endColumn
          });
        }
      }
      return result;
    }
    //#endregion
    async $navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      if (range.startColumn === range.endColumn) {
        range = {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn + 1
        };
      }
      const selectionText = model.getValueInRange(range);
      const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
      if (!wordRange) {
        return null;
      }
      const word2 = model.getValueInRange(wordRange);
      const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word2, up);
      return result;
    }
  };
  var EditorSimpleWorker = class extends BaseEditorSimpleWorker {
    constructor(_host, _foreignModuleFactory) {
      super();
      this._host = _host;
      this._foreignModuleFactory = _foreignModuleFactory;
      this._foreignModule = null;
    }
    async $ping() {
      return "pong";
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    $loadForeignModule(moduleId, createData, foreignHostMethods) {
      const proxyMethodRequest = (method, args) => {
        return this._host.$fhr(method, args);
      };
      const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
      const ctx = {
        host: foreignHost,
        getMirrorModels: () => {
          return this._getModels();
        }
      };
      if (this._foreignModuleFactory) {
        this._foreignModule = this._foreignModuleFactory(ctx, createData);
        return Promise.resolve(getAllMethodNames(this._foreignModule));
      }
      return new Promise((resolve2, reject) => {
        const onModuleCallback = (foreignModule) => {
          this._foreignModule = foreignModule.create(ctx, createData);
          resolve2(getAllMethodNames(this._foreignModule));
        };
        if (!isESM2) {
          __require([`${moduleId}`], onModuleCallback, reject);
        } else {
          const url = FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);
          import(`${url}`).then(onModuleCallback).catch(reject);
        }
      });
    }
    // foreign method request
    $fmr(method, args) {
      if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
  if (typeof importScripts === "function") {
    globalThis.monaco = createMonacoBaseAPI();
  }

  // node_modules/monaco-editor/esm/vs/editor/editor.worker.js
  var initialized = false;
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      globalThis.postMessage(msg);
    }, (workerServer) => new EditorSimpleWorker(EditorWorkerHost.getChannel(workerServer), foreignModule));
    globalThis.onmessage = (e) => {
      simpleWorker.onmessage(e.data);
    };
  }
  globalThis.onmessage = (e) => {
    if (!initialized) {
      initialize(null);
    }
  };

  // node_modules/graphql/jsutils/devAssert.mjs
  function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  }

  // node_modules/graphql/jsutils/isObjectLike.mjs
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }

  // node_modules/graphql/jsutils/invariant.mjs
  function invariant(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(
        message != null ? message : "Unexpected invariant triggered."
      );
    }
  }

  // node_modules/graphql/language/location.mjs
  var LineRegExp = /\r\n|[\n\r]/g;
  function getLocation(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match of source.body.matchAll(LineRegExp)) {
      typeof match.index === "number" || invariant(false);
      if (match.index >= position) {
        break;
      }
      lastLineStart = match.index + match[0].length;
      line += 1;
    }
    return {
      line,
      column: position + 1 - lastLineStart
    };
  }

  // node_modules/graphql/language/printLocation.mjs
  function printLocation(location) {
    return printSourceLocation(
      location.source,
      getLocation(location.source, location.start)
    );
  }
  function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0; i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      // Lines specified like this: ["prefix", "string"],
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_2, line]) => line !== void 0);
    const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
    return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
  }

  // node_modules/graphql/error/GraphQLError.mjs
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }
  var GraphQLError = class _GraphQLError extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(message, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref;
      const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message);
      this.name = "GraphQLError";
      this.path = path !== null && path !== void 0 ? path : void 0;
      this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
      this.nodes = undefinedIfEmpty(
        Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
      );
      const nodeLocations = undefinedIfEmpty(
        (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
      );
      this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
      this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
      const originalExtensions = isObjectLike(
        originalError === null || originalError === void 0 ? void 0 : originalError.extensions
      ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
      this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== void 0 && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, _GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output = this.message;
      if (this.nodes) {
        for (const node of this.nodes) {
          if (node.loc) {
            output += "\n\n" + printLocation(node.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location of this.locations) {
          output += "\n\n" + printSourceLocation(this.source, location);
        }
      }
      return output;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  };
  function undefinedIfEmpty(array) {
    return array === void 0 || array.length === 0 ? void 0 : array;
  }

  // node_modules/graphql/error/syntaxError.mjs
  function syntaxError(source, position, description) {
    return new GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position]
    });
  }

  // node_modules/graphql/language/ast.mjs
  var Location = class {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  };
  var Token2 = class {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(kind, start, end, line, column, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  };
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "description",
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: [
      "description",
      "variable",
      "type",
      "defaultValue",
      "directives"
    ],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "description",
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"],
    TypeCoordinate: ["name"],
    MemberCoordinate: ["name", "memberName"],
    ArgumentCoordinate: ["name", "fieldName", "argumentName"],
    DirectiveCoordinate: ["name"],
    DirectiveArgumentCoordinate: ["name", "argumentName"]
  };
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  function isNode(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  }
  var OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (OperationTypeNode = {}));

  // node_modules/graphql/language/directiveLocation.mjs
  var DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (DirectiveLocation = {}));

  // node_modules/graphql/language/kinds.mjs
  var Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    Kind2["TYPE_COORDINATE"] = "TypeCoordinate";
    Kind2["MEMBER_COORDINATE"] = "MemberCoordinate";
    Kind2["ARGUMENT_COORDINATE"] = "ArgumentCoordinate";
    Kind2["DIRECTIVE_COORDINATE"] = "DirectiveCoordinate";
    Kind2["DIRECTIVE_ARGUMENT_COORDINATE"] = "DirectiveArgumentCoordinate";
  })(Kind || (Kind = {}));

  // node_modules/graphql/language/characterClasses.mjs
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || // A-Z
    code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }

  // node_modules/graphql/language/blockString.mjs
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0; i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line = lines[i];
      const indent2 = leadingWhitespace(line);
      if (indent2 === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent2 < commonIndent) {
        commonIndent = indent2;
      }
    }
    return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
      lastNonEmptyLine + 1
    );
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  }
  function printBlockString(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
    (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result = "";
    const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result += "\n";
    }
    result += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result += "\n";
    }
    return '"""' + result + '"""';
  }

  // node_modules/graphql/language/tokenKind.mjs
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["DOT"] = ".";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (TokenKind = {}));

  // node_modules/graphql/language/lexer.mjs
  var Lexer = class {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(source) {
      const startOfFileToken = new Token2(TokenKind.SOF, 0, 0, 0, 0);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      this.lastToken = this.token;
      const token = this.token = this.lookahead();
      return token;
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let token = this.token;
      if (token.kind !== TokenKind.EOF) {
        do {
          if (token.next) {
            token = token.next;
          } else {
            const nextToken = readNextToken(this, token.end);
            token.next = nextToken;
            nextToken.prev = token;
            token = nextToken;
          }
        } while (token.kind === TokenKind.COMMENT);
      }
      return token;
    }
  };
  function isPunctuatorTokenKind(kind) {
    return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.DOT || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === void 0) {
      return TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? `'"'` : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new Token2(kind, start, end, line, col, value);
  }
  function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      switch (code) {
        // Ignored ::
        //   - UnicodeBOM
        //   - WhiteSpace
        //   - LineTerminator
        //   - Comment
        //   - Comma
        //
        // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
        //
        // WhiteSpace ::
        //   - "Horizontal Tab (U+0009)"
        //   - "Space (U+0020)"
        //
        // Comma :: ,
        case 65279:
        // <BOM>
        case 9:
        // \t
        case 32:
        // <space>
        case 44:
          ++position;
          continue;
        // LineTerminator ::
        //   - "New Line (U+000A)"
        //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
        //   - "Carriage Return (U+000D)" "New Line (U+000A)"
        case 10:
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 13:
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        // Comment
        case 35:
          return readComment(lexer, position);
        // Token ::
        //   - Punctuator
        //   - Name
        //   - IntValue
        //   - FloatValue
        //   - StringValue
        //
        // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
        case 33:
          return createToken(lexer, TokenKind.BANG, position, position + 1);
        case 36:
          return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
        case 38:
          return createToken(lexer, TokenKind.AMP, position, position + 1);
        case 40:
          return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
        case 41:
          return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
        case 46:
          if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
            return createToken(lexer, TokenKind.SPREAD, position, position + 3);
          }
          break;
        case 58:
          return createToken(lexer, TokenKind.COLON, position, position + 1);
        case 61:
          return createToken(lexer, TokenKind.EQUALS, position, position + 1);
        case 64:
          return createToken(lexer, TokenKind.AT, position, position + 1);
        case 91:
          return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
        case 93:
          return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
        case 123:
          return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
        case 124:
          return createToken(lexer, TokenKind.PIPE, position, position + 1);
        case 125:
          return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
        // StringValue
        case 34:
          if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            return readBlockString(lexer, position);
          }
          return readString(lexer, position);
      }
      if (isDigit(code) || code === 45) {
        return readNumber(lexer, position, code);
      }
      if (isNameStart(code)) {
        return readName(lexer, position);
      }
      throw syntaxError(
        lexer.source,
        position,
        code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
      );
    }
    return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.COMMENT,
      start,
      position,
      body.slice(start + 1, position)
    );
  }
  function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if (isDigit(code)) {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid number, unexpected digit after 0: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    } else {
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || isNameStart(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
    return createToken(
      lexer,
      isFloat ? TokenKind.FLOAT : TokenKind.INT,
      start,
      position,
      body.slice(start, position)
    );
  }
  function readDigits(lexer, start, firstCode) {
    if (!isDigit(firstCode)) {
      throw syntaxError(
        lexer.source,
        start,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          start
        )}.`
      );
    }
    const body = lexer.source.body;
    let position = start + 1;
    while (isDigit(body.charCodeAt(position))) {
      ++position;
    }
    return position;
  }
  function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return createToken(lexer, TokenKind.STRING, start, position + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position);
        const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
        value += escape.value;
        position += escape.size;
        chunkStart = position;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3;
    while (size < 12) {
      const code = body.charCodeAt(position + size++);
      if (code === 125) {
        if (size < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(
        position,
        position + size
      )}".`
    );
  }
  function readEscapedUnicodeFixedWidth(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
    );
  }
  function read16BitHexCode(body, position) {
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: "\n",
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid character escape sequence: "${body.slice(
        position,
        position + 2
      )}".`
    );
  }
  function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        const token = createToken(
          lexer,
          TokenKind.BLOCK_STRING,
          start,
          position + 3,
          // Return a string of the lines joined with U+000A.
          dedentBlockStringLines(blockLines).join("\n")
        );
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        currentLine += body.slice(chunkStart, position);
        chunkStart = position + 1;
        position += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        currentLine = "";
        chunkStart = position;
        lineStart = position;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (isNameContinue(code)) {
        ++position;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.NAME,
      start,
      position,
      body.slice(start, position)
    );
  }

  // node_modules/graphql/jsutils/inspect.mjs
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(
      ([key, value]) => key + ": " + formatValue(value, seenValues)
    );
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i = 0; i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name2 = object.constructor.name;
      if (typeof name2 === "string" && name2 !== "") {
        return name2;
      }
    }
    return tag;
  }

  // node_modules/graphql/jsutils/instanceOf.mjs
  var isProduction = globalThis.process && // eslint-disable-next-line no-undef
  false;
  var instanceOf = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    isProduction ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    }
  );

  // node_modules/graphql/language/source.mjs
  var Source = class {
    constructor(body, name2 = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
      this.body = body;
      this.name = name2;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || devAssert(
        false,
        "line in locationOffset is 1-indexed and must be positive."
      );
      this.locationOffset.column > 0 || devAssert(
        false,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  };
  function isSource(source) {
    return instanceOf(source, Source);
  }

  // node_modules/graphql/language/parser.mjs
  function parse(source, options) {
    const parser = new Parser(source, options);
    const document2 = parser.parseDocument();
    Object.defineProperty(document2, "tokenCount", {
      enumerable: false,
      value: parser.tokenCount
    });
    return document2;
  }
  function parseValue(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(TokenKind.SOF);
    const value = parser.parseValueLiteral(false);
    parser.expectToken(TokenKind.EOF);
    return value;
  }
  var Parser = class {
    constructor(source, options = {}) {
      const { lexer, ..._options } = options;
      if (lexer) {
        this._lexer = lexer;
      } else {
        const sourceObj = isSource(source) ? source : new Source(source);
        this._lexer = new Lexer(sourceObj);
      }
      this._options = _options;
      this._tokenCounter = 0;
    }
    get tokenCount() {
      return this._tokenCounter;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const token = this.expectToken(TokenKind.NAME);
      return this.node(token, {
        kind: Kind.NAME,
        value: token.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: Kind.DOCUMENT,
        definitions: this.many(
          TokenKind.SOF,
          this.parseDefinition,
          TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (hasDescription && keywordToken.kind === TokenKind.BRACE_L) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are not supported on shorthand queries."
        );
      }
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
        }
        if (hasDescription) {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, only GraphQL definitions support descriptions."
          );
        }
        switch (keywordToken.value) {
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const start = this._lexer.token;
      if (this.peek(TokenKind.BRACE_L)) {
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation: OperationTypeNode.QUERY,
          description: void 0,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const description = this.parseDescription();
      const operation = this.parseOperationType();
      let name2;
      if (this.peek(TokenKind.NAME)) {
        name2 = this.parseName();
      }
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        description,
        name: name2,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const operationToken = this.expectToken(TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return OperationTypeNode.QUERY;
        case "mutation":
          return OperationTypeNode.MUTATION;
        case "subscription":
          return OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseVariableDefinition,
        TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: Kind.VARIABLE_DEFINITION,
        description: this.parseDescription(),
        variable: this.parseVariable(),
        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.DOLLAR);
      return this.node(start, {
        kind: Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: Kind.SELECTION_SET,
        selections: this.many(
          TokenKind.BRACE_L,
          this.parseSelection,
          TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const start = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name2;
      if (this.expectOptionalToken(TokenKind.COLON)) {
        alias = nameOrAlias;
        name2 = this.parseName();
      } else {
        name2 = nameOrAlias;
      }
      return this.node(start, {
        kind: Kind.FIELD,
        alias,
        name: name2,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(isConst = false) {
      const start = this._lexer.token;
      const name2 = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.ARGUMENT,
        name: name2,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
        return this.node(start, {
          kind: Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start, {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("fragment");
      if (this._options.allowLegacyFragmentVariables === true) {
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          description,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        description,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(isConst) {
      const token = this._lexer.token;
      switch (token.kind) {
        case TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case TokenKind.INT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.INT,
            value: token.value
          });
        case TokenKind.FLOAT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.FLOAT,
            value: token.value
          });
        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case TokenKind.NAME:
          this.advanceLexer();
          switch (token.value) {
            case "true":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token, {
                kind: Kind.NULL
              });
            default:
              return this.node(token, {
                kind: Kind.ENUM,
                value: token.value
              });
          }
        case TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(TokenKind.DOLLAR);
            if (this._lexer.token.kind === TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw syntaxError(
                this._lexer.source,
                token.start,
                `Unexpected variable "$${varName}" in constant value.`
              );
            } else {
              throw this.unexpected(token);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token = this._lexer.token;
      this.advanceLexer();
      return this.node(token, {
        kind: Kind.STRING,
        value: token.value,
        block: token.kind === TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.LIST,
        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.OBJECT,
        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(isConst) {
      const start = this._lexer.token;
      const name2 = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.OBJECT_FIELD,
        name: name2,
        value: this.parseValueLiteral(isConst)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(isConst) {
      const start = this._lexer.token;
      this.expectToken(TokenKind.AT);
      return this.node(start, {
        kind: Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const start = this._lexer.token;
      let type2;
      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(TokenKind.BRACKET_R);
        type2 = this.node(start, {
          kind: Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type2 = this.parseNamedType();
      }
      if (this.expectOptionalToken(TokenKind.BANG)) {
        return this.node(start, {
          kind: Kind.NON_NULL_TYPE,
          type: type2
        });
      }
      return type2;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      return this.node(start, {
        kind: Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const start = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(TokenKind.COLON);
      const type2 = this.parseNamedType();
      return this.node(start, {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type: type2
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description,
        name: name2,
        directives
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name2 = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description,
        name: name2,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseFieldDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name2 = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(TokenKind.COLON);
      const type2 = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.FIELD_DEFINITION,
        description,
        name: name2,
        arguments: args,
        type: type2,
        directives
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseInputValueDef,
        TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name2 = this.parseName();
      this.expectToken(TokenKind.COLON);
      const type2 = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description,
        name: name2,
        type: type2,
        defaultValue,
        directives
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name2 = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name: name2,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      return this.node(start, {
        kind: Kind.UNION_TYPE_DEFINITION,
        description,
        name: name2,
        directives,
        types
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      return this.node(start, {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description,
        name: name2,
        directives,
        values
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name2 = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description,
        name: name2,
        directives
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          `${getTokenDesc(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      }
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name: name2,
        directives,
        fields
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseInputValueDef,
        TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name: name2,
        directives
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name2 = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name: name2,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name2 = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name: name2,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      if (directives.length === 0 && types.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.UNION_TYPE_EXTENSION,
        name: name2,
        directives,
        types
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name: name2,
        directives,
        values
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name2 = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name: name2,
        directives,
        fields
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(TokenKind.AT);
      const name2 = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start, {
        kind: Kind.DIRECTIVE_DEFINITION,
        description,
        name: name2,
        arguments: args,
        repeatable,
        locations
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const start = this._lexer.token;
      const name2 = this.parseName();
      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name2.value)) {
        return name2;
      }
      throw this.unexpected(start);
    }
    // Schema Coordinates
    /**
     * SchemaCoordinate :
     *   - Name
     *   - Name . Name
     *   - Name . Name ( Name : )
     *   - \@ Name
     *   - \@ Name ( Name : )
     */
    parseSchemaCoordinate() {
      const start = this._lexer.token;
      const ofDirective = this.expectOptionalToken(TokenKind.AT);
      const name2 = this.parseName();
      let memberName;
      if (!ofDirective && this.expectOptionalToken(TokenKind.DOT)) {
        memberName = this.parseName();
      }
      let argumentName;
      if ((ofDirective || memberName) && this.expectOptionalToken(TokenKind.PAREN_L)) {
        argumentName = this.parseName();
        this.expectToken(TokenKind.COLON);
        this.expectToken(TokenKind.PAREN_R);
      }
      if (ofDirective) {
        if (argumentName) {
          return this.node(start, {
            kind: Kind.DIRECTIVE_ARGUMENT_COORDINATE,
            name: name2,
            argumentName
          });
        }
        return this.node(start, {
          kind: Kind.DIRECTIVE_COORDINATE,
          name: name2
        });
      } else if (memberName) {
        if (argumentName) {
          return this.node(start, {
            kind: Kind.ARGUMENT_COORDINATE,
            name: name2,
            fieldName: memberName,
            argumentName
          });
        }
        return this.node(start, {
          kind: Kind.MEMBER_COORDINATE,
          name: name2,
          memberName
        });
      }
      return this.node(start, {
        kind: Kind.TYPE_COORDINATE,
        name: name2
      });
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(startToken, node) {
      if (this._options.noLocation !== true) {
        node.loc = new Location(
          startToken,
          this._lexer.lastToken,
          this._lexer.source
        );
      }
      return node;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(kind) {
      return this._lexer.token.kind === kind;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return token;
      }
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
      } else {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected "${value}", found ${getTokenDesc(token)}.`
        );
      }
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(atToken) {
      const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
      return syntaxError(
        this._lexer.source,
        token.start,
        `Unexpected ${getTokenDesc(token)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
    advanceLexer() {
      const { maxTokens } = this._options;
      const token = this._lexer.advance();
      if (token.kind !== TokenKind.EOF) {
        ++this._tokenCounter;
        if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Document contains more that ${maxTokens} tokens. Parsing aborted.`
          );
        }
      }
    }
  };
  function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
  }

  // node_modules/graphql/jsutils/didYouMean.mjs
  var MAX_SUGGESTIONS = 5;
  function didYouMean(firstArg, secondArg) {
    const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
    let message = " Did you mean ";
    if (subMessage) {
      message += subMessage + " ";
    }
    const suggestions = suggestionsArg.map((x2) => `"${x2}"`);
    switch (suggestions.length) {
      case 0:
        return "";
      case 1:
        return message + suggestions[0] + "?";
      case 2:
        return message + suggestions[0] + " or " + suggestions[1] + "?";
    }
    const selected = suggestions.slice(0, MAX_SUGGESTIONS);
    const lastItem = selected.pop();
    return message + selected.join(", ") + ", or " + lastItem + "?";
  }

  // node_modules/graphql/jsutils/identityFunc.mjs
  function identityFunc(x2) {
    return x2;
  }

  // node_modules/graphql/jsutils/keyMap.mjs
  function keyMap(list2, keyFn) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const item of list2) {
      result[keyFn(item)] = item;
    }
    return result;
  }

  // node_modules/graphql/jsutils/keyValMap.mjs
  function keyValMap(list2, keyFn, valFn) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const item of list2) {
      result[keyFn(item)] = valFn(item);
    }
    return result;
  }

  // node_modules/graphql/jsutils/mapValue.mjs
  function mapValue(map, fn) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const key of Object.keys(map)) {
      result[key] = fn(map[key], key);
    }
    return result;
  }

  // node_modules/graphql/jsutils/naturalCompare.mjs
  function naturalCompare(aStr, bStr) {
    let aIndex = 0;
    let bIndex = 0;
    while (aIndex < aStr.length && bIndex < bStr.length) {
      let aChar = aStr.charCodeAt(aIndex);
      let bChar = bStr.charCodeAt(bIndex);
      if (isDigit2(aChar) && isDigit2(bChar)) {
        let aNum = 0;
        do {
          ++aIndex;
          aNum = aNum * 10 + aChar - DIGIT_0;
          aChar = aStr.charCodeAt(aIndex);
        } while (isDigit2(aChar) && aNum > 0);
        let bNum = 0;
        do {
          ++bIndex;
          bNum = bNum * 10 + bChar - DIGIT_0;
          bChar = bStr.charCodeAt(bIndex);
        } while (isDigit2(bChar) && bNum > 0);
        if (aNum < bNum) {
          return -1;
        }
        if (aNum > bNum) {
          return 1;
        }
      } else {
        if (aChar < bChar) {
          return -1;
        }
        if (aChar > bChar) {
          return 1;
        }
        ++aIndex;
        ++bIndex;
      }
    }
    return aStr.length - bStr.length;
  }
  var DIGIT_0 = 48;
  var DIGIT_9 = 57;
  function isDigit2(code) {
    return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
  }

  // node_modules/graphql/jsutils/suggestionList.mjs
  function suggestionList(input, options) {
    const optionsByDistance = /* @__PURE__ */ Object.create(null);
    const lexicalDistance2 = new LexicalDistance(input);
    const threshold = Math.floor(input.length * 0.4) + 1;
    for (const option of options) {
      const distance = lexicalDistance2.measure(option, threshold);
      if (distance !== void 0) {
        optionsByDistance[option] = distance;
      }
    }
    return Object.keys(optionsByDistance).sort((a, b2) => {
      const distanceDiff = optionsByDistance[a] - optionsByDistance[b2];
      return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b2);
    });
  }
  var LexicalDistance = class {
    constructor(input) {
      this._input = input;
      this._inputLowerCase = input.toLowerCase();
      this._inputArray = stringToArray(this._inputLowerCase);
      this._rows = [
        new Array(input.length + 1).fill(0),
        new Array(input.length + 1).fill(0),
        new Array(input.length + 1).fill(0)
      ];
    }
    measure(option, threshold) {
      if (this._input === option) {
        return 0;
      }
      const optionLowerCase = option.toLowerCase();
      if (this._inputLowerCase === optionLowerCase) {
        return 1;
      }
      let a = stringToArray(optionLowerCase);
      let b2 = this._inputArray;
      if (a.length < b2.length) {
        const tmp = a;
        a = b2;
        b2 = tmp;
      }
      const aLength = a.length;
      const bLength = b2.length;
      if (aLength - bLength > threshold) {
        return void 0;
      }
      const rows = this._rows;
      for (let j2 = 0; j2 <= bLength; j2++) {
        rows[0][j2] = j2;
      }
      for (let i = 1; i <= aLength; i++) {
        const upRow = rows[(i - 1) % 3];
        const currentRow = rows[i % 3];
        let smallestCell = currentRow[0] = i;
        for (let j2 = 1; j2 <= bLength; j2++) {
          const cost = a[i - 1] === b2[j2 - 1] ? 0 : 1;
          let currentCell = Math.min(
            upRow[j2] + 1,
            // delete
            currentRow[j2 - 1] + 1,
            // insert
            upRow[j2 - 1] + cost
            // substitute
          );
          if (i > 1 && j2 > 1 && a[i - 1] === b2[j2 - 2] && a[i - 2] === b2[j2 - 1]) {
            const doubleDiagonalCell = rows[(i - 2) % 3][j2 - 2];
            currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
          }
          if (currentCell < smallestCell) {
            smallestCell = currentCell;
          }
          currentRow[j2] = currentCell;
        }
        if (smallestCell > threshold) {
          return void 0;
        }
      }
      const distance = rows[aLength % 3][bLength];
      return distance <= threshold ? distance : void 0;
    }
  };
  function stringToArray(str) {
    const strLength = str.length;
    const array = new Array(strLength);
    for (let i = 0; i < strLength; ++i) {
      array[i] = str.charCodeAt(i);
    }
    return array;
  }

  // node_modules/graphql/jsutils/toObjMap.mjs
  function toObjMap(obj) {
    if (obj == null) {
      return /* @__PURE__ */ Object.create(null);
    }
    if (Object.getPrototypeOf(obj) === null) {
      return obj;
    }
    const map = /* @__PURE__ */ Object.create(null);
    for (const [key, value] of Object.entries(obj)) {
      map[key] = value;
    }
    return map;
  }

  // node_modules/graphql/language/printString.mjs
  function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  }
  var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
  }
  var escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 2F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 3F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 4F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    // 5F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 6F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];

  // node_modules/graphql/language/visitor.mjs
  var BREAK = Object.freeze({});
  function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
    const enterLeaveMap = /* @__PURE__ */ new Map();
    for (const kind of Object.values(Kind)) {
      enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    let stack = void 0;
    let inArray = Array.isArray(root);
    let keys = [root];
    let index = -1;
    let edits = [];
    let node = root;
    let key = void 0;
    let parent = void 0;
    const path = [];
    const ancestors = [];
    do {
      index++;
      const isLeaving = index === keys.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path[path.length - 1];
        node = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node.splice(arrayKey, 1);
                editOffset++;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            node = { ...node };
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index : keys[index];
        node = parent[key];
        if (node === null || node === void 0) {
          continue;
        }
        path.push(key);
      }
      let result;
      if (!Array.isArray(node)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
        result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result === void 0 && isEdited) {
        edits.push([key, node]);
      }
      if (isLeaving) {
        path.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
        index = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root;
  }
  function visitInParallel(visitors) {
    const skipping = new Array(visitors.length).fill(null);
    const mergedVisitor = /* @__PURE__ */ Object.create(null);
    for (const kind of Object.values(Kind)) {
      let hasVisitor = false;
      const enterList = new Array(visitors.length).fill(void 0);
      const leaveList = new Array(visitors.length).fill(void 0);
      for (let i = 0; i < visitors.length; ++i) {
        const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
        hasVisitor || (hasVisitor = enter != null || leave != null);
        enterList[i] = enter;
        leaveList[i] = leave;
      }
      if (!hasVisitor) {
        continue;
      }
      const mergedEnterLeave = {
        enter(...args) {
          const node = args[0];
          for (let i = 0; i < visitors.length; i++) {
            if (skipping[i] === null) {
              var _enterList$i;
              const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
              if (result === false) {
                skipping[i] = node;
              } else if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== void 0) {
                return result;
              }
            }
          }
        },
        leave(...args) {
          const node = args[0];
          for (let i = 0; i < visitors.length; i++) {
            if (skipping[i] === null) {
              var _leaveList$i;
              const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
              if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== void 0 && result !== false) {
                return result;
              }
            } else if (skipping[i] === node) {
              skipping[i] = null;
            }
          }
        }
      };
      mergedVisitor[kind] = mergedEnterLeave;
    }
    return mergedVisitor;
  }
  function getEnterLeaveForKind(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: void 0
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  }

  // node_modules/graphql/language/printer.mjs
  function print(ast) {
    return visit(ast, printDocASTReducer);
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: {
      leave: (node) => node.value
    },
    Variable: {
      leave: (node) => "$" + node.name
    },
    // Document
    Document: {
      leave: (node) => join2(node.definitions, "\n\n")
    },
    OperationDefinition: {
      leave(node) {
        const varDefs = hasMultilineItems(node.variableDefinitions) ? wrap("(\n", join2(node.variableDefinitions, "\n"), "\n)") : wrap("(", join2(node.variableDefinitions, ", "), ")");
        const prefix = wrap("", node.description, "\n") + join2(
          [
            node.operation,
            join2([node.name, varDefs]),
            join2(node.directives, " ")
          ],
          " "
        );
        return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type: type2, defaultValue, directives, description }) => wrap("", description, "\n") + variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join2(directives, " "))
    },
    SelectionSet: {
      leave: ({ selections }) => block(selections)
    },
    Field: {
      leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
        const prefix = wrap("", alias, ": ") + name2;
        let argsLine = prefix + wrap("(", join2(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
        }
        return join2([argsLine, join2(directives, " "), selectionSet], " ");
      }
    },
    Argument: {
      leave: ({ name: name2, value }) => name2 + ": " + value
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name: name2, directives }) => "..." + name2 + wrap(" ", join2(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join2(
        [
          "...",
          wrap("on ", typeCondition),
          join2(directives, " "),
          selectionSet
        ],
        " "
      )
    },
    FragmentDefinition: {
      leave: ({
        name: name2,
        typeCondition,
        variableDefinitions,
        directives,
        selectionSet,
        description
      }) => wrap("", description, "\n") + // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      `fragment ${name2}${wrap("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join2(directives, " "), " ")}` + selectionSet
    },
    // Value
    IntValue: {
      leave: ({ value }) => value
    },
    FloatValue: {
      leave: ({ value }) => value
    },
    StringValue: {
      leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
    },
    BooleanValue: {
      leave: ({ value }) => value ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value }) => value
    },
    ListValue: {
      leave: ({ values }) => "[" + join2(values, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields }) => "{" + join2(fields, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name: name2, value }) => name2 + ": " + value
    },
    // Directive
    Directive: {
      leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join2(args, ", "), ")")
    },
    // Type
    NamedType: {
      leave: ({ name: name2 }) => name2
    },
    ListType: {
      leave: ({ type: type2 }) => "[" + type2 + "]"
    },
    NonNullType: {
      leave: ({ type: type2 }) => type2 + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join2(["schema", join2(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type: type2 }) => operation + ": " + type2
    },
    ScalarTypeDefinition: {
      leave: ({ description, name: name2, directives }) => wrap("", description, "\n") + join2(["scalar", name2, join2(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description, name: name2, interfaces, directives, fields }) => wrap("", description, "\n") + join2(
        [
          "type",
          name2,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    FieldDefinition: {
      leave: ({ description, name: name2, arguments: args, type: type2, directives }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type2 + wrap(" ", join2(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ description, name: name2, type: type2, defaultValue, directives }) => wrap("", description, "\n") + join2(
        [name2 + ": " + type2, wrap("= ", defaultValue), join2(directives, " ")],
        " "
      )
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name: name2, interfaces, directives, fields }) => wrap("", description, "\n") + join2(
        [
          "interface",
          name2,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeDefinition: {
      leave: ({ description, name: name2, directives, types }) => wrap("", description, "\n") + join2(
        ["union", name2, join2(directives, " "), wrap("= ", join2(types, " | "))],
        " "
      )
    },
    EnumTypeDefinition: {
      leave: ({ description, name: name2, directives, values }) => wrap("", description, "\n") + join2(["enum", name2, join2(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description, name: name2, directives }) => wrap("", description, "\n") + join2([name2, join2(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name: name2, directives, fields }) => wrap("", description, "\n") + join2(["input", name2, join2(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join2(
        ["extend schema", join2(directives, " "), block(operationTypes)],
        " "
      )
    },
    ScalarTypeExtension: {
      leave: ({ name: name2, directives }) => join2(["extend scalar", name2, join2(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name: name2, interfaces, directives, fields }) => join2(
        [
          "extend type",
          name2,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    InterfaceTypeExtension: {
      leave: ({ name: name2, interfaces, directives, fields }) => join2(
        [
          "extend interface",
          name2,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeExtension: {
      leave: ({ name: name2, directives, types }) => join2(
        [
          "extend union",
          name2,
          join2(directives, " "),
          wrap("= ", join2(types, " | "))
        ],
        " "
      )
    },
    EnumTypeExtension: {
      leave: ({ name: name2, directives, values }) => join2(["extend enum", name2, join2(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name: name2, directives, fields }) => join2(["extend input", name2, join2(directives, " "), block(fields)], " ")
    },
    // Schema Coordinates
    TypeCoordinate: {
      leave: ({ name: name2 }) => name2
    },
    MemberCoordinate: {
      leave: ({ name: name2, memberName }) => join2([name2, wrap(".", memberName)])
    },
    ArgumentCoordinate: {
      leave: ({ name: name2, fieldName, argumentName }) => join2([name2, wrap(".", fieldName), wrap("(", argumentName, ":)")])
    },
    DirectiveCoordinate: {
      leave: ({ name: name2 }) => join2(["@", name2])
    },
    DirectiveArgumentCoordinate: {
      leave: ({ name: name2, argumentName }) => join2(["@", name2, wrap("(", argumentName, ":)")])
    }
  };
  function join2(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
  }
  function block(array) {
    return wrap("{\n", indent(join2(array, "\n")), "\n}");
  }
  function wrap(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap("  ", str.replace(/\n/g, "\n  "));
  }
  function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
  }

  // node_modules/graphql/utilities/valueFromASTUntyped.mjs
  function valueFromASTUntyped(valueNode, variables) {
    switch (valueNode.kind) {
      case Kind.NULL:
        return null;
      case Kind.INT:
        return parseInt(valueNode.value, 10);
      case Kind.FLOAT:
        return parseFloat(valueNode.value);
      case Kind.STRING:
      case Kind.ENUM:
      case Kind.BOOLEAN:
        return valueNode.value;
      case Kind.LIST:
        return valueNode.values.map(
          (node) => valueFromASTUntyped(node, variables)
        );
      case Kind.OBJECT:
        return keyValMap(
          valueNode.fields,
          (field) => field.name.value,
          (field) => valueFromASTUntyped(field.value, variables)
        );
      case Kind.VARIABLE:
        return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
    }
  }

  // node_modules/graphql/type/assertName.mjs
  function assertName(name2) {
    name2 != null || devAssert(false, "Must provide name.");
    typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
    if (name2.length === 0) {
      throw new GraphQLError("Expected name to be a non-empty string.");
    }
    for (let i = 1; i < name2.length; ++i) {
      if (!isNameContinue(name2.charCodeAt(i))) {
        throw new GraphQLError(
          `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
        );
      }
    }
    if (!isNameStart(name2.charCodeAt(0))) {
      throw new GraphQLError(
        `Names must start with [_a-zA-Z] but "${name2}" does not.`
      );
    }
    return name2;
  }
  function assertEnumValueName(name2) {
    if (name2 === "true" || name2 === "false" || name2 === "null") {
      throw new GraphQLError(`Enum values cannot be named: ${name2}`);
    }
    return assertName(name2);
  }

  // node_modules/graphql/type/definition.mjs
  function isType(type2) {
    return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
  }
  function isScalarType(type2) {
    return instanceOf(type2, GraphQLScalarType);
  }
  function isObjectType(type2) {
    return instanceOf(type2, GraphQLObjectType);
  }
  function assertObjectType(type2) {
    if (!isObjectType(type2)) {
      throw new Error(`Expected ${inspect(type2)} to be a GraphQL Object type.`);
    }
    return type2;
  }
  function isInterfaceType(type2) {
    return instanceOf(type2, GraphQLInterfaceType);
  }
  function assertInterfaceType(type2) {
    if (!isInterfaceType(type2)) {
      throw new Error(
        `Expected ${inspect(type2)} to be a GraphQL Interface type.`
      );
    }
    return type2;
  }
  function isUnionType(type2) {
    return instanceOf(type2, GraphQLUnionType);
  }
  function isEnumType(type2) {
    return instanceOf(type2, GraphQLEnumType);
  }
  function isInputObjectType(type2) {
    return instanceOf(type2, GraphQLInputObjectType);
  }
  function isListType(type2) {
    return instanceOf(type2, GraphQLList);
  }
  function isNonNullType(type2) {
    return instanceOf(type2, GraphQLNonNull);
  }
  function isInputType(type2) {
    return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
  }
  function isOutputType(type2) {
    return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
  }
  function isLeafType(type2) {
    return isScalarType(type2) || isEnumType(type2);
  }
  function isCompositeType(type2) {
    return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
  }
  function isAbstractType(type2) {
    return isInterfaceType(type2) || isUnionType(type2);
  }
  function assertAbstractType(type2) {
    if (!isAbstractType(type2)) {
      throw new Error(`Expected ${inspect(type2)} to be a GraphQL abstract type.`);
    }
    return type2;
  }
  var GraphQLList = class {
    constructor(ofType) {
      isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
      this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLList";
    }
    toString() {
      return "[" + String(this.ofType) + "]";
    }
    toJSON() {
      return this.toString();
    }
  };
  var GraphQLNonNull = class {
    constructor(ofType) {
      isNullableType(ofType) || devAssert(
        false,
        `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
      );
      this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLNonNull";
    }
    toString() {
      return String(this.ofType) + "!";
    }
    toJSON() {
      return this.toString();
    }
  };
  function isWrappingType(type2) {
    return isListType(type2) || isNonNullType(type2);
  }
  function isNullableType(type2) {
    return isType(type2) && !isNonNullType(type2);
  }
  function assertNullableType(type2) {
    if (!isNullableType(type2)) {
      throw new Error(`Expected ${inspect(type2)} to be a GraphQL nullable type.`);
    }
    return type2;
  }
  function getNullableType(type2) {
    if (type2) {
      return isNonNullType(type2) ? type2.ofType : type2;
    }
  }
  function isNamedType(type2) {
    return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);
  }
  function getNamedType(type2) {
    if (type2) {
      let unwrappedType = type2;
      while (isWrappingType(unwrappedType)) {
        unwrappedType = unwrappedType.ofType;
      }
      return unwrappedType;
    }
  }
  function resolveReadonlyArrayThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  }
  function resolveObjMapThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  }
  var GraphQLScalarType = class {
    constructor(config) {
      var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
      const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
      this.name = assertName(config.name);
      this.description = config.description;
      this.specifiedByURL = config.specifiedByURL;
      this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
      this.parseValue = parseValue2;
      this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
      config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
        false,
        `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
      );
      config.serialize == null || typeof config.serialize === "function" || devAssert(
        false,
        `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
      );
      if (config.parseLiteral) {
        typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
          false,
          `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
        );
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLScalarType";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        specifiedByURL: this.specifiedByURL,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  };
  var GraphQLObjectType = class {
    constructor(config) {
      var _config$extensionASTN2;
      this.name = assertName(config.name);
      this.description = config.description;
      this.isTypeOf = config.isTypeOf;
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
      this._fields = () => defineFieldMap(config);
      this._interfaces = () => defineInterfaces(config);
      config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
        false,
        `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLObjectType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  };
  function defineInterfaces(config) {
    var _config$interfaces;
    const interfaces = resolveReadonlyArrayThunk(
      (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
    );
    Array.isArray(interfaces) || devAssert(
      false,
      `${config.name} interfaces must be an Array or a function which returns an Array.`
    );
    return interfaces;
  }
  function defineFieldMap(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || devAssert(
      false,
      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
    );
    return mapValue(fieldMap, (fieldConfig, fieldName) => {
      var _fieldConfig$args;
      isPlainObj(fieldConfig) || devAssert(
        false,
        `${config.name}.${fieldName} field config must be an object.`
      );
      fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
        false,
        `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
      );
      const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
      isPlainObj(argsConfig) || devAssert(
        false,
        `${config.name}.${fieldName} args must be an object with argument names as keys.`
      );
      return {
        name: assertName(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        args: defineArguments(argsConfig),
        resolve: fieldConfig.resolve,
        subscribe: fieldConfig.subscribe,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: toObjMap(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function defineArguments(config) {
    return Object.entries(config).map(([argName, argConfig]) => ({
      name: assertName(argName),
      description: argConfig.description,
      type: argConfig.type,
      defaultValue: argConfig.defaultValue,
      deprecationReason: argConfig.deprecationReason,
      extensions: toObjMap(argConfig.extensions),
      astNode: argConfig.astNode
    }));
  }
  function isPlainObj(obj) {
    return isObjectLike(obj) && !Array.isArray(obj);
  }
  function fieldsToFieldsConfig(fields) {
    return mapValue(fields, (field) => ({
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
  }
  function argsToArgsConfig(args) {
    return keyValMap(
      args,
      (arg) => arg.name,
      (arg) => ({
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        deprecationReason: arg.deprecationReason,
        extensions: arg.extensions,
        astNode: arg.astNode
      })
    );
  }
  function isRequiredArgument(arg) {
    return isNonNullType(arg.type) && arg.defaultValue === void 0;
  }
  var GraphQLInterfaceType = class {
    constructor(config) {
      var _config$extensionASTN3;
      this.name = assertName(config.name);
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
      this._fields = defineFieldMap.bind(void 0, config);
      this._interfaces = defineInterfaces.bind(void 0, config);
      config.resolveType == null || typeof config.resolveType === "function" || devAssert(
        false,
        `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInterfaceType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  };
  var GraphQLUnionType = class {
    constructor(config) {
      var _config$extensionASTN4;
      this.name = assertName(config.name);
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
      this._types = defineTypes.bind(void 0, config);
      config.resolveType == null || typeof config.resolveType === "function" || devAssert(
        false,
        `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLUnionType";
    }
    getTypes() {
      if (typeof this._types === "function") {
        this._types = this._types();
      }
      return this._types;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  };
  function defineTypes(config) {
    const types = resolveReadonlyArrayThunk(config.types);
    Array.isArray(types) || devAssert(
      false,
      `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
    );
    return types;
  }
  var GraphQLEnumType = class {
    /* <T> */
    constructor(config) {
      var _config$extensionASTN5;
      this.name = assertName(config.name);
      this.description = config.description;
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
      this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
      this._valueLookup = null;
      this._nameLookup = null;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLEnumType";
    }
    getValues() {
      if (typeof this._values === "function") {
        this._values = defineEnumValues(this.name, this._values());
      }
      return this._values;
    }
    getValue(name2) {
      if (this._nameLookup === null) {
        this._nameLookup = keyMap(this.getValues(), (value) => value.name);
      }
      return this._nameLookup[name2];
    }
    serialize(outputValue) {
      if (this._valueLookup === null) {
        this._valueLookup = new Map(
          this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
        );
      }
      const enumValue = this._valueLookup.get(outputValue);
      if (enumValue === void 0) {
        throw new GraphQLError(
          `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
        );
      }
      return enumValue.name;
    }
    parseValue(inputValue) {
      if (typeof inputValue !== "string") {
        const valueStr = inspect(inputValue);
        throw new GraphQLError(
          `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
        );
      }
      const enumValue = this.getValue(inputValue);
      if (enumValue == null) {
        throw new GraphQLError(
          `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
        );
      }
      return enumValue.value;
    }
    parseLiteral(valueNode, _variables) {
      if (valueNode.kind !== Kind.ENUM) {
        const valueStr = print(valueNode);
        throw new GraphQLError(
          `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
          {
            nodes: valueNode
          }
        );
      }
      const enumValue = this.getValue(valueNode.value);
      if (enumValue == null) {
        const valueStr = print(valueNode);
        throw new GraphQLError(
          `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
          {
            nodes: valueNode
          }
        );
      }
      return enumValue.value;
    }
    toConfig() {
      const values = keyValMap(
        this.getValues(),
        (value) => value.name,
        (value) => ({
          description: value.description,
          value: value.value,
          deprecationReason: value.deprecationReason,
          extensions: value.extensions,
          astNode: value.astNode
        })
      );
      return {
        name: this.name,
        description: this.description,
        values,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  };
  function didYouMeanEnumValue(enumType, unknownValueStr) {
    const allNames = enumType.getValues().map((value) => value.name);
    const suggestedValues = suggestionList(unknownValueStr, allNames);
    return didYouMean("the enum value", suggestedValues);
  }
  function defineEnumValues(typeName, valueMap) {
    isPlainObj(valueMap) || devAssert(
      false,
      `${typeName} values must be an object with value names as keys.`
    );
    return Object.entries(valueMap).map(([valueName, valueConfig]) => {
      isPlainObj(valueConfig) || devAssert(
        false,
        `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
      );
      return {
        name: assertEnumValueName(valueName),
        description: valueConfig.description,
        value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
        deprecationReason: valueConfig.deprecationReason,
        extensions: toObjMap(valueConfig.extensions),
        astNode: valueConfig.astNode
      };
    });
  }
  var GraphQLInputObjectType = class {
    constructor(config) {
      var _config$extensionASTN6, _config$isOneOf;
      this.name = assertName(config.name);
      this.description = config.description;
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
      this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
      this._fields = defineInputFieldMap.bind(void 0, config);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInputObjectType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    toConfig() {
      const fields = mapValue(this.getFields(), (field) => ({
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        fields,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        isOneOf: this.isOneOf
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  };
  function defineInputFieldMap(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || devAssert(
      false,
      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
    );
    return mapValue(fieldMap, (fieldConfig, fieldName) => {
      !("resolve" in fieldConfig) || devAssert(
        false,
        `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
      );
      return {
        name: assertName(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        defaultValue: fieldConfig.defaultValue,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: toObjMap(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function isRequiredInputField(field) {
    return isNonNullType(field.type) && field.defaultValue === void 0;
  }

  // node_modules/graphql/utilities/typeComparators.mjs
  function isEqualType(typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if (isNonNullType(typeA) && isNonNullType(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    if (isListType(typeA) && isListType(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    return false;
  }
  function isTypeSubTypeOf(schema, maybeSubType, superType) {
    if (maybeSubType === superType) {
      return true;
    }
    if (isNonNullType(superType)) {
      if (isNonNullType(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
    }
    if (isListType(superType)) {
      if (isListType(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if (isListType(maybeSubType)) {
      return false;
    }
    return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
  }
  function doTypesOverlap(schema, typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if (isAbstractType(typeA)) {
      if (isAbstractType(typeB)) {
        return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
      }
      return schema.isSubType(typeA, typeB);
    }
    if (isAbstractType(typeB)) {
      return schema.isSubType(typeB, typeA);
    }
    return false;
  }

  // node_modules/graphql/type/scalars.mjs
  var GRAPHQL_MAX_INT = 2147483647;
  var GRAPHQL_MIN_INT = -2147483648;
  var GraphQLInt = new GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      let num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (typeof num !== "number" || !Number.isInteger(num)) {
        throw new GraphQLError(
          `Int cannot represent non-integer value: ${inspect(coercedValue)}`
        );
      }
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new GraphQLError(
          "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
        );
      }
      return num;
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
        throw new GraphQLError(
          `Int cannot represent non-integer value: ${inspect(inputValue)}`
        );
      }
      if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
        throw new GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${inputValue}`
        );
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.INT) {
        throw new GraphQLError(
          `Int cannot represent non-integer value: ${print(valueNode)}`,
          {
            nodes: valueNode
          }
        );
      }
      const num = parseInt(valueNode.value, 10);
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
          {
            nodes: valueNode
          }
        );
      }
      return num;
    }
  });
  var GraphQLFloat = new GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      let num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (typeof num !== "number" || !Number.isFinite(num)) {
        throw new GraphQLError(
          `Float cannot represent non numeric value: ${inspect(coercedValue)}`
        );
      }
      return num;
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
        throw new GraphQLError(
          `Float cannot represent non numeric value: ${inspect(inputValue)}`
        );
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
        throw new GraphQLError(
          `Float cannot represent non numeric value: ${print(valueNode)}`,
          valueNode
        );
      }
      return parseFloat(valueNode.value);
    }
  });
  var GraphQLString = new GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (typeof coercedValue === "boolean") {
        return coercedValue ? "true" : "false";
      }
      if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
        return coercedValue.toString();
      }
      throw new GraphQLError(
        `String cannot represent value: ${inspect(outputValue)}`
      );
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "string") {
        throw new GraphQLError(
          `String cannot represent a non string value: ${inspect(inputValue)}`
        );
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.STRING) {
        throw new GraphQLError(
          `String cannot represent a non string value: ${print(valueNode)}`,
          {
            nodes: valueNode
          }
        );
      }
      return valueNode.value;
    }
  });
  var GraphQLBoolean = new GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue;
      }
      if (Number.isFinite(coercedValue)) {
        return coercedValue !== 0;
      }
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
      );
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "boolean") {
        throw new GraphQLError(
          `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
        );
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.BOOLEAN) {
        throw new GraphQLError(
          `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
          {
            nodes: valueNode
          }
        );
      }
      return valueNode.value;
    }
  });
  var GraphQLID = new GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (Number.isInteger(coercedValue)) {
        return String(coercedValue);
      }
      throw new GraphQLError(
        `ID cannot represent value: ${inspect(outputValue)}`
      );
    },
    parseValue(inputValue) {
      if (typeof inputValue === "string") {
        return inputValue;
      }
      if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
        return inputValue.toString();
      }
      throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
        throw new GraphQLError(
          "ID cannot represent a non-string and non-integer value: " + print(valueNode),
          {
            nodes: valueNode
          }
        );
      }
      return valueNode.value;
    }
  });
  var specifiedScalarTypes = Object.freeze([
    GraphQLString,
    GraphQLInt,
    GraphQLFloat,
    GraphQLBoolean,
    GraphQLID
  ]);
  function isSpecifiedScalarType(type2) {
    return specifiedScalarTypes.some(({ name: name2 }) => type2.name === name2);
  }
  function serializeObject(outputValue) {
    if (isObjectLike(outputValue)) {
      if (typeof outputValue.valueOf === "function") {
        const valueOfResult = outputValue.valueOf();
        if (!isObjectLike(valueOfResult)) {
          return valueOfResult;
        }
      }
      if (typeof outputValue.toJSON === "function") {
        return outputValue.toJSON();
      }
    }
    return outputValue;
  }

  // node_modules/graphql/type/directives.mjs
  function isDirective(directive) {
    return instanceOf(directive, GraphQLDirective);
  }
  var GraphQLDirective = class {
    constructor(config) {
      var _config$isRepeatable, _config$args;
      this.name = assertName(config.name);
      this.description = config.description;
      this.locations = config.locations;
      this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
      const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
      isObjectLike(args) && !Array.isArray(args) || devAssert(
        false,
        `@${config.name} args must be an object with argument names as keys.`
      );
      this.args = defineArguments(args);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLDirective";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        locations: this.locations,
        args: argsToArgsConfig(this.args),
        isRepeatable: this.isRepeatable,
        extensions: this.extensions,
        astNode: this.astNode
      };
    }
    toString() {
      return "@" + this.name;
    }
    toJSON() {
      return this.toString();
    }
  };
  var GraphQLIncludeDirective = new GraphQLDirective({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
      DirectiveLocation.FIELD,
      DirectiveLocation.FRAGMENT_SPREAD,
      DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new GraphQLNonNull(GraphQLBoolean),
        description: "Included when true."
      }
    }
  });
  var GraphQLSkipDirective = new GraphQLDirective({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
      DirectiveLocation.FIELD,
      DirectiveLocation.FRAGMENT_SPREAD,
      DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new GraphQLNonNull(GraphQLBoolean),
        description: "Skipped when true."
      }
    }
  });
  var DEFAULT_DEPRECATION_REASON = "No longer supported";
  var GraphQLDeprecatedDirective = new GraphQLDirective({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
      DirectiveLocation.FIELD_DEFINITION,
      DirectiveLocation.ARGUMENT_DEFINITION,
      DirectiveLocation.INPUT_FIELD_DEFINITION,
      DirectiveLocation.ENUM_VALUE
    ],
    args: {
      reason: {
        type: GraphQLString,
        description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: DEFAULT_DEPRECATION_REASON
      }
    }
  });
  var GraphQLSpecifiedByDirective = new GraphQLDirective({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behavior of this scalar.",
    locations: [DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new GraphQLNonNull(GraphQLString),
        description: "The URL that specifies the behavior of this scalar."
      }
    }
  });
  var GraphQLOneOfDirective = new GraphQLDirective({
    name: "oneOf",
    description: "Indicates exactly one field must be supplied and this field must not be `null`.",
    locations: [DirectiveLocation.INPUT_OBJECT],
    args: {}
  });
  var specifiedDirectives = Object.freeze([
    GraphQLIncludeDirective,
    GraphQLSkipDirective,
    GraphQLDeprecatedDirective,
    GraphQLSpecifiedByDirective,
    GraphQLOneOfDirective
  ]);

  // node_modules/graphql/jsutils/isIterableObject.mjs
  function isIterableObject(maybeIterable) {
    return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
  }

  // node_modules/graphql/utilities/astFromValue.mjs
  function astFromValue(value, type2) {
    if (isNonNullType(type2)) {
      const astValue = astFromValue(value, type2.ofType);
      if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
        return null;
      }
      return astValue;
    }
    if (value === null) {
      return {
        kind: Kind.NULL
      };
    }
    if (value === void 0) {
      return null;
    }
    if (isListType(type2)) {
      const itemType = type2.ofType;
      if (isIterableObject(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValue(item, itemType);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return {
          kind: Kind.LIST,
          values: valuesNodes
        };
      }
      return astFromValue(value, itemType);
    }
    if (isInputObjectType(type2)) {
      if (!isObjectLike(value)) {
        return null;
      }
      const fieldNodes = [];
      for (const field of Object.values(type2.getFields())) {
        const fieldValue = astFromValue(value[field.name], field.type);
        if (fieldValue) {
          fieldNodes.push({
            kind: Kind.OBJECT_FIELD,
            name: {
              kind: Kind.NAME,
              value: field.name
            },
            value: fieldValue
          });
        }
      }
      return {
        kind: Kind.OBJECT,
        fields: fieldNodes
      };
    }
    if (isLeafType(type2)) {
      const serialized = type2.serialize(value);
      if (serialized == null) {
        return null;
      }
      if (typeof serialized === "boolean") {
        return {
          kind: Kind.BOOLEAN,
          value: serialized
        };
      }
      if (typeof serialized === "number" && Number.isFinite(serialized)) {
        const stringNum = String(serialized);
        return integerStringRegExp.test(stringNum) ? {
          kind: Kind.INT,
          value: stringNum
        } : {
          kind: Kind.FLOAT,
          value: stringNum
        };
      }
      if (typeof serialized === "string") {
        if (isEnumType(type2)) {
          return {
            kind: Kind.ENUM,
            value: serialized
          };
        }
        if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
          return {
            kind: Kind.INT,
            value: serialized
          };
        }
        return {
          kind: Kind.STRING,
          value: serialized
        };
      }
      throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
    }
    invariant(false, "Unexpected input type: " + inspect(type2));
  }
  var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

  // node_modules/graphql/type/introspection.mjs
  var __Schema = new GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: () => ({
      description: {
        type: GraphQLString,
        resolve: (schema) => schema.description
      },
      types: {
        description: "A list of all types supported by this server.",
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
        resolve(schema) {
          return Object.values(schema.getTypeMap());
        }
      },
      queryType: {
        description: "The type that query operations will be rooted at.",
        type: new GraphQLNonNull(__Type),
        resolve: (schema) => schema.getQueryType()
      },
      mutationType: {
        description: "If this server supports mutation, the type that mutation operations will be rooted at.",
        type: __Type,
        resolve: (schema) => schema.getMutationType()
      },
      subscriptionType: {
        description: "If this server support subscription, the type that subscription operations will be rooted at.",
        type: __Type,
        resolve: (schema) => schema.getSubscriptionType()
      },
      directives: {
        description: "A list of all directives supported by this server.",
        type: new GraphQLNonNull(
          new GraphQLList(new GraphQLNonNull(__Directive))
        ),
        resolve: (schema) => schema.getDirectives()
      }
    })
  });
  var __Directive = new GraphQLObjectType({
    name: "__Directive",
    description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
    fields: () => ({
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: (directive) => directive.name
      },
      description: {
        type: GraphQLString,
        resolve: (directive) => directive.description
      },
      isRepeatable: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: (directive) => directive.isRepeatable
      },
      locations: {
        type: new GraphQLNonNull(
          new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
        ),
        resolve: (directive) => directive.locations
      },
      args: {
        type: new GraphQLNonNull(
          new GraphQLList(new GraphQLNonNull(__InputValue))
        ),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
        }
      }
    })
  });
  var __DirectiveLocation = new GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation."
      },
      MUTATION: {
        value: DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation."
      },
      SUBSCRIPTION: {
        value: DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation."
      },
      FIELD: {
        value: DirectiveLocation.FIELD,
        description: "Location adjacent to a field."
      },
      FRAGMENT_DEFINITION: {
        value: DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition."
      },
      FRAGMENT_SPREAD: {
        value: DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread."
      },
      INLINE_FRAGMENT: {
        value: DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment."
      },
      VARIABLE_DEFINITION: {
        value: DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition."
      },
      SCHEMA: {
        value: DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition."
      },
      SCALAR: {
        value: DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition."
      },
      OBJECT: {
        value: DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition."
      },
      FIELD_DEFINITION: {
        value: DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition."
      },
      ARGUMENT_DEFINITION: {
        value: DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition."
      },
      INTERFACE: {
        value: DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition."
      },
      UNION: {
        value: DirectiveLocation.UNION,
        description: "Location adjacent to a union definition."
      },
      ENUM: {
        value: DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition."
      },
      ENUM_VALUE: {
        value: DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition."
      },
      INPUT_OBJECT: {
        value: DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition."
      },
      INPUT_FIELD_DEFINITION: {
        value: DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition."
      }
    }
  });
  var __Type = new GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: () => ({
      kind: {
        type: new GraphQLNonNull(__TypeKind),
        resolve(type2) {
          if (isScalarType(type2)) {
            return TypeKind.SCALAR;
          }
          if (isObjectType(type2)) {
            return TypeKind.OBJECT;
          }
          if (isInterfaceType(type2)) {
            return TypeKind.INTERFACE;
          }
          if (isUnionType(type2)) {
            return TypeKind.UNION;
          }
          if (isEnumType(type2)) {
            return TypeKind.ENUM;
          }
          if (isInputObjectType(type2)) {
            return TypeKind.INPUT_OBJECT;
          }
          if (isListType(type2)) {
            return TypeKind.LIST;
          }
          if (isNonNullType(type2)) {
            return TypeKind.NON_NULL;
          }
          invariant(false, `Unexpected type: "${inspect(type2)}".`);
        }
      },
      name: {
        type: GraphQLString,
        resolve: (type2) => "name" in type2 ? type2.name : void 0
      },
      description: {
        type: GraphQLString,
        resolve: (type2) => (
          /* c8 ignore next */
          "description" in type2 ? type2.description : void 0
        )
      },
      specifiedByURL: {
        type: GraphQLString,
        resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
      },
      fields: {
        type: new GraphQLList(new GraphQLNonNull(__Field)),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type2, { includeDeprecated }) {
          if (isObjectType(type2) || isInterfaceType(type2)) {
            const fields = Object.values(type2.getFields());
            return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
          }
        }
      },
      interfaces: {
        type: new GraphQLList(new GraphQLNonNull(__Type)),
        resolve(type2) {
          if (isObjectType(type2) || isInterfaceType(type2)) {
            return type2.getInterfaces();
          }
        }
      },
      possibleTypes: {
        type: new GraphQLList(new GraphQLNonNull(__Type)),
        resolve(type2, _args, _context, { schema }) {
          if (isAbstractType(type2)) {
            return schema.getPossibleTypes(type2);
          }
        }
      },
      enumValues: {
        type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type2, { includeDeprecated }) {
          if (isEnumType(type2)) {
            const values = type2.getValues();
            return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
          }
        }
      },
      inputFields: {
        type: new GraphQLList(new GraphQLNonNull(__InputValue)),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type2, { includeDeprecated }) {
          if (isInputObjectType(type2)) {
            const values = Object.values(type2.getFields());
            return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
          }
        }
      },
      ofType: {
        type: __Type,
        resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
      },
      isOneOf: {
        type: GraphQLBoolean,
        resolve: (type2) => {
          if (isInputObjectType(type2)) {
            return type2.isOneOf;
          }
        }
      }
    })
  });
  var __Field = new GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: () => ({
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: (field) => field.name
      },
      description: {
        type: GraphQLString,
        resolve: (field) => field.description
      },
      args: {
        type: new GraphQLNonNull(
          new GraphQLList(new GraphQLNonNull(__InputValue))
        ),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
        }
      },
      type: {
        type: new GraphQLNonNull(__Type),
        resolve: (field) => field.type
      },
      isDeprecated: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: (field) => field.deprecationReason != null
      },
      deprecationReason: {
        type: GraphQLString,
        resolve: (field) => field.deprecationReason
      }
    })
  });
  var __InputValue = new GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: () => ({
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: (inputValue) => inputValue.name
      },
      description: {
        type: GraphQLString,
        resolve: (inputValue) => inputValue.description
      },
      type: {
        type: new GraphQLNonNull(__Type),
        resolve: (inputValue) => inputValue.type
      },
      defaultValue: {
        type: GraphQLString,
        description: "A GraphQL-formatted string representing the default value for this input value.",
        resolve(inputValue) {
          const { type: type2, defaultValue } = inputValue;
          const valueAST = astFromValue(defaultValue, type2);
          return valueAST ? print(valueAST) : null;
        }
      },
      isDeprecated: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: (field) => field.deprecationReason != null
      },
      deprecationReason: {
        type: GraphQLString,
        resolve: (obj) => obj.deprecationReason
      }
    })
  });
  var __EnumValue = new GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: () => ({
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: (enumValue) => enumValue.name
      },
      description: {
        type: GraphQLString,
        resolve: (enumValue) => enumValue.description
      },
      isDeprecated: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: (enumValue) => enumValue.deprecationReason != null
      },
      deprecationReason: {
        type: GraphQLString,
        resolve: (enumValue) => enumValue.deprecationReason
      }
    })
  });
  var TypeKind;
  (function(TypeKind2) {
    TypeKind2["SCALAR"] = "SCALAR";
    TypeKind2["OBJECT"] = "OBJECT";
    TypeKind2["INTERFACE"] = "INTERFACE";
    TypeKind2["UNION"] = "UNION";
    TypeKind2["ENUM"] = "ENUM";
    TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
    TypeKind2["LIST"] = "LIST";
    TypeKind2["NON_NULL"] = "NON_NULL";
  })(TypeKind || (TypeKind = {}));
  var __TypeKind = new GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: TypeKind.SCALAR,
        description: "Indicates this type is a scalar."
      },
      OBJECT: {
        value: TypeKind.OBJECT,
        description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
      },
      INTERFACE: {
        value: TypeKind.INTERFACE,
        description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
      },
      UNION: {
        value: TypeKind.UNION,
        description: "Indicates this type is a union. `possibleTypes` is a valid field."
      },
      ENUM: {
        value: TypeKind.ENUM,
        description: "Indicates this type is an enum. `enumValues` is a valid field."
      },
      INPUT_OBJECT: {
        value: TypeKind.INPUT_OBJECT,
        description: "Indicates this type is an input object. `inputFields` is a valid field."
      },
      LIST: {
        value: TypeKind.LIST,
        description: "Indicates this type is a list. `ofType` is a valid field."
      },
      NON_NULL: {
        value: TypeKind.NON_NULL,
        description: "Indicates this type is a non-null. `ofType` is a valid field."
      }
    }
  });
  var SchemaMetaFieldDef = {
    name: "__schema",
    type: new GraphQLNonNull(__Schema),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: (_source, _args, _context, { schema }) => schema,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  var TypeMetaFieldDef = {
    name: "__type",
    type: __Type,
    description: "Request the type information of a single type.",
    args: [
      {
        name: "name",
        description: void 0,
        type: new GraphQLNonNull(GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      }
    ],
    resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  var TypeNameMetaFieldDef = {
    name: "__typename",
    type: new GraphQLNonNull(GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: (_source, _args, _context, { parentType }) => parentType.name,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  var introspectionTypes = Object.freeze([
    __Schema,
    __Directive,
    __DirectiveLocation,
    __Type,
    __Field,
    __InputValue,
    __EnumValue,
    __TypeKind
  ]);
  function isIntrospectionType(type2) {
    return introspectionTypes.some(({ name: name2 }) => type2.name === name2);
  }

  // node_modules/graphql/type/schema.mjs
  function isSchema(schema) {
    return instanceOf(schema, GraphQLSchema);
  }
  function assertSchema(schema) {
    if (!isSchema(schema)) {
      throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
    }
    return schema;
  }
  var GraphQLSchema = class {
    // Used as a cache for validateSchema().
    constructor(config) {
      var _config$extensionASTN, _config$directives;
      this.__validationErrors = config.assumeValid === true ? [] : void 0;
      isObjectLike(config) || devAssert(false, "Must provide configuration object.");
      !config.types || Array.isArray(config.types) || devAssert(
        false,
        `"types" must be Array if provided but got: ${inspect(config.types)}.`
      );
      !config.directives || Array.isArray(config.directives) || devAssert(
        false,
        `"directives" must be Array if provided but got: ${inspect(config.directives)}.`
      );
      this.description = config.description;
      this.extensions = toObjMap(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
      this._queryType = config.query;
      this._mutationType = config.mutation;
      this._subscriptionType = config.subscription;
      this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
      const allReferencedTypes = new Set(config.types);
      if (config.types != null) {
        for (const type2 of config.types) {
          allReferencedTypes.delete(type2);
          collectReferencedTypes(type2, allReferencedTypes);
        }
      }
      if (this._queryType != null) {
        collectReferencedTypes(this._queryType, allReferencedTypes);
      }
      if (this._mutationType != null) {
        collectReferencedTypes(this._mutationType, allReferencedTypes);
      }
      if (this._subscriptionType != null) {
        collectReferencedTypes(this._subscriptionType, allReferencedTypes);
      }
      for (const directive of this._directives) {
        if (isDirective(directive)) {
          for (const arg of directive.args) {
            collectReferencedTypes(arg.type, allReferencedTypes);
          }
        }
      }
      collectReferencedTypes(__Schema, allReferencedTypes);
      this._typeMap = /* @__PURE__ */ Object.create(null);
      this._subTypeMap = /* @__PURE__ */ Object.create(null);
      this._implementationsMap = /* @__PURE__ */ Object.create(null);
      for (const namedType of allReferencedTypes) {
        if (namedType == null) {
          continue;
        }
        const typeName = namedType.name;
        typeName || devAssert(
          false,
          "One of the provided types for building the Schema is missing a name."
        );
        if (this._typeMap[typeName] !== void 0) {
          throw new Error(
            `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
          );
        }
        this._typeMap[typeName] = namedType;
        if (isInterfaceType(namedType)) {
          for (const iface of namedType.getInterfaces()) {
            if (isInterfaceType(iface)) {
              let implementations = this._implementationsMap[iface.name];
              if (implementations === void 0) {
                implementations = this._implementationsMap[iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              implementations.interfaces.push(namedType);
            }
          }
        } else if (isObjectType(namedType)) {
          for (const iface of namedType.getInterfaces()) {
            if (isInterfaceType(iface)) {
              let implementations = this._implementationsMap[iface.name];
              if (implementations === void 0) {
                implementations = this._implementationsMap[iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              implementations.objects.push(namedType);
            }
          }
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLSchema";
    }
    getQueryType() {
      return this._queryType;
    }
    getMutationType() {
      return this._mutationType;
    }
    getSubscriptionType() {
      return this._subscriptionType;
    }
    getRootType(operation) {
      switch (operation) {
        case OperationTypeNode.QUERY:
          return this.getQueryType();
        case OperationTypeNode.MUTATION:
          return this.getMutationType();
        case OperationTypeNode.SUBSCRIPTION:
          return this.getSubscriptionType();
      }
    }
    getTypeMap() {
      return this._typeMap;
    }
    getType(name2) {
      return this.getTypeMap()[name2];
    }
    getPossibleTypes(abstractType) {
      return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
    }
    getImplementations(interfaceType) {
      const implementations = this._implementationsMap[interfaceType.name];
      return implementations !== null && implementations !== void 0 ? implementations : {
        objects: [],
        interfaces: []
      };
    }
    isSubType(abstractType, maybeSubType) {
      let map = this._subTypeMap[abstractType.name];
      if (map === void 0) {
        map = /* @__PURE__ */ Object.create(null);
        if (isUnionType(abstractType)) {
          for (const type2 of abstractType.getTypes()) {
            map[type2.name] = true;
          }
        } else {
          const implementations = this.getImplementations(abstractType);
          for (const type2 of implementations.objects) {
            map[type2.name] = true;
          }
          for (const type2 of implementations.interfaces) {
            map[type2.name] = true;
          }
        }
        this._subTypeMap[abstractType.name] = map;
      }
      return map[maybeSubType.name] !== void 0;
    }
    getDirectives() {
      return this._directives;
    }
    getDirective(name2) {
      return this.getDirectives().find((directive) => directive.name === name2);
    }
    toConfig() {
      return {
        description: this.description,
        query: this.getQueryType(),
        mutation: this.getMutationType(),
        subscription: this.getSubscriptionType(),
        types: Object.values(this.getTypeMap()),
        directives: this.getDirectives(),
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        assumeValid: this.__validationErrors !== void 0
      };
    }
  };
  function collectReferencedTypes(type2, typeSet) {
    const namedType = getNamedType(type2);
    if (!typeSet.has(namedType)) {
      typeSet.add(namedType);
      if (isUnionType(namedType)) {
        for (const memberType of namedType.getTypes()) {
          collectReferencedTypes(memberType, typeSet);
        }
      } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
        for (const interfaceType of namedType.getInterfaces()) {
          collectReferencedTypes(interfaceType, typeSet);
        }
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
          for (const arg of field.args) {
            collectReferencedTypes(arg.type, typeSet);
          }
        }
      } else if (isInputObjectType(namedType)) {
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
        }
      }
    }
    return typeSet;
  }

  // node_modules/graphql/type/validate.mjs
  function validateSchema(schema) {
    assertSchema(schema);
    if (schema.__validationErrors) {
      return schema.__validationErrors;
    }
    const context = new SchemaValidationContext(schema);
    validateRootTypes(context);
    validateDirectives(context);
    validateTypes(context);
    const errors = context.getErrors();
    schema.__validationErrors = errors;
    return errors;
  }
  function assertValidSchema(schema) {
    const errors = validateSchema(schema);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  }
  var SchemaValidationContext = class {
    constructor(schema) {
      this._errors = [];
      this.schema = schema;
    }
    reportError(message, nodes) {
      const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
      this._errors.push(
        new GraphQLError(message, {
          nodes: _nodes
        })
      );
    }
    getErrors() {
      return this._errors;
    }
  };
  function validateRootTypes(context) {
    const schema = context.schema;
    const queryType = schema.getQueryType();
    if (!queryType) {
      context.reportError("Query root type must be provided.", schema.astNode);
    } else if (!isObjectType(queryType)) {
      var _getOperationTypeNode;
      context.reportError(
        `Query root type must be Object type, it cannot be ${inspect(
          queryType
        )}.`,
        (_getOperationTypeNode = getOperationTypeNode(
          schema,
          OperationTypeNode.QUERY
        )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
      );
    }
    const mutationType = schema.getMutationType();
    if (mutationType && !isObjectType(mutationType)) {
      var _getOperationTypeNode2;
      context.reportError(
        `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
        (_getOperationTypeNode2 = getOperationTypeNode(
          schema,
          OperationTypeNode.MUTATION
        )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
      );
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && !isObjectType(subscriptionType)) {
      var _getOperationTypeNode3;
      context.reportError(
        `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
        (_getOperationTypeNode3 = getOperationTypeNode(
          schema,
          OperationTypeNode.SUBSCRIPTION
        )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
      );
    }
  }
  function getOperationTypeNode(schema, operation) {
    var _flatMap$find;
    return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (schemaNode) => {
        var _schemaNode$operation;
        return (
          /* c8 ignore next */
          (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
        );
      }
    ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
  }
  function validateDirectives(context) {
    for (const directive of context.schema.getDirectives()) {
      if (!isDirective(directive)) {
        context.reportError(
          `Expected directive but got: ${inspect(directive)}.`,
          directive === null || directive === void 0 ? void 0 : directive.astNode
        );
        continue;
      }
      validateName(context, directive);
      if (directive.locations.length === 0) {
        context.reportError(
          `Directive @${directive.name} must include 1 or more locations.`,
          directive.astNode
        );
      }
      for (const arg of directive.args) {
        validateName(context, arg);
        if (!isInputType(arg.type)) {
          context.reportError(
            `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
            arg.astNode
          );
        }
        if (isRequiredArgument(arg) && arg.deprecationReason != null) {
          var _arg$astNode;
          context.reportError(
            `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
            ]
          );
        }
      }
    }
  }
  function validateName(context, node) {
    if (node.name.startsWith("__")) {
      context.reportError(
        `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
        node.astNode
      );
    }
  }
  function validateTypes(context) {
    const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
    const typeMap = context.schema.getTypeMap();
    for (const type2 of Object.values(typeMap)) {
      if (!isNamedType(type2)) {
        context.reportError(
          `Expected GraphQL named type but got: ${inspect(type2)}.`,
          type2.astNode
        );
        continue;
      }
      if (!isIntrospectionType(type2)) {
        validateName(context, type2);
      }
      if (isObjectType(type2)) {
        validateFields(context, type2);
        validateInterfaces(context, type2);
      } else if (isInterfaceType(type2)) {
        validateFields(context, type2);
        validateInterfaces(context, type2);
      } else if (isUnionType(type2)) {
        validateUnionMembers(context, type2);
      } else if (isEnumType(type2)) {
        validateEnumValues(context, type2);
      } else if (isInputObjectType(type2)) {
        validateInputFields(context, type2);
        validateInputObjectCircularRefs(type2);
      }
    }
  }
  function validateFields(context, type2) {
    const fields = Object.values(type2.getFields());
    if (fields.length === 0) {
      context.reportError(`Type ${type2.name} must define one or more fields.`, [
        type2.astNode,
        ...type2.extensionASTNodes
      ]);
    }
    for (const field of fields) {
      validateName(context, field);
      if (!isOutputType(field.type)) {
        var _field$astNode;
        context.reportError(
          `The type of ${type2.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
          (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
        );
      }
      for (const arg of field.args) {
        const argName = arg.name;
        validateName(context, arg);
        if (!isInputType(arg.type)) {
          var _arg$astNode2;
          context.reportError(
            `The type of ${type2.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
            (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
          );
        }
        if (isRequiredArgument(arg) && arg.deprecationReason != null) {
          var _arg$astNode3;
          context.reportError(
            `Required argument ${type2.name}.${field.name}(${argName}:) cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
            ]
          );
        }
      }
    }
  }
  function validateInterfaces(context, type2) {
    const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
    for (const iface of type2.getInterfaces()) {
      if (!isInterfaceType(iface)) {
        context.reportError(
          `Type ${inspect(type2)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
          getAllImplementsInterfaceNodes(type2, iface)
        );
        continue;
      }
      if (type2 === iface) {
        context.reportError(
          `Type ${type2.name} cannot implement itself because it would create a circular reference.`,
          getAllImplementsInterfaceNodes(type2, iface)
        );
        continue;
      }
      if (ifaceTypeNames[iface.name]) {
        context.reportError(
          `Type ${type2.name} can only implement ${iface.name} once.`,
          getAllImplementsInterfaceNodes(type2, iface)
        );
        continue;
      }
      ifaceTypeNames[iface.name] = true;
      validateTypeImplementsAncestors(context, type2, iface);
      validateTypeImplementsInterface(context, type2, iface);
    }
  }
  function validateTypeImplementsInterface(context, type2, iface) {
    const typeFieldMap = type2.getFields();
    for (const ifaceField of Object.values(iface.getFields())) {
      const fieldName = ifaceField.name;
      const typeField = typeFieldMap[fieldName];
      if (!typeField) {
        context.reportError(
          `Interface field ${iface.name}.${fieldName} expected but ${type2.name} does not provide it.`,
          [ifaceField.astNode, type2.astNode, ...type2.extensionASTNodes]
        );
        continue;
      }
      if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
        var _ifaceField$astNode, _typeField$astNode;
        context.reportError(
          `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type2.name}.${fieldName} is type ${inspect(typeField.type)}.`,
          [
            (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
            (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
          ]
        );
      }
      for (const ifaceArg of ifaceField.args) {
        const argName = ifaceArg.name;
        const typeArg = typeField.args.find((arg) => arg.name === argName);
        if (!typeArg) {
          context.reportError(
            `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type2.name}.${fieldName} does not provide it.`,
            [ifaceArg.astNode, typeField.astNode]
          );
          continue;
        }
        if (!isEqualType(ifaceArg.type, typeArg.type)) {
          var _ifaceArg$astNode, _typeArg$astNode;
          context.reportError(
            `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type2.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
            [
              (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
              (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
            ]
          );
        }
      }
      for (const typeArg of typeField.args) {
        const argName = typeArg.name;
        const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
        if (!ifaceArg && isRequiredArgument(typeArg)) {
          context.reportError(
            `Object field ${type2.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
            [typeArg.astNode, ifaceField.astNode]
          );
        }
      }
    }
  }
  function validateTypeImplementsAncestors(context, type2, iface) {
    const ifaceInterfaces = type2.getInterfaces();
    for (const transitive of iface.getInterfaces()) {
      if (!ifaceInterfaces.includes(transitive)) {
        context.reportError(
          transitive === type2 ? `Type ${type2.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type2.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
          [
            ...getAllImplementsInterfaceNodes(iface, transitive),
            ...getAllImplementsInterfaceNodes(type2, iface)
          ]
        );
      }
    }
  }
  function validateUnionMembers(context, union) {
    const memberTypes = union.getTypes();
    if (memberTypes.length === 0) {
      context.reportError(
        `Union type ${union.name} must define one or more member types.`,
        [union.astNode, ...union.extensionASTNodes]
      );
    }
    const includedTypeNames = /* @__PURE__ */ Object.create(null);
    for (const memberType of memberTypes) {
      if (includedTypeNames[memberType.name]) {
        context.reportError(
          `Union type ${union.name} can only include type ${memberType.name} once.`,
          getUnionMemberTypeNodes(union, memberType.name)
        );
        continue;
      }
      includedTypeNames[memberType.name] = true;
      if (!isObjectType(memberType)) {
        context.reportError(
          `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
          getUnionMemberTypeNodes(union, String(memberType))
        );
      }
    }
  }
  function validateEnumValues(context, enumType) {
    const enumValues = enumType.getValues();
    if (enumValues.length === 0) {
      context.reportError(
        `Enum type ${enumType.name} must define one or more values.`,
        [enumType.astNode, ...enumType.extensionASTNodes]
      );
    }
    for (const enumValue of enumValues) {
      validateName(context, enumValue);
    }
  }
  function validateInputFields(context, inputObj) {
    const fields = Object.values(inputObj.getFields());
    if (fields.length === 0) {
      context.reportError(
        `Input Object type ${inputObj.name} must define one or more fields.`,
        [inputObj.astNode, ...inputObj.extensionASTNodes]
      );
    }
    for (const field of fields) {
      validateName(context, field);
      if (!isInputType(field.type)) {
        var _field$astNode2;
        context.reportError(
          `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
          (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
        );
      }
      if (isRequiredInputField(field) && field.deprecationReason != null) {
        var _field$astNode3;
        context.reportError(
          `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(field.astNode),
            (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
          ]
        );
      }
      if (inputObj.isOneOf) {
        validateOneOfInputObjectField(inputObj, field, context);
      }
    }
  }
  function validateOneOfInputObjectField(type2, field, context) {
    if (isNonNullType(field.type)) {
      var _field$astNode4;
      context.reportError(
        `OneOf input field ${type2.name}.${field.name} must be nullable.`,
        (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type
      );
    }
    if (field.defaultValue !== void 0) {
      context.reportError(
        `OneOf input field ${type2.name}.${field.name} cannot have a default value.`,
        field.astNode
      );
    }
  }
  function createInputObjectCircularRefsValidator(context) {
    const visitedTypes = /* @__PURE__ */ Object.create(null);
    const fieldPath = [];
    const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
    return detectCycleRecursive;
    function detectCycleRecursive(inputObj) {
      if (visitedTypes[inputObj.name]) {
        return;
      }
      visitedTypes[inputObj.name] = true;
      fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
      const fields = Object.values(inputObj.getFields());
      for (const field of fields) {
        if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
          const fieldType = field.type.ofType;
          const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
          fieldPath.push(field);
          if (cycleIndex === void 0) {
            detectCycleRecursive(fieldType);
          } else {
            const cyclePath = fieldPath.slice(cycleIndex);
            const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
            context.reportError(
              `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
              cyclePath.map((fieldObj) => fieldObj.astNode)
            );
          }
          fieldPath.pop();
        }
      }
      fieldPathIndexByTypeName[inputObj.name] = void 0;
    }
  }
  function getAllImplementsInterfaceNodes(type2, iface) {
    const { astNode, extensionASTNodes } = type2;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((typeNode) => {
      var _typeNode$interfaces;
      return (
        /* c8 ignore next */
        (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
      );
    }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
  }
  function getUnionMemberTypeNodes(union, typeName) {
    const { astNode, extensionASTNodes } = union;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((unionNode) => {
      var _unionNode$types;
      return (
        /* c8 ignore next */
        (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
      );
    }).filter((typeNode) => typeNode.name.value === typeName);
  }
  function getDeprecatedDirectiveNode(definitionNode) {
    var _definitionNode$direc;
    return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
      (node) => node.name.value === GraphQLDeprecatedDirective.name
    );
  }

  // node_modules/graphql/utilities/typeFromAST.mjs
  function typeFromAST(schema, typeNode) {
    switch (typeNode.kind) {
      case Kind.LIST_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new GraphQLList(innerType);
      }
      case Kind.NON_NULL_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new GraphQLNonNull(innerType);
      }
      case Kind.NAMED_TYPE:
        return schema.getType(typeNode.name.value);
    }
  }

  // node_modules/graphql/utilities/TypeInfo.mjs
  var TypeInfo = class {
    constructor(schema, initialType, getFieldDefFn) {
      this._schema = schema;
      this._typeStack = [];
      this._parentTypeStack = [];
      this._inputTypeStack = [];
      this._fieldDefStack = [];
      this._defaultValueStack = [];
      this._directive = null;
      this._argument = null;
      this._enumValue = null;
      this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
      if (initialType) {
        if (isInputType(initialType)) {
          this._inputTypeStack.push(initialType);
        }
        if (isCompositeType(initialType)) {
          this._parentTypeStack.push(initialType);
        }
        if (isOutputType(initialType)) {
          this._typeStack.push(initialType);
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "TypeInfo";
    }
    getType() {
      if (this._typeStack.length > 0) {
        return this._typeStack[this._typeStack.length - 1];
      }
    }
    getParentType() {
      if (this._parentTypeStack.length > 0) {
        return this._parentTypeStack[this._parentTypeStack.length - 1];
      }
    }
    getInputType() {
      if (this._inputTypeStack.length > 0) {
        return this._inputTypeStack[this._inputTypeStack.length - 1];
      }
    }
    getParentInputType() {
      if (this._inputTypeStack.length > 1) {
        return this._inputTypeStack[this._inputTypeStack.length - 2];
      }
    }
    getFieldDef() {
      if (this._fieldDefStack.length > 0) {
        return this._fieldDefStack[this._fieldDefStack.length - 1];
      }
    }
    getDefaultValue() {
      if (this._defaultValueStack.length > 0) {
        return this._defaultValueStack[this._defaultValueStack.length - 1];
      }
    }
    getDirective() {
      return this._directive;
    }
    getArgument() {
      return this._argument;
    }
    getEnumValue() {
      return this._enumValue;
    }
    enter(node) {
      const schema = this._schema;
      switch (node.kind) {
        case Kind.SELECTION_SET: {
          const namedType = getNamedType(this.getType());
          this._parentTypeStack.push(
            isCompositeType(namedType) ? namedType : void 0
          );
          break;
        }
        case Kind.FIELD: {
          const parentType = this.getParentType();
          let fieldDef;
          let fieldType;
          if (parentType) {
            fieldDef = this._getFieldDef(schema, parentType, node);
            if (fieldDef) {
              fieldType = fieldDef.type;
            }
          }
          this._fieldDefStack.push(fieldDef);
          this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
          break;
        }
        case Kind.DIRECTIVE:
          this._directive = schema.getDirective(node.name.value);
          break;
        case Kind.OPERATION_DEFINITION: {
          const rootType = schema.getRootType(node.operation);
          this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
          break;
        }
        case Kind.INLINE_FRAGMENT:
        case Kind.FRAGMENT_DEFINITION: {
          const typeConditionAST = node.typeCondition;
          const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
          this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
          break;
        }
        case Kind.VARIABLE_DEFINITION: {
          const inputType = typeFromAST(schema, node.type);
          this._inputTypeStack.push(
            isInputType(inputType) ? inputType : void 0
          );
          break;
        }
        case Kind.ARGUMENT: {
          var _this$getDirective;
          let argDef;
          let argType;
          const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
          if (fieldOrDirective) {
            argDef = fieldOrDirective.args.find(
              (arg) => arg.name === node.name.value
            );
            if (argDef) {
              argType = argDef.type;
            }
          }
          this._argument = argDef;
          this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
          this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
          break;
        }
        case Kind.LIST: {
          const listType = getNullableType(this.getInputType());
          const itemType = isListType(listType) ? listType.ofType : listType;
          this._defaultValueStack.push(void 0);
          this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
          break;
        }
        case Kind.OBJECT_FIELD: {
          const objectType = getNamedType(this.getInputType());
          let inputFieldType;
          let inputField;
          if (isInputObjectType(objectType)) {
            inputField = objectType.getFields()[node.name.value];
            if (inputField) {
              inputFieldType = inputField.type;
            }
          }
          this._defaultValueStack.push(
            inputField ? inputField.defaultValue : void 0
          );
          this._inputTypeStack.push(
            isInputType(inputFieldType) ? inputFieldType : void 0
          );
          break;
        }
        case Kind.ENUM: {
          const enumType = getNamedType(this.getInputType());
          let enumValue;
          if (isEnumType(enumType)) {
            enumValue = enumType.getValue(node.value);
          }
          this._enumValue = enumValue;
          break;
        }
        default:
      }
    }
    leave(node) {
      switch (node.kind) {
        case Kind.SELECTION_SET:
          this._parentTypeStack.pop();
          break;
        case Kind.FIELD:
          this._fieldDefStack.pop();
          this._typeStack.pop();
          break;
        case Kind.DIRECTIVE:
          this._directive = null;
          break;
        case Kind.OPERATION_DEFINITION:
        case Kind.INLINE_FRAGMENT:
        case Kind.FRAGMENT_DEFINITION:
          this._typeStack.pop();
          break;
        case Kind.VARIABLE_DEFINITION:
          this._inputTypeStack.pop();
          break;
        case Kind.ARGUMENT:
          this._argument = null;
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case Kind.LIST:
        case Kind.OBJECT_FIELD:
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case Kind.ENUM:
          this._enumValue = null;
          break;
        default:
      }
    }
  };
  function getFieldDef(schema, parentType, fieldNode) {
    const name2 = fieldNode.name.value;
    if (name2 === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return SchemaMetaFieldDef;
    }
    if (name2 === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return TypeMetaFieldDef;
    }
    if (name2 === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
      return TypeNameMetaFieldDef;
    }
    if (isObjectType(parentType) || isInterfaceType(parentType)) {
      return parentType.getFields()[name2];
    }
  }
  function visitWithTypeInfo(typeInfo, visitor) {
    return {
      enter(...args) {
        const node = args[0];
        typeInfo.enter(node);
        const fn = getEnterLeaveForKind(visitor, node.kind).enter;
        if (fn) {
          const result = fn.apply(visitor, args);
          if (result !== void 0) {
            typeInfo.leave(node);
            if (isNode(result)) {
              typeInfo.enter(result);
            }
          }
          return result;
        }
      },
      leave(...args) {
        const node = args[0];
        const fn = getEnterLeaveForKind(visitor, node.kind).leave;
        let result;
        if (fn) {
          result = fn.apply(visitor, args);
        }
        typeInfo.leave(node);
        return result;
      }
    };
  }

  // node_modules/graphql/language/predicates.mjs
  function isExecutableDefinitionNode(node) {
    return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
  }
  function isTypeSystemDefinitionNode(node) {
    return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
  }
  function isTypeDefinitionNode(node) {
    return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
  }
  function isTypeSystemExtensionNode(node) {
    return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
  }
  function isTypeExtensionNode(node) {
    return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }

  // node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
  function ExecutableDefinitionsRule(context) {
    return {
      Document(node) {
        for (const definition of node.definitions) {
          if (!isExecutableDefinitionNode(definition)) {
            const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
            context.reportError(
              new GraphQLError(`The ${defName} definition is not executable.`, {
                nodes: definition
              })
            );
          }
        }
        return false;
      }
    };
  }

  // node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
  function FieldsOnCorrectTypeRule(context) {
    return {
      Field(node) {
        const type2 = context.getParentType();
        if (type2) {
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            const schema = context.getSchema();
            const fieldName = node.name.value;
            let suggestion = didYouMean(
              "to use an inline fragment on",
              getSuggestedTypeNames(schema, type2, fieldName)
            );
            if (suggestion === "") {
              suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
            }
            context.reportError(
              new GraphQLError(
                `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
                {
                  nodes: node
                }
              )
            );
          }
        }
      }
    };
  }
  function getSuggestedTypeNames(schema, type2, fieldName) {
    if (!isAbstractType(type2)) {
      return [];
    }
    const suggestedTypes = /* @__PURE__ */ new Set();
    const usageCount = /* @__PURE__ */ Object.create(null);
    for (const possibleType of schema.getPossibleTypes(type2)) {
      if (!possibleType.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleType);
      usageCount[possibleType.name] = 1;
      for (const possibleInterface of possibleType.getInterfaces()) {
        var _usageCount$possibleI;
        if (!possibleInterface.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleInterface);
        usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
      }
    }
    return [...suggestedTypes].sort((typeA, typeB) => {
      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
      if (usageCountDiff !== 0) {
        return usageCountDiff;
      }
      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
        return -1;
      }
      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
        return 1;
      }
      return naturalCompare(typeA.name, typeB.name);
    }).map((x2) => x2.name);
  }
  function getSuggestedFieldNames(type2, fieldName) {
    if (isObjectType(type2) || isInterfaceType(type2)) {
      const possibleFieldNames = Object.keys(type2.getFields());
      return suggestionList(fieldName, possibleFieldNames);
    }
    return [];
  }

  // node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
  function FragmentsOnCompositeTypesRule(context) {
    return {
      InlineFragment(node) {
        const typeCondition = node.typeCondition;
        if (typeCondition) {
          const type2 = typeFromAST(context.getSchema(), typeCondition);
          if (type2 && !isCompositeType(type2)) {
            const typeStr = print(typeCondition);
            context.reportError(
              new GraphQLError(
                `Fragment cannot condition on non composite type "${typeStr}".`,
                {
                  nodes: typeCondition
                }
              )
            );
          }
        }
      },
      FragmentDefinition(node) {
        const type2 = typeFromAST(context.getSchema(), node.typeCondition);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(node.typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
              {
                nodes: node.typeCondition
              }
            )
          );
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
  function KnownArgumentNamesRule(context) {
    return {
      // eslint-disable-next-line new-cap
      ...KnownArgumentNamesOnDirectivesRule(context),
      Argument(argNode) {
        const argDef = context.getArgument();
        const fieldDef = context.getFieldDef();
        const parentType = context.getParentType();
        if (!argDef && fieldDef && parentType) {
          const argName = argNode.name.value;
          const knownArgsNames = fieldDef.args.map((arg) => arg.name);
          const suggestions = suggestionList(argName, knownArgsNames);
          context.reportError(
            new GraphQLError(
              `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
              {
                nodes: argNode
              }
            )
          );
        }
      }
    };
  }
  function KnownArgumentNamesOnDirectivesRule(context) {
    const directiveArgs = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
    for (const directive of definedDirectives) {
      directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
        directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
      }
    }
    return {
      Directive(directiveNode) {
        const directiveName = directiveNode.name.value;
        const knownArgs = directiveArgs[directiveName];
        if (directiveNode.arguments && knownArgs) {
          for (const argNode of directiveNode.arguments) {
            const argName = argNode.name.value;
            if (!knownArgs.includes(argName)) {
              const suggestions = suggestionList(argName, knownArgs);
              context.reportError(
                new GraphQLError(
                  `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                  {
                    nodes: argNode
                  }
                )
              );
            }
          }
        }
        return false;
      }
    };
  }

  // node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
  function KnownDirectivesRule(context) {
    const locationsMap = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
    for (const directive of definedDirectives) {
      locationsMap[directive.name] = directive.locations;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
      }
    }
    return {
      Directive(node, _key, _parent, _path, ancestors) {
        const name2 = node.name.value;
        const locations = locationsMap[name2];
        if (!locations) {
          context.reportError(
            new GraphQLError(`Unknown directive "@${name2}".`, {
              nodes: node
            })
          );
          return;
        }
        const candidateLocation = getDirectiveLocationForASTPath(ancestors);
        if (candidateLocation && !locations.includes(candidateLocation)) {
          context.reportError(
            new GraphQLError(
              `Directive "@${name2}" may not be used on ${candidateLocation}.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  function getDirectiveLocationForASTPath(ancestors) {
    const appliedTo = ancestors[ancestors.length - 1];
    "kind" in appliedTo || invariant(false);
    switch (appliedTo.kind) {
      case Kind.OPERATION_DEFINITION:
        return getDirectiveLocationForOperation(appliedTo.operation);
      case Kind.FIELD:
        return DirectiveLocation.FIELD;
      case Kind.FRAGMENT_SPREAD:
        return DirectiveLocation.FRAGMENT_SPREAD;
      case Kind.INLINE_FRAGMENT:
        return DirectiveLocation.INLINE_FRAGMENT;
      case Kind.FRAGMENT_DEFINITION:
        return DirectiveLocation.FRAGMENT_DEFINITION;
      case Kind.VARIABLE_DEFINITION:
        return DirectiveLocation.VARIABLE_DEFINITION;
      case Kind.SCHEMA_DEFINITION:
      case Kind.SCHEMA_EXTENSION:
        return DirectiveLocation.SCHEMA;
      case Kind.SCALAR_TYPE_DEFINITION:
      case Kind.SCALAR_TYPE_EXTENSION:
        return DirectiveLocation.SCALAR;
      case Kind.OBJECT_TYPE_DEFINITION:
      case Kind.OBJECT_TYPE_EXTENSION:
        return DirectiveLocation.OBJECT;
      case Kind.FIELD_DEFINITION:
        return DirectiveLocation.FIELD_DEFINITION;
      case Kind.INTERFACE_TYPE_DEFINITION:
      case Kind.INTERFACE_TYPE_EXTENSION:
        return DirectiveLocation.INTERFACE;
      case Kind.UNION_TYPE_DEFINITION:
      case Kind.UNION_TYPE_EXTENSION:
        return DirectiveLocation.UNION;
      case Kind.ENUM_TYPE_DEFINITION:
      case Kind.ENUM_TYPE_EXTENSION:
        return DirectiveLocation.ENUM;
      case Kind.ENUM_VALUE_DEFINITION:
        return DirectiveLocation.ENUM_VALUE;
      case Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return DirectiveLocation.INPUT_OBJECT;
      case Kind.INPUT_VALUE_DEFINITION: {
        const parentNode = ancestors[ancestors.length - 3];
        "kind" in parentNode || invariant(false);
        return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
      }
      // Not reachable, all possible types have been considered.
      /* c8 ignore next */
      default:
        invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
    }
  }
  function getDirectiveLocationForOperation(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return DirectiveLocation.QUERY;
      case OperationTypeNode.MUTATION:
        return DirectiveLocation.MUTATION;
      case OperationTypeNode.SUBSCRIPTION:
        return DirectiveLocation.SUBSCRIPTION;
    }
  }

  // node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
  function KnownFragmentNamesRule(context) {
    return {
      FragmentSpread(node) {
        const fragmentName = node.name.value;
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          context.reportError(
            new GraphQLError(`Unknown fragment "${fragmentName}".`, {
              nodes: node.name
            })
          );
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
  function KnownTypeNamesRule(context) {
    const schema = context.getSchema();
    const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
    const definedTypes = /* @__PURE__ */ Object.create(null);
    for (const def of context.getDocument().definitions) {
      if (isTypeDefinitionNode(def)) {
        definedTypes[def.name.value] = true;
      }
    }
    const typeNames = [
      ...Object.keys(existingTypesMap),
      ...Object.keys(definedTypes)
    ];
    return {
      NamedType(node, _1, parent, _2, ancestors) {
        const typeName = node.name.value;
        if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
          var _ancestors$;
          const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
          const isSDL = definitionNode != null && isSDLNode(definitionNode);
          if (isSDL && standardTypeNames.includes(typeName)) {
            return;
          }
          const suggestedTypes = suggestionList(
            typeName,
            isSDL ? standardTypeNames.concat(typeNames) : typeNames
          );
          context.reportError(
            new GraphQLError(
              `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
    (type2) => type2.name
  );
  function isSDLNode(value) {
    return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
  }

  // node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
  function LoneAnonymousOperationRule(context) {
    let operationCount = 0;
    return {
      Document(node) {
        operationCount = node.definitions.filter(
          (definition) => definition.kind === Kind.OPERATION_DEFINITION
        ).length;
      },
      OperationDefinition(node) {
        if (!node.name && operationCount > 1) {
          context.reportError(
            new GraphQLError(
              "This anonymous operation must be the only defined operation.",
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
  function LoneSchemaDefinitionRule(context) {
    var _ref, _ref2, _oldSchema$astNode;
    const oldSchema = context.getSchema();
    const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
    let schemaDefinitionsCount = 0;
    return {
      SchemaDefinition(node) {
        if (alreadyDefined) {
          context.reportError(
            new GraphQLError(
              "Cannot define a new schema within a schema extension.",
              {
                nodes: node
              }
            )
          );
          return;
        }
        if (schemaDefinitionsCount > 0) {
          context.reportError(
            new GraphQLError("Must provide only one schema definition.", {
              nodes: node
            })
          );
        }
        ++schemaDefinitionsCount;
      }
    };
  }

  // node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
  var MAX_LISTS_DEPTH = 3;
  function MaxIntrospectionDepthRule(context) {
    function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
      if (node.kind === Kind.FRAGMENT_SPREAD) {
        const fragmentName = node.name.value;
        if (visitedFragments[fragmentName] === true) {
          return false;
        }
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          return false;
        }
        try {
          visitedFragments[fragmentName] = true;
          return checkDepth(fragment, visitedFragments, depth);
        } finally {
          visitedFragments[fragmentName] = void 0;
        }
      }
      if (node.kind === Kind.FIELD && // check all introspection lists
      (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
        depth++;
        if (depth >= MAX_LISTS_DEPTH) {
          return true;
        }
      }
      if ("selectionSet" in node && node.selectionSet) {
        for (const child of node.selectionSet.selections) {
          if (checkDepth(child, visitedFragments, depth)) {
            return true;
          }
        }
      }
      return false;
    }
    return {
      Field(node) {
        if (node.name.value === "__schema" || node.name.value === "__type") {
          if (checkDepth(node)) {
            context.reportError(
              new GraphQLError("Maximum introspection depth exceeded", {
                nodes: [node]
              })
            );
            return false;
          }
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
  function NoFragmentCyclesRule(context) {
    const visitedFrags = /* @__PURE__ */ Object.create(null);
    const spreadPath = [];
    const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node) {
        detectCycleRecursive(node);
        return false;
      }
    };
    function detectCycleRecursive(fragment) {
      if (visitedFrags[fragment.name.value]) {
        return;
      }
      const fragmentName = fragment.name.value;
      visitedFrags[fragmentName] = true;
      const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
      if (spreadNodes.length === 0) {
        return;
      }
      spreadPathIndexByName[fragmentName] = spreadPath.length;
      for (const spreadNode of spreadNodes) {
        const spreadName = spreadNode.name.value;
        const cycleIndex = spreadPathIndexByName[spreadName];
        spreadPath.push(spreadNode);
        if (cycleIndex === void 0) {
          const spreadFragment = context.getFragment(spreadName);
          if (spreadFragment) {
            detectCycleRecursive(spreadFragment);
          }
        } else {
          const cyclePath = spreadPath.slice(cycleIndex);
          const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
          context.reportError(
            new GraphQLError(
              `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
              {
                nodes: cyclePath
              }
            )
          );
        }
        spreadPath.pop();
      }
      spreadPathIndexByName[fragmentName] = void 0;
    }
  }

  // node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
  function NoUndefinedVariablesRule(context) {
    let variableNameDefined = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          variableNameDefined = /* @__PURE__ */ Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node } of usages) {
            const varName = node.name.value;
            if (variableNameDefined[varName] !== true) {
              context.reportError(
                new GraphQLError(
                  operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                  {
                    nodes: [node, operation]
                  }
                )
              );
            }
          }
        }
      },
      VariableDefinition(node) {
        variableNameDefined[node.variable.name.value] = true;
      }
    };
  }

  // node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
  function NoUnusedFragmentsRule(context) {
    const operationDefs = [];
    const fragmentDefs = [];
    return {
      OperationDefinition(node) {
        operationDefs.push(node);
        return false;
      },
      FragmentDefinition(node) {
        fragmentDefs.push(node);
        return false;
      },
      Document: {
        leave() {
          const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
          for (const operation of operationDefs) {
            for (const fragment of context.getRecursivelyReferencedFragments(
              operation
            )) {
              fragmentNameUsed[fragment.name.value] = true;
            }
          }
          for (const fragmentDef of fragmentDefs) {
            const fragName = fragmentDef.name.value;
            if (fragmentNameUsed[fragName] !== true) {
              context.reportError(
                new GraphQLError(`Fragment "${fragName}" is never used.`, {
                  nodes: fragmentDef
                })
              );
            }
          }
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
  function NoUnusedVariablesRule(context) {
    let variableDefs = [];
    return {
      OperationDefinition: {
        enter() {
          variableDefs = [];
        },
        leave(operation) {
          const variableNameUsed = /* @__PURE__ */ Object.create(null);
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node } of usages) {
            variableNameUsed[node.name.value] = true;
          }
          for (const variableDef of variableDefs) {
            const variableName = variableDef.variable.name.value;
            if (variableNameUsed[variableName] !== true) {
              context.reportError(
                new GraphQLError(
                  operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                  {
                    nodes: variableDef
                  }
                )
              );
            }
          }
        }
      },
      VariableDefinition(def) {
        variableDefs.push(def);
      }
    };
  }

  // node_modules/graphql/utilities/sortValueNode.mjs
  function sortValueNode(valueNode) {
    switch (valueNode.kind) {
      case Kind.OBJECT:
        return { ...valueNode, fields: sortFields(valueNode.fields) };
      case Kind.LIST:
        return { ...valueNode, values: valueNode.values.map(sortValueNode) };
      case Kind.INT:
      case Kind.FLOAT:
      case Kind.STRING:
      case Kind.BOOLEAN:
      case Kind.NULL:
      case Kind.ENUM:
      case Kind.VARIABLE:
        return valueNode;
    }
  }
  function sortFields(fields) {
    return fields.map((fieldNode) => ({
      ...fieldNode,
      value: sortValueNode(fieldNode.value)
    })).sort(
      (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
    );
  }

  // node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
  function reasonMessage(reason) {
    if (Array.isArray(reason)) {
      return reason.map(
        ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
      ).join(" and ");
    }
    return reason;
  }
  function OverlappingFieldsCanBeMergedRule(context) {
    const comparedFieldsAndFragmentPairs = new OrderedPairSet();
    const comparedFragmentPairs = new PairSet();
    const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
    return {
      SelectionSet(selectionSet) {
        const conflicts = findConflictsWithinSelectionSet(
          context,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          context.getParentType(),
          selectionSet
        );
        for (const [[responseName, reason], fields1, fields2] of conflicts) {
          const reasonMsg = reasonMessage(reason);
          context.reportError(
            new GraphQLError(
              `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
              {
                nodes: fields1.concat(fields2)
              }
            )
          );
        }
      }
    };
  }
  function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
    const conflicts = [];
    const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      parentType,
      selectionSet
    );
    collectConflictsWithin(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      fieldMap
    );
    if (fragmentNames.length !== 0) {
      for (let i = 0; i < fragmentNames.length; i++) {
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          false,
          fieldMap,
          fragmentNames[i]
        );
        for (let j2 = i + 1; j2 < fragmentNames.length; j2++) {
          collectConflictsBetweenFragments(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            fragmentNames[i],
            fragmentNames[j2]
          );
        }
      }
    }
    return conflicts;
  }
  function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    if (comparedFieldsAndFragmentPairs.has(
      fieldMap,
      fragmentName,
      areMutuallyExclusive
    )) {
      return;
    }
    comparedFieldsAndFragmentPairs.add(
      fieldMap,
      fragmentName,
      areMutuallyExclusive
    );
    const fragment = context.getFragment(fragmentName);
    if (!fragment) {
      return;
    }
    const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragment
    );
    if (fieldMap === fieldMap2) {
      return;
    }
    collectConflictsBetween(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      fieldMap2
    );
    for (const referencedFragmentName of referencedFragmentNames) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap,
        referencedFragmentName
      );
    }
  }
  function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    if (fragmentName1 === fragmentName2) {
      return;
    }
    if (comparedFragmentPairs.has(
      fragmentName1,
      fragmentName2,
      areMutuallyExclusive
    )) {
      return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    const fragment1 = context.getFragment(fragmentName1);
    const fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
      return;
    }
    const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragment1
    );
    const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragment2
    );
    collectConflictsBetween(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fieldMap2
    );
    for (const referencedFragmentName2 of referencedFragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        referencedFragmentName2
      );
    }
    for (const referencedFragmentName1 of referencedFragmentNames1) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        referencedFragmentName1,
        fragmentName2
      );
    }
  }
  function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    const conflicts = [];
    const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      parentType1,
      selectionSet1
    );
    const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      parentType2,
      selectionSet2
    );
    collectConflictsBetween(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fieldMap2
    );
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fragmentName2
      );
    }
    for (const fragmentName1 of fragmentNames1) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap2,
        fragmentName1
      );
    }
    for (const fragmentName1 of fragmentNames1) {
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fragmentName1,
          fragmentName2
        );
      }
    }
    return conflicts;
  }
  function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
    for (const [responseName, fields] of Object.entries(fieldMap)) {
      if (fields.length > 1) {
        for (let i = 0; i < fields.length; i++) {
          for (let j2 = i + 1; j2 < fields.length; j2++) {
            const conflict = findConflict(
              context,
              cachedFieldsAndFragmentNames,
              comparedFieldsAndFragmentPairs,
              comparedFragmentPairs,
              false,
              // within one collection is never mutually exclusive
              responseName,
              fields[i],
              fields[j2]
            );
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    for (const [responseName, fields1] of Object.entries(fieldMap1)) {
      const fields2 = fieldMap2[responseName];
      if (fields2) {
        for (const field1 of fields1) {
          for (const field2 of fields2) {
            const conflict = findConflict(
              context,
              cachedFieldsAndFragmentNames,
              comparedFieldsAndFragmentPairs,
              comparedFragmentPairs,
              parentFieldsAreMutuallyExclusive,
              responseName,
              field1,
              field2
            );
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    const [parentType1, node1, def1] = field1;
    const [parentType2, node2, def2] = field2;
    const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
    if (!areMutuallyExclusive) {
      const name1 = node1.name.value;
      const name2 = node2.name.value;
      if (name1 !== name2) {
        return [
          [responseName, `"${name1}" and "${name2}" are different fields`],
          [node1],
          [node2]
        ];
      }
      if (!sameArguments(node1, node2)) {
        return [
          [responseName, "they have differing arguments"],
          [node1],
          [node2]
        ];
      }
    }
    const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
    const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
      return [
        [
          responseName,
          `they return conflicting types "${inspect(type1)}" and "${inspect(
            type2
          )}"`
        ],
        [node1],
        [node2]
      ];
    }
    const selectionSet1 = node1.selectionSet;
    const selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
      const conflicts = findConflictsBetweenSubSelectionSets(
        context,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        getNamedType(type1),
        selectionSet1,
        getNamedType(type2),
        selectionSet2
      );
      return subfieldConflicts(conflicts, responseName, node1, node2);
    }
  }
  function sameArguments(node1, node2) {
    const args1 = node1.arguments;
    const args2 = node2.arguments;
    if (args1 === void 0 || args1.length === 0) {
      return args2 === void 0 || args2.length === 0;
    }
    if (args2 === void 0 || args2.length === 0) {
      return false;
    }
    if (args1.length !== args2.length) {
      return false;
    }
    const values2 = new Map(args2.map(({ name: name2, value }) => [name2.value, value]));
    return args1.every((arg1) => {
      const value1 = arg1.value;
      const value2 = values2.get(arg1.name.value);
      if (value2 === void 0) {
        return false;
      }
      return stringifyValue(value1) === stringifyValue(value2);
    });
  }
  function stringifyValue(value) {
    return print(sortValueNode(value));
  }
  function doTypesConflict(type1, type2) {
    if (isListType(type1)) {
      return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if (isListType(type2)) {
      return true;
    }
    if (isNonNullType(type1)) {
      return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if (isNonNullType(type2)) {
      return true;
    }
    if (isLeafType(type1) || isLeafType(type2)) {
      return type1 !== type2;
    }
    return false;
  }
  function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    const cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (cached) {
      return cached;
    }
    const nodeAndDefs = /* @__PURE__ */ Object.create(null);
    const fragmentNames = /* @__PURE__ */ Object.create(null);
    _collectFieldsAndFragmentNames(
      context,
      parentType,
      selectionSet,
      nodeAndDefs,
      fragmentNames
    );
    const result = [nodeAndDefs, Object.keys(fragmentNames)];
    cachedFieldsAndFragmentNames.set(selectionSet, result);
    return result;
  }
  function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
      return cached;
    }
    const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragmentType,
      fragment.selectionSet
    );
  }
  function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case Kind.FIELD: {
          const fieldName = selection.name.value;
          let fieldDef;
          if (isObjectType(parentType) || isInterfaceType(parentType)) {
            fieldDef = parentType.getFields()[fieldName];
          }
          const responseName = selection.alias ? selection.alias.value : fieldName;
          if (!nodeAndDefs[responseName]) {
            nodeAndDefs[responseName] = [];
          }
          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
          break;
        }
        case Kind.FRAGMENT_SPREAD:
          fragmentNames[selection.name.value] = true;
          break;
        case Kind.INLINE_FRAGMENT: {
          const typeCondition = selection.typeCondition;
          const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
          _collectFieldsAndFragmentNames(
            context,
            inlineFragmentType,
            selection.selectionSet,
            nodeAndDefs,
            fragmentNames
          );
          break;
        }
      }
    }
  }
  function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
      return [
        [responseName, conflicts.map(([reason]) => reason)],
        [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
        [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
      ];
    }
  }
  var OrderedPairSet = class {
    constructor() {
      this._data = /* @__PURE__ */ new Map();
    }
    has(a, b2, weaklyPresent) {
      var _this$_data$get;
      const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b2);
      if (result === void 0) {
        return false;
      }
      return weaklyPresent ? true : weaklyPresent === result;
    }
    add(a, b2, weaklyPresent) {
      const map = this._data.get(a);
      if (map === void 0) {
        this._data.set(a, /* @__PURE__ */ new Map([[b2, weaklyPresent]]));
      } else {
        map.set(b2, weaklyPresent);
      }
    }
  };
  var PairSet = class {
    constructor() {
      this._orderedPairSet = new OrderedPairSet();
    }
    has(a, b2, weaklyPresent) {
      return a < b2 ? this._orderedPairSet.has(a, b2, weaklyPresent) : this._orderedPairSet.has(b2, a, weaklyPresent);
    }
    add(a, b2, weaklyPresent) {
      if (a < b2) {
        this._orderedPairSet.add(a, b2, weaklyPresent);
      } else {
        this._orderedPairSet.add(b2, a, weaklyPresent);
      }
    }
  };

  // node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
  function PossibleFragmentSpreadsRule(context) {
    return {
      InlineFragment(node) {
        const fragType = context.getType();
        const parentType = context.getParentType();
        if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = inspect(parentType);
          const fragTypeStr = inspect(fragType);
          context.reportError(
            new GraphQLError(
              `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
              {
                nodes: node
              }
            )
          );
        }
      },
      FragmentSpread(node) {
        const fragName = node.name.value;
        const fragType = getFragmentType(context, fragName);
        const parentType = context.getParentType();
        if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = inspect(parentType);
          const fragTypeStr = inspect(fragType);
          context.reportError(
            new GraphQLError(
              `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  function getFragmentType(context, name2) {
    const frag = context.getFragment(name2);
    if (frag) {
      const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
      if (isCompositeType(type2)) {
        return type2;
      }
    }
  }

  // node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
  function PossibleTypeExtensionsRule(context) {
    const schema = context.getSchema();
    const definedTypes = /* @__PURE__ */ Object.create(null);
    for (const def of context.getDocument().definitions) {
      if (isTypeDefinitionNode(def)) {
        definedTypes[def.name.value] = def;
      }
    }
    return {
      ScalarTypeExtension: checkExtension,
      ObjectTypeExtension: checkExtension,
      InterfaceTypeExtension: checkExtension,
      UnionTypeExtension: checkExtension,
      EnumTypeExtension: checkExtension,
      InputObjectTypeExtension: checkExtension
    };
    function checkExtension(node) {
      const typeName = node.name.value;
      const defNode = definedTypes[typeName];
      const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
      let expectedKind;
      if (defNode) {
        expectedKind = defKindToExtKind[defNode.kind];
      } else if (existingType) {
        expectedKind = typeToExtKind(existingType);
      }
      if (expectedKind) {
        if (expectedKind !== node.kind) {
          const kindStr = extensionKindToTypeName(node.kind);
          context.reportError(
            new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
              nodes: defNode ? [defNode, node] : node
            })
          );
        }
      } else {
        const allTypeNames = Object.keys({
          ...definedTypes,
          ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
        });
        const suggestedTypes = suggestionList(typeName, allTypeNames);
        context.reportError(
          new GraphQLError(
            `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
            {
              nodes: node.name
            }
          )
        );
      }
    }
  }
  var defKindToExtKind = {
    [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
    [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
    [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
    [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
    [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
    [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
  };
  function typeToExtKind(type2) {
    if (isScalarType(type2)) {
      return Kind.SCALAR_TYPE_EXTENSION;
    }
    if (isObjectType(type2)) {
      return Kind.OBJECT_TYPE_EXTENSION;
    }
    if (isInterfaceType(type2)) {
      return Kind.INTERFACE_TYPE_EXTENSION;
    }
    if (isUnionType(type2)) {
      return Kind.UNION_TYPE_EXTENSION;
    }
    if (isEnumType(type2)) {
      return Kind.ENUM_TYPE_EXTENSION;
    }
    if (isInputObjectType(type2)) {
      return Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    invariant(false, "Unexpected type: " + inspect(type2));
  }
  function extensionKindToTypeName(kind) {
    switch (kind) {
      case Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case Kind.UNION_TYPE_EXTENSION:
        return "union";
      case Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
      // Not reachable. All possible types have been considered
      /* c8 ignore next */
      default:
        invariant(false, "Unexpected kind: " + inspect(kind));
    }
  }

  // node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
  function ProvidedRequiredArgumentsRule(context) {
    return {
      // eslint-disable-next-line new-cap
      ...ProvidedRequiredArgumentsOnDirectivesRule(context),
      Field: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(fieldNode) {
          var _fieldNode$arguments;
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            return false;
          }
          const providedArgs = new Set(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */
            (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
          );
          for (const argDef of fieldDef.args) {
            if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
              const argTypeStr = inspect(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                  {
                    nodes: fieldNode
                  }
                )
              );
            }
          }
        }
      }
    };
  }
  function ProvidedRequiredArgumentsOnDirectivesRule(context) {
    var _schema$getDirectives;
    const requiredArgsMap = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
    for (const directive of definedDirectives) {
      requiredArgsMap[directive.name] = keyMap(
        directive.args.filter(isRequiredArgument),
        (arg) => arg.name
      );
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
        requiredArgsMap[def.name.value] = keyMap(
          argNodes.filter(isRequiredArgumentNode),
          (arg) => arg.name.value
        );
      }
    }
    return {
      Directive: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(directiveNode) {
          const directiveName = directiveNode.name.value;
          const requiredArgs = requiredArgsMap[directiveName];
          if (requiredArgs) {
            var _directiveNode$argume;
            const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
            for (const [argName, argDef] of Object.entries(requiredArgs)) {
              if (!argNodeMap.has(argName)) {
                const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
                context.reportError(
                  new GraphQLError(
                    `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                    {
                      nodes: directiveNode
                    }
                  )
                );
              }
            }
          }
        }
      }
    };
  }
  function isRequiredArgumentNode(arg) {
    return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
  }

  // node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
  function ScalarLeafsRule(context) {
    return {
      Field(node) {
        const type2 = context.getType();
        const selectionSet = node.selectionSet;
        if (type2) {
          if (isLeafType(getNamedType(type2))) {
            if (selectionSet) {
              const fieldName = node.name.value;
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                  {
                    nodes: selectionSet
                  }
                )
              );
            }
          } else if (!selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                {
                  nodes: node
                }
              )
            );
          } else if (selectionSet.selections.length === 0) {
            const fieldName = node.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      }
    };
  }

  // node_modules/graphql/utilities/valueFromAST.mjs
  function valueFromAST(valueNode, type2, variables) {
    if (!valueNode) {
      return;
    }
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variables == null || variables[variableName] === void 0) {
        return;
      }
      const variableValue = variables[variableName];
      if (variableValue === null && isNonNullType(type2)) {
        return;
      }
      return variableValue;
    }
    if (isNonNullType(type2)) {
      if (valueNode.kind === Kind.NULL) {
        return;
      }
      return valueFromAST(valueNode, type2.ofType, variables);
    }
    if (valueNode.kind === Kind.NULL) {
      return null;
    }
    if (isListType(type2)) {
      const itemType = type2.ofType;
      if (valueNode.kind === Kind.LIST) {
        const coercedValues = [];
        for (const itemNode of valueNode.values) {
          if (isMissingVariable(itemNode, variables)) {
            if (isNonNullType(itemType)) {
              return;
            }
            coercedValues.push(null);
          } else {
            const itemValue = valueFromAST(itemNode, itemType, variables);
            if (itemValue === void 0) {
              return;
            }
            coercedValues.push(itemValue);
          }
        }
        return coercedValues;
      }
      const coercedValue = valueFromAST(valueNode, itemType, variables);
      if (coercedValue === void 0) {
        return;
      }
      return [coercedValue];
    }
    if (isInputObjectType(type2)) {
      if (valueNode.kind !== Kind.OBJECT) {
        return;
      }
      const coercedObj = /* @__PURE__ */ Object.create(null);
      const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
      for (const field of Object.values(type2.getFields())) {
        const fieldNode = fieldNodes[field.name];
        if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
          if (field.defaultValue !== void 0) {
            coercedObj[field.name] = field.defaultValue;
          } else if (isNonNullType(field.type)) {
            return;
          }
          continue;
        }
        const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
        if (fieldValue === void 0) {
          return;
        }
        coercedObj[field.name] = fieldValue;
      }
      if (type2.isOneOf) {
        const keys = Object.keys(coercedObj);
        if (keys.length !== 1) {
          return;
        }
        if (coercedObj[keys[0]] === null) {
          return;
        }
      }
      return coercedObj;
    }
    if (isLeafType(type2)) {
      let result;
      try {
        result = type2.parseLiteral(valueNode, variables);
      } catch (_error) {
        return;
      }
      if (result === void 0) {
        return;
      }
      return result;
    }
    invariant(false, "Unexpected input type: " + inspect(type2));
  }
  function isMissingVariable(valueNode, variables) {
    return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
  }

  // node_modules/graphql/execution/values.mjs
  function getArgumentValues(def, node, variableValues) {
    var _node$arguments;
    const coercedValues = {};
    const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
    const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
    for (const argDef of def.args) {
      const name2 = argDef.name;
      const argType = argDef.type;
      const argumentNode = argNodeMap[name2];
      if (!argumentNode) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
            {
              nodes: node
            }
          );
        }
        continue;
      }
      const valueNode = argumentNode.value;
      let isNull = valueNode.kind === Kind.NULL;
      if (valueNode.kind === Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name2] = argDef.defaultValue;
          } else if (isNonNullType(argType)) {
            throw new GraphQLError(
              `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
              {
                nodes: valueNode
              }
            );
          }
          continue;
        }
        isNull = variableValues[variableName] == null;
      }
      if (isNull && isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
          {
            nodes: valueNode
          }
        );
      }
      const coercedValue = valueFromAST(valueNode, argType, variableValues);
      if (coercedValue === void 0) {
        throw new GraphQLError(
          `Argument "${name2}" has invalid value ${print(valueNode)}.`,
          {
            nodes: valueNode
          }
        );
      }
      coercedValues[name2] = coercedValue;
    }
    return coercedValues;
  }
  function getDirectiveValues(directiveDef, node, variableValues) {
    var _node$directives;
    const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
      (directive) => directive.name.value === directiveDef.name
    );
    if (directiveNode) {
      return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // node_modules/graphql/execution/collectFields.mjs
  function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
    const fields = /* @__PURE__ */ new Map();
    collectFieldsImpl(
      schema,
      fragments,
      variableValues,
      runtimeType,
      selectionSet,
      fields,
      /* @__PURE__ */ new Set()
    );
    return fields;
  }
  function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case Kind.FIELD: {
          if (!shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          const name2 = getFieldEntryKey(selection);
          const fieldList = fields.get(name2);
          if (fieldList !== void 0) {
            fieldList.push(selection);
          } else {
            fields.set(name2, [selection]);
          }
          break;
        }
        case Kind.INLINE_FRAGMENT: {
          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
            continue;
          }
          collectFieldsImpl(
            schema,
            fragments,
            variableValues,
            runtimeType,
            selection.selectionSet,
            fields,
            visitedFragmentNames
          );
          break;
        }
        case Kind.FRAGMENT_SPREAD: {
          const fragName = selection.name.value;
          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          visitedFragmentNames.add(fragName);
          const fragment = fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
            continue;
          }
          collectFieldsImpl(
            schema,
            fragments,
            variableValues,
            runtimeType,
            fragment.selectionSet,
            fields,
            visitedFragmentNames
          );
          break;
        }
      }
    }
  }
  function shouldIncludeNode(variableValues, node) {
    const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
      return false;
    }
    const include = getDirectiveValues(
      GraphQLIncludeDirective,
      node,
      variableValues
    );
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
      return false;
    }
    return true;
  }
  function doesFragmentConditionMatch(schema, fragment, type2) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    const conditionalType = typeFromAST(schema, typeConditionNode);
    if (conditionalType === type2) {
      return true;
    }
    if (isAbstractType(conditionalType)) {
      return schema.isSubType(conditionalType, type2);
    }
    return false;
  }
  function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
  }

  // node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
  function SingleFieldSubscriptionsRule(context) {
    return {
      OperationDefinition(node) {
        if (node.operation === "subscription") {
          const schema = context.getSchema();
          const subscriptionType = schema.getSubscriptionType();
          if (subscriptionType) {
            const operationName = node.name ? node.name.value : null;
            const variableValues = /* @__PURE__ */ Object.create(null);
            const document2 = context.getDocument();
            const fragments = /* @__PURE__ */ Object.create(null);
            for (const definition of document2.definitions) {
              if (definition.kind === Kind.FRAGMENT_DEFINITION) {
                fragments[definition.name.value] = definition;
              }
            }
            const fields = collectFields(
              schema,
              fragments,
              variableValues,
              subscriptionType,
              node.selectionSet
            );
            if (fields.size > 1) {
              const fieldSelectionLists = [...fields.values()];
              const extraFieldSelectionLists = fieldSelectionLists.slice(1);
              const extraFieldSelections = extraFieldSelectionLists.flat();
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                  {
                    nodes: extraFieldSelections
                  }
                )
              );
            }
            for (const fieldNodes of fields.values()) {
              const field = fieldNodes[0];
              const fieldName = field.name.value;
              if (fieldName.startsWith("__")) {
                context.reportError(
                  new GraphQLError(
                    operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                    {
                      nodes: fieldNodes
                    }
                  )
                );
              }
            }
          }
        }
      }
    };
  }

  // node_modules/graphql/jsutils/groupBy.mjs
  function groupBy(list2, keyFn) {
    const result = /* @__PURE__ */ new Map();
    for (const item of list2) {
      const key = keyFn(item);
      const group = result.get(key);
      if (group === void 0) {
        result.set(key, [item]);
      } else {
        group.push(item);
      }
    }
    return result;
  }

  // node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
  function UniqueArgumentDefinitionNamesRule(context) {
    return {
      DirectiveDefinition(directiveNode) {
        var _directiveNode$argume;
        const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
        return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
      },
      InterfaceTypeDefinition: checkArgUniquenessPerField,
      InterfaceTypeExtension: checkArgUniquenessPerField,
      ObjectTypeDefinition: checkArgUniquenessPerField,
      ObjectTypeExtension: checkArgUniquenessPerField
    };
    function checkArgUniquenessPerField(typeNode) {
      var _typeNode$fields;
      const typeName = typeNode.name.value;
      const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
      for (const fieldDef of fieldNodes) {
        var _fieldDef$arguments;
        const fieldName = fieldDef.name.value;
        const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
        checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
      }
      return false;
    }
    function checkArgUniqueness(parentName, argumentNodes) {
      const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `Argument "${parentName}(${argName}:)" can only be defined once.`,
              {
                nodes: argNodes.map((node) => node.name)
              }
            )
          );
        }
      }
      return false;
    }
  }

  // node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
  function UniqueArgumentNamesRule(context) {
    return {
      Field: checkArgUniqueness,
      Directive: checkArgUniqueness
    };
    function checkArgUniqueness(parentNode) {
      var _parentNode$arguments;
      const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
      const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one argument named "${argName}".`,
              {
                nodes: argNodes.map((node) => node.name)
              }
            )
          );
        }
      }
    }
  }

  // node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
  function UniqueDirectiveNamesRule(context) {
    const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    return {
      DirectiveDefinition(node) {
        const directiveName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
          context.reportError(
            new GraphQLError(
              `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
              {
                nodes: node.name
              }
            )
          );
          return;
        }
        if (knownDirectiveNames[directiveName]) {
          context.reportError(
            new GraphQLError(
              `There can be only one directive named "@${directiveName}".`,
              {
                nodes: [knownDirectiveNames[directiveName], node.name]
              }
            )
          );
        } else {
          knownDirectiveNames[directiveName] = node.name;
        }
        return false;
      }
    };
  }

  // node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
  function UniqueDirectivesPerLocationRule(context) {
    const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
    for (const directive of definedDirectives) {
      uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        uniqueDirectiveMap[def.name.value] = !def.repeatable;
      }
    }
    const schemaDirectives = /* @__PURE__ */ Object.create(null);
    const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
    return {
      // Many different AST nodes may contain directives. Rather than listing
      // them all, just listen for entering any node, and check to see if it
      // defines any directives.
      enter(node) {
        if (!("directives" in node) || !node.directives) {
          return;
        }
        let seenDirectives;
        if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
          seenDirectives = schemaDirectives;
        } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
          const typeName = node.name.value;
          seenDirectives = typeDirectivesMap[typeName];
          if (seenDirectives === void 0) {
            typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
          }
        } else {
          seenDirectives = /* @__PURE__ */ Object.create(null);
        }
        for (const directive of node.directives) {
          const directiveName = directive.name.value;
          if (uniqueDirectiveMap[directiveName]) {
            if (seenDirectives[directiveName]) {
              context.reportError(
                new GraphQLError(
                  `The directive "@${directiveName}" can only be used once at this location.`,
                  {
                    nodes: [seenDirectives[directiveName], directive]
                  }
                )
              );
            } else {
              seenDirectives[directiveName] = directive;
            }
          }
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
  function UniqueEnumValueNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
    const knownValueNames = /* @__PURE__ */ Object.create(null);
    return {
      EnumTypeDefinition: checkValueUniqueness,
      EnumTypeExtension: checkValueUniqueness
    };
    function checkValueUniqueness(node) {
      var _node$values;
      const typeName = node.name.value;
      if (!knownValueNames[typeName]) {
        knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
      }
      const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
      const valueNames = knownValueNames[typeName];
      for (const valueDef of valueNodes) {
        const valueName = valueDef.name.value;
        const existingType = existingTypeMap[typeName];
        if (isEnumType(existingType) && existingType.getValue(valueName)) {
          context.reportError(
            new GraphQLError(
              `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
              {
                nodes: valueDef.name
              }
            )
          );
        } else if (valueNames[valueName]) {
          context.reportError(
            new GraphQLError(
              `Enum value "${typeName}.${valueName}" can only be defined once.`,
              {
                nodes: [valueNames[valueName], valueDef.name]
              }
            )
          );
        } else {
          valueNames[valueName] = valueDef.name;
        }
      }
      return false;
    }
  }

  // node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
  function UniqueFieldDefinitionNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
    const knownFieldNames = /* @__PURE__ */ Object.create(null);
    return {
      InputObjectTypeDefinition: checkFieldUniqueness,
      InputObjectTypeExtension: checkFieldUniqueness,
      InterfaceTypeDefinition: checkFieldUniqueness,
      InterfaceTypeExtension: checkFieldUniqueness,
      ObjectTypeDefinition: checkFieldUniqueness,
      ObjectTypeExtension: checkFieldUniqueness
    };
    function checkFieldUniqueness(node) {
      var _node$fields;
      const typeName = node.name.value;
      if (!knownFieldNames[typeName]) {
        knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
      }
      const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
      const fieldNames = knownFieldNames[typeName];
      for (const fieldDef of fieldNodes) {
        const fieldName = fieldDef.name.value;
        if (hasField(existingTypeMap[typeName], fieldName)) {
          context.reportError(
            new GraphQLError(
              `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
              {
                nodes: fieldDef.name
              }
            )
          );
        } else if (fieldNames[fieldName]) {
          context.reportError(
            new GraphQLError(
              `Field "${typeName}.${fieldName}" can only be defined once.`,
              {
                nodes: [fieldNames[fieldName], fieldDef.name]
              }
            )
          );
        } else {
          fieldNames[fieldName] = fieldDef.name;
        }
      }
      return false;
    }
  }
  function hasField(type2, fieldName) {
    if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
      return type2.getFields()[fieldName] != null;
    }
    return false;
  }

  // node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
  function UniqueFragmentNamesRule(context) {
    const knownFragmentNames = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node) {
        const fragmentName = node.name.value;
        if (knownFragmentNames[fragmentName]) {
          context.reportError(
            new GraphQLError(
              `There can be only one fragment named "${fragmentName}".`,
              {
                nodes: [knownFragmentNames[fragmentName], node.name]
              }
            )
          );
        } else {
          knownFragmentNames[fragmentName] = node.name;
        }
        return false;
      }
    };
  }

  // node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
  function UniqueInputFieldNamesRule(context) {
    const knownNameStack = [];
    let knownNames = /* @__PURE__ */ Object.create(null);
    return {
      ObjectValue: {
        enter() {
          knownNameStack.push(knownNames);
          knownNames = /* @__PURE__ */ Object.create(null);
        },
        leave() {
          const prevKnownNames = knownNameStack.pop();
          prevKnownNames || invariant(false);
          knownNames = prevKnownNames;
        }
      },
      ObjectField(node) {
        const fieldName = node.name.value;
        if (knownNames[fieldName]) {
          context.reportError(
            new GraphQLError(
              `There can be only one input field named "${fieldName}".`,
              {
                nodes: [knownNames[fieldName], node.name]
              }
            )
          );
        } else {
          knownNames[fieldName] = node.name;
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
  function UniqueOperationNamesRule(context) {
    const knownOperationNames = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition(node) {
        const operationName = node.name;
        if (operationName) {
          if (knownOperationNames[operationName.value]) {
            context.reportError(
              new GraphQLError(
                `There can be only one operation named "${operationName.value}".`,
                {
                  nodes: [
                    knownOperationNames[operationName.value],
                    operationName
                  ]
                }
              )
            );
          } else {
            knownOperationNames[operationName.value] = operationName;
          }
        }
        return false;
      },
      FragmentDefinition: () => false
    };
  }

  // node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
  function UniqueOperationTypesRule(context) {
    const schema = context.getSchema();
    const definedOperationTypes = /* @__PURE__ */ Object.create(null);
    const existingOperationTypes = schema ? {
      query: schema.getQueryType(),
      mutation: schema.getMutationType(),
      subscription: schema.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: checkOperationTypes,
      SchemaExtension: checkOperationTypes
    };
    function checkOperationTypes(node) {
      var _node$operationTypes;
      const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
      for (const operationType of operationTypesNodes) {
        const operation = operationType.operation;
        const alreadyDefinedOperationType = definedOperationTypes[operation];
        if (existingOperationTypes[operation]) {
          context.reportError(
            new GraphQLError(
              `Type for ${operation} already defined in the schema. It cannot be redefined.`,
              {
                nodes: operationType
              }
            )
          );
        } else if (alreadyDefinedOperationType) {
          context.reportError(
            new GraphQLError(
              `There can be only one ${operation} type in schema.`,
              {
                nodes: [alreadyDefinedOperationType, operationType]
              }
            )
          );
        } else {
          definedOperationTypes[operation] = operationType;
        }
      }
      return false;
    }
  }

  // node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
  function UniqueTypeNamesRule(context) {
    const knownTypeNames = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    return {
      ScalarTypeDefinition: checkTypeName,
      ObjectTypeDefinition: checkTypeName,
      InterfaceTypeDefinition: checkTypeName,
      UnionTypeDefinition: checkTypeName,
      EnumTypeDefinition: checkTypeName,
      InputObjectTypeDefinition: checkTypeName
    };
    function checkTypeName(node) {
      const typeName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
        context.reportError(
          new GraphQLError(
            `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownTypeNames[typeName]) {
        context.reportError(
          new GraphQLError(`There can be only one type named "${typeName}".`, {
            nodes: [knownTypeNames[typeName], node.name]
          })
        );
      } else {
        knownTypeNames[typeName] = node.name;
      }
      return false;
    }
  }

  // node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
  function UniqueVariableNamesRule(context) {
    return {
      OperationDefinition(operationNode) {
        var _operationNode$variab;
        const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
        const seenVariableDefinitions = groupBy(
          variableDefinitions,
          (node) => node.variable.name.value
        );
        for (const [variableName, variableNodes] of seenVariableDefinitions) {
          if (variableNodes.length > 1) {
            context.reportError(
              new GraphQLError(
                `There can be only one variable named "$${variableName}".`,
                {
                  nodes: variableNodes.map((node) => node.variable.name)
                }
              )
            );
          }
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
  function ValuesOfCorrectTypeRule(context) {
    let variableDefinitions = {};
    return {
      OperationDefinition: {
        enter() {
          variableDefinitions = {};
        }
      },
      VariableDefinition(definition) {
        variableDefinitions[definition.variable.name.value] = definition;
      },
      ListValue(node) {
        const type2 = getNullableType(context.getParentInputType());
        if (!isListType(type2)) {
          isValidValueNode(context, node);
          return false;
        }
      },
      ObjectValue(node) {
        const type2 = getNamedType(context.getInputType());
        if (!isInputObjectType(type2)) {
          isValidValueNode(context, node);
          return false;
        }
        const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
        for (const fieldDef of Object.values(type2.getFields())) {
          const fieldNode = fieldNodeMap[fieldDef.name];
          if (!fieldNode && isRequiredInputField(fieldDef)) {
            const typeStr = inspect(fieldDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                {
                  nodes: node
                }
              )
            );
          }
        }
        if (type2.isOneOf) {
          validateOneOfInputObject(context, node, type2, fieldNodeMap);
        }
      },
      ObjectField(node) {
        const parentType = getNamedType(context.getParentInputType());
        const fieldType = context.getInputType();
        if (!fieldType && isInputObjectType(parentType)) {
          const suggestions = suggestionList(
            node.name.value,
            Object.keys(parentType.getFields())
          );
          context.reportError(
            new GraphQLError(
              `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
              {
                nodes: node
              }
            )
          );
        }
      },
      NullValue(node) {
        const type2 = context.getInputType();
        if (isNonNullType(type2)) {
          context.reportError(
            new GraphQLError(
              `Expected value of type "${inspect(type2)}", found ${print(node)}.`,
              {
                nodes: node
              }
            )
          );
        }
      },
      EnumValue: (node) => isValidValueNode(context, node),
      IntValue: (node) => isValidValueNode(context, node),
      FloatValue: (node) => isValidValueNode(context, node),
      StringValue: (node) => isValidValueNode(context, node),
      BooleanValue: (node) => isValidValueNode(context, node)
    };
  }
  function isValidValueNode(context, node) {
    const locationType = context.getInputType();
    if (!locationType) {
      return;
    }
    const type2 = getNamedType(locationType);
    if (!isLeafType(type2)) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
      return;
    }
    try {
      const parseResult = type2.parseLiteral(
        node,
        void 0
        /* variables */
      );
      if (parseResult === void 0) {
        const typeStr = inspect(locationType);
        context.reportError(
          new GraphQLError(
            `Expected value of type "${typeStr}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    } catch (error) {
      const typeStr = inspect(locationType);
      if (error instanceof GraphQLError) {
        context.reportError(error);
      } else {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
            {
              nodes: node,
              originalError: error
            }
          )
        );
      }
    }
  }
  function validateOneOfInputObject(context, node, type2, fieldNodeMap) {
    var _fieldNodeMap$keys$;
    const keys = Object.keys(fieldNodeMap);
    const isNotExactlyOneField = keys.length !== 1;
    if (isNotExactlyOneField) {
      context.reportError(
        new GraphQLError(
          `OneOf Input Object "${type2.name}" must specify exactly one key.`,
          {
            nodes: [node]
          }
        )
      );
      return;
    }
    const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
    const isNullLiteral = !value || value.kind === Kind.NULL;
    if (isNullLiteral) {
      context.reportError(
        new GraphQLError(`Field "${type2.name}.${keys[0]}" must be non-null.`, {
          nodes: [node]
        })
      );
    }
  }

  // node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
  function VariablesAreInputTypesRule(context) {
    return {
      VariableDefinition(node) {
        const type2 = typeFromAST(context.getSchema(), node.type);
        if (type2 !== void 0 && !isInputType(type2)) {
          const variableName = node.variable.name.value;
          const typeName = print(node.type);
          context.reportError(
            new GraphQLError(
              `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
              {
                nodes: node.type
              }
            )
          );
        }
      }
    };
  }

  // node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
  function VariablesInAllowedPositionRule(context) {
    let varDefMap = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          varDefMap = /* @__PURE__ */ Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node, type: type2, defaultValue, parentType } of usages) {
            const varName = node.name.value;
            const varDef = varDefMap[varName];
            if (varDef && type2) {
              const schema = context.getSchema();
              const varType = typeFromAST(schema, varDef.type);
              if (varType && !allowedVariableUsage(
                schema,
                varType,
                varDef.defaultValue,
                type2,
                defaultValue
              )) {
                const varTypeStr = inspect(varType);
                const typeStr = inspect(type2);
                context.reportError(
                  new GraphQLError(
                    `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                    {
                      nodes: [varDef, node]
                    }
                  )
                );
              }
              if (isInputObjectType(parentType) && parentType.isOneOf && isNullableType(varType)) {
                context.reportError(
                  new GraphQLError(
                    `Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`,
                    {
                      nodes: [varDef, node]
                    }
                  )
                );
              }
            }
          }
        }
      },
      VariableDefinition(node) {
        varDefMap[node.variable.name.value] = node;
      }
    };
  }
  function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if (isNonNullType(locationType) && !isNonNullType(varType)) {
      const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
      const hasLocationDefaultValue = locationDefaultValue !== void 0;
      if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
        return false;
      }
      const nullableLocationType = locationType.ofType;
      return isTypeSubTypeOf(schema, varType, nullableLocationType);
    }
    return isTypeSubTypeOf(schema, varType, locationType);
  }

  // node_modules/graphql/validation/specifiedRules.mjs
  var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
  var specifiedRules = Object.freeze([
    ExecutableDefinitionsRule,
    UniqueOperationNamesRule,
    LoneAnonymousOperationRule,
    SingleFieldSubscriptionsRule,
    KnownTypeNamesRule,
    FragmentsOnCompositeTypesRule,
    VariablesAreInputTypesRule,
    ScalarLeafsRule,
    FieldsOnCorrectTypeRule,
    UniqueFragmentNamesRule,
    KnownFragmentNamesRule,
    NoUnusedFragmentsRule,
    PossibleFragmentSpreadsRule,
    NoFragmentCyclesRule,
    UniqueVariableNamesRule,
    NoUndefinedVariablesRule,
    NoUnusedVariablesRule,
    KnownDirectivesRule,
    UniqueDirectivesPerLocationRule,
    KnownArgumentNamesRule,
    UniqueArgumentNamesRule,
    ValuesOfCorrectTypeRule,
    ProvidedRequiredArgumentsRule,
    VariablesInAllowedPositionRule,
    OverlappingFieldsCanBeMergedRule,
    UniqueInputFieldNamesRule,
    ...recommendedRules
  ]);
  var specifiedSDLRules = Object.freeze([
    LoneSchemaDefinitionRule,
    UniqueOperationTypesRule,
    UniqueTypeNamesRule,
    UniqueEnumValueNamesRule,
    UniqueFieldDefinitionNamesRule,
    UniqueArgumentDefinitionNamesRule,
    UniqueDirectiveNamesRule,
    KnownTypeNamesRule,
    KnownDirectivesRule,
    UniqueDirectivesPerLocationRule,
    PossibleTypeExtensionsRule,
    KnownArgumentNamesOnDirectivesRule,
    UniqueArgumentNamesRule,
    UniqueInputFieldNamesRule,
    ProvidedRequiredArgumentsOnDirectivesRule
  ]);

  // node_modules/graphql/validation/ValidationContext.mjs
  var ASTValidationContext = class {
    constructor(ast, onError) {
      this._ast = ast;
      this._fragments = void 0;
      this._fragmentSpreads = /* @__PURE__ */ new Map();
      this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
      this._onError = onError;
    }
    get [Symbol.toStringTag]() {
      return "ASTValidationContext";
    }
    reportError(error) {
      this._onError(error);
    }
    getDocument() {
      return this._ast;
    }
    getFragment(name2) {
      let fragments;
      if (this._fragments) {
        fragments = this._fragments;
      } else {
        fragments = /* @__PURE__ */ Object.create(null);
        for (const defNode of this.getDocument().definitions) {
          if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
            fragments[defNode.name.value] = defNode;
          }
        }
        this._fragments = fragments;
      }
      return fragments[name2];
    }
    getFragmentSpreads(node) {
      let spreads = this._fragmentSpreads.get(node);
      if (!spreads) {
        spreads = [];
        const setsToVisit = [node];
        let set;
        while (set = setsToVisit.pop()) {
          for (const selection of set.selections) {
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
              spreads.push(selection);
            } else if (selection.selectionSet) {
              setsToVisit.push(selection.selectionSet);
            }
          }
        }
        this._fragmentSpreads.set(node, spreads);
      }
      return spreads;
    }
    getRecursivelyReferencedFragments(operation) {
      let fragments = this._recursivelyReferencedFragments.get(operation);
      if (!fragments) {
        fragments = [];
        const collectedNames = /* @__PURE__ */ Object.create(null);
        const nodesToVisit = [operation.selectionSet];
        let node;
        while (node = nodesToVisit.pop()) {
          for (const spread of this.getFragmentSpreads(node)) {
            const fragName = spread.name.value;
            if (collectedNames[fragName] !== true) {
              collectedNames[fragName] = true;
              const fragment = this.getFragment(fragName);
              if (fragment) {
                fragments.push(fragment);
                nodesToVisit.push(fragment.selectionSet);
              }
            }
          }
        }
        this._recursivelyReferencedFragments.set(operation, fragments);
      }
      return fragments;
    }
  };
  var SDLValidationContext = class extends ASTValidationContext {
    constructor(ast, schema, onError) {
      super(ast, onError);
      this._schema = schema;
    }
    get [Symbol.toStringTag]() {
      return "SDLValidationContext";
    }
    getSchema() {
      return this._schema;
    }
  };
  var ValidationContext = class extends ASTValidationContext {
    constructor(schema, ast, typeInfo, onError) {
      super(ast, onError);
      this._schema = schema;
      this._typeInfo = typeInfo;
      this._variableUsages = /* @__PURE__ */ new Map();
      this._recursiveVariableUsages = /* @__PURE__ */ new Map();
    }
    get [Symbol.toStringTag]() {
      return "ValidationContext";
    }
    getSchema() {
      return this._schema;
    }
    getVariableUsages(node) {
      let usages = this._variableUsages.get(node);
      if (!usages) {
        const newUsages = [];
        const typeInfo = new TypeInfo(this._schema);
        visit(
          node,
          visitWithTypeInfo(typeInfo, {
            VariableDefinition: () => false,
            Variable(variable) {
              newUsages.push({
                node: variable,
                type: typeInfo.getInputType(),
                defaultValue: typeInfo.getDefaultValue(),
                parentType: typeInfo.getParentInputType()
              });
            }
          })
        );
        usages = newUsages;
        this._variableUsages.set(node, usages);
      }
      return usages;
    }
    getRecursiveVariableUsages(operation) {
      let usages = this._recursiveVariableUsages.get(operation);
      if (!usages) {
        usages = this.getVariableUsages(operation);
        for (const frag of this.getRecursivelyReferencedFragments(operation)) {
          usages = usages.concat(this.getVariableUsages(frag));
        }
        this._recursiveVariableUsages.set(operation, usages);
      }
      return usages;
    }
    getType() {
      return this._typeInfo.getType();
    }
    getParentType() {
      return this._typeInfo.getParentType();
    }
    getInputType() {
      return this._typeInfo.getInputType();
    }
    getParentInputType() {
      return this._typeInfo.getParentInputType();
    }
    getFieldDef() {
      return this._typeInfo.getFieldDef();
    }
    getDirective() {
      return this._typeInfo.getDirective();
    }
    getArgument() {
      return this._typeInfo.getArgument();
    }
    getEnumValue() {
      return this._typeInfo.getEnumValue();
    }
  };

  // node_modules/graphql/validation/validate.mjs
  function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
    var _options$maxErrors;
    const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
    documentAST || devAssert(false, "Must provide document.");
    assertValidSchema(schema);
    const abortObj = Object.freeze({});
    const errors = [];
    const context = new ValidationContext(
      schema,
      documentAST,
      typeInfo,
      (error) => {
        if (errors.length >= maxErrors) {
          errors.push(
            new GraphQLError(
              "Too many validation errors, error limit reached. Validation aborted."
            )
          );
          throw abortObj;
        }
        errors.push(error);
      }
    );
    const visitor = visitInParallel(rules.map((rule) => rule(context)));
    try {
      visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
    } catch (e) {
      if (e !== abortObj) {
        throw e;
      }
    }
    return errors;
  }
  function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
    const errors = [];
    const context = new SDLValidationContext(
      documentAST,
      schemaToExtend,
      (error) => {
        errors.push(error);
      }
    );
    const visitors = rules.map((rule) => rule(context));
    visit(documentAST, visitInParallel(visitors));
    return errors;
  }
  function assertValidSDL(documentAST) {
    const errors = validateSDL(documentAST);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  }

  // node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs
  function NoDeprecatedCustomRule(context) {
    return {
      Field(node) {
        const fieldDef = context.getFieldDef();
        const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
        if (fieldDef && deprecationReason != null) {
          const parentType = context.getParentType();
          parentType != null || invariant(false);
          context.reportError(
            new GraphQLError(
              `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      },
      Argument(node) {
        const argDef = context.getArgument();
        const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
        if (argDef && deprecationReason != null) {
          const directiveDef = context.getDirective();
          if (directiveDef != null) {
            context.reportError(
              new GraphQLError(
                `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          } else {
            const parentType = context.getParentType();
            const fieldDef = context.getFieldDef();
            parentType != null && fieldDef != null || invariant(false);
            context.reportError(
              new GraphQLError(
                `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      },
      ObjectField(node) {
        const inputObjectDef = getNamedType(context.getParentInputType());
        if (isInputObjectType(inputObjectDef)) {
          const inputFieldDef = inputObjectDef.getFields()[node.name.value];
          const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
          if (deprecationReason != null) {
            context.reportError(
              new GraphQLError(
                `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      },
      EnumValue(node) {
        const enumValueDef = context.getEnumValue();
        const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
        if (enumValueDef && deprecationReason != null) {
          const enumTypeDef = getNamedType(context.getInputType());
          enumTypeDef != null || invariant(false);
          context.reportError(
            new GraphQLError(
              `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }

  // node_modules/graphql/utilities/buildClientSchema.mjs
  function buildClientSchema(introspection, options) {
    isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(
      false,
      `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(
        introspection
      )}.`
    );
    const schemaIntrospection = introspection.__schema;
    const typeMap = keyValMap(
      schemaIntrospection.types,
      (typeIntrospection) => typeIntrospection.name,
      (typeIntrospection) => buildType(typeIntrospection)
    );
    for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
      if (typeMap[stdType.name]) {
        typeMap[stdType.name] = stdType;
      }
    }
    const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
    const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
    const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
    const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
    return new GraphQLSchema({
      description: schemaIntrospection.description,
      query: queryType,
      mutation: mutationType,
      subscription: subscriptionType,
      types: Object.values(typeMap),
      directives,
      assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
    });
    function getType(typeRef) {
      if (typeRef.kind === TypeKind.LIST) {
        const itemRef = typeRef.ofType;
        if (!itemRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        return new GraphQLList(getType(itemRef));
      }
      if (typeRef.kind === TypeKind.NON_NULL) {
        const nullableRef = typeRef.ofType;
        if (!nullableRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        const nullableType = getType(nullableRef);
        return new GraphQLNonNull(assertNullableType(nullableType));
      }
      return getNamedType2(typeRef);
    }
    function getNamedType2(typeRef) {
      const typeName = typeRef.name;
      if (!typeName) {
        throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);
      }
      const type2 = typeMap[typeName];
      if (!type2) {
        throw new Error(
          `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
        );
      }
      return type2;
    }
    function getObjectType(typeRef) {
      return assertObjectType(getNamedType2(typeRef));
    }
    function getInterfaceType(typeRef) {
      return assertInterfaceType(getNamedType2(typeRef));
    }
    function buildType(type2) {
      if (type2 != null && type2.name != null && type2.kind != null) {
        switch (type2.kind) {
          case TypeKind.SCALAR:
            return buildScalarDef(type2);
          case TypeKind.OBJECT:
            return buildObjectDef(type2);
          case TypeKind.INTERFACE:
            return buildInterfaceDef(type2);
          case TypeKind.UNION:
            return buildUnionDef(type2);
          case TypeKind.ENUM:
            return buildEnumDef(type2);
          case TypeKind.INPUT_OBJECT:
            return buildInputObjectDef(type2);
        }
      }
      const typeStr = inspect(type2);
      throw new Error(
        `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
      );
    }
    function buildScalarDef(scalarIntrospection) {
      return new GraphQLScalarType({
        name: scalarIntrospection.name,
        description: scalarIntrospection.description,
        specifiedByURL: scalarIntrospection.specifiedByURL
      });
    }
    function buildImplementationsList(implementingIntrospection) {
      if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
        return [];
      }
      if (!implementingIntrospection.interfaces) {
        const implementingIntrospectionStr = inspect(implementingIntrospection);
        throw new Error(
          `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
        );
      }
      return implementingIntrospection.interfaces.map(getInterfaceType);
    }
    function buildObjectDef(objectIntrospection) {
      return new GraphQLObjectType({
        name: objectIntrospection.name,
        description: objectIntrospection.description,
        interfaces: () => buildImplementationsList(objectIntrospection),
        fields: () => buildFieldDefMap(objectIntrospection)
      });
    }
    function buildInterfaceDef(interfaceIntrospection) {
      return new GraphQLInterfaceType({
        name: interfaceIntrospection.name,
        description: interfaceIntrospection.description,
        interfaces: () => buildImplementationsList(interfaceIntrospection),
        fields: () => buildFieldDefMap(interfaceIntrospection)
      });
    }
    function buildUnionDef(unionIntrospection) {
      if (!unionIntrospection.possibleTypes) {
        const unionIntrospectionStr = inspect(unionIntrospection);
        throw new Error(
          `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
        );
      }
      return new GraphQLUnionType({
        name: unionIntrospection.name,
        description: unionIntrospection.description,
        types: () => unionIntrospection.possibleTypes.map(getObjectType)
      });
    }
    function buildEnumDef(enumIntrospection) {
      if (!enumIntrospection.enumValues) {
        const enumIntrospectionStr = inspect(enumIntrospection);
        throw new Error(
          `Introspection result missing enumValues: ${enumIntrospectionStr}.`
        );
      }
      return new GraphQLEnumType({
        name: enumIntrospection.name,
        description: enumIntrospection.description,
        values: keyValMap(
          enumIntrospection.enumValues,
          (valueIntrospection) => valueIntrospection.name,
          (valueIntrospection) => ({
            description: valueIntrospection.description,
            deprecationReason: valueIntrospection.deprecationReason
          })
        )
      });
    }
    function buildInputObjectDef(inputObjectIntrospection) {
      if (!inputObjectIntrospection.inputFields) {
        const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
        throw new Error(
          `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
        );
      }
      return new GraphQLInputObjectType({
        name: inputObjectIntrospection.name,
        description: inputObjectIntrospection.description,
        fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),
        isOneOf: inputObjectIntrospection.isOneOf
      });
    }
    function buildFieldDefMap(typeIntrospection) {
      if (!typeIntrospection.fields) {
        throw new Error(
          `Introspection result missing fields: ${inspect(typeIntrospection)}.`
        );
      }
      return keyValMap(
        typeIntrospection.fields,
        (fieldIntrospection) => fieldIntrospection.name,
        buildField
      );
    }
    function buildField(fieldIntrospection) {
      const type2 = getType(fieldIntrospection.type);
      if (!isOutputType(type2)) {
        const typeStr = inspect(type2);
        throw new Error(
          `Introspection must provide output type for fields, but received: ${typeStr}.`
        );
      }
      if (!fieldIntrospection.args) {
        const fieldIntrospectionStr = inspect(fieldIntrospection);
        throw new Error(
          `Introspection result missing field args: ${fieldIntrospectionStr}.`
        );
      }
      return {
        description: fieldIntrospection.description,
        deprecationReason: fieldIntrospection.deprecationReason,
        type: type2,
        args: buildInputValueDefMap(fieldIntrospection.args)
      };
    }
    function buildInputValueDefMap(inputValueIntrospections) {
      return keyValMap(
        inputValueIntrospections,
        (inputValue) => inputValue.name,
        buildInputValue
      );
    }
    function buildInputValue(inputValueIntrospection) {
      const type2 = getType(inputValueIntrospection.type);
      if (!isInputType(type2)) {
        const typeStr = inspect(type2);
        throw new Error(
          `Introspection must provide input type for arguments, but received: ${typeStr}.`
        );
      }
      const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type2) : void 0;
      return {
        description: inputValueIntrospection.description,
        type: type2,
        defaultValue,
        deprecationReason: inputValueIntrospection.deprecationReason
      };
    }
    function buildDirective(directiveIntrospection) {
      if (!directiveIntrospection.args) {
        const directiveIntrospectionStr = inspect(directiveIntrospection);
        throw new Error(
          `Introspection result missing directive args: ${directiveIntrospectionStr}.`
        );
      }
      if (!directiveIntrospection.locations) {
        const directiveIntrospectionStr = inspect(directiveIntrospection);
        throw new Error(
          `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
        );
      }
      return new GraphQLDirective({
        name: directiveIntrospection.name,
        description: directiveIntrospection.description,
        isRepeatable: directiveIntrospection.isRepeatable,
        locations: directiveIntrospection.locations.slice(),
        args: buildInputValueDefMap(directiveIntrospection.args)
      });
    }
  }

  // node_modules/graphql/utilities/extendSchema.mjs
  function extendSchemaImpl(schemaConfig, documentAST, options) {
    var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
    const typeDefs = [];
    const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
    const directiveDefs = [];
    let schemaDef;
    const schemaExtensions = [];
    for (const def of documentAST.definitions) {
      if (def.kind === Kind.SCHEMA_DEFINITION) {
        schemaDef = def;
      } else if (def.kind === Kind.SCHEMA_EXTENSION) {
        schemaExtensions.push(def);
      } else if (isTypeDefinitionNode(def)) {
        typeDefs.push(def);
      } else if (isTypeExtensionNode(def)) {
        const extendedTypeName = def.name.value;
        const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
      } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        directiveDefs.push(def);
      }
    }
    if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
      return schemaConfig;
    }
    const typeMap = /* @__PURE__ */ Object.create(null);
    for (const existingType of schemaConfig.types) {
      typeMap[existingType.name] = extendNamedType(existingType);
    }
    for (const typeNode of typeDefs) {
      var _stdTypeMap$name;
      const name2 = typeNode.name.value;
      typeMap[name2] = (_stdTypeMap$name = stdTypeMap[name2]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
    }
    const operationTypes = {
      // Get the extended root operation types.
      query: schemaConfig.query && replaceNamedType(schemaConfig.query),
      mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
      subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
      // Then, incorporate schema definition and all schema extensions.
      ...schemaDef && getOperationTypes([schemaDef]),
      ...getOperationTypes(schemaExtensions)
    };
    return {
      description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
      ...operationTypes,
      types: Object.values(typeMap),
      directives: [
        ...schemaConfig.directives.map(replaceDirective),
        ...directiveDefs.map(buildDirective)
      ],
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
      extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
      assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
    };
    function replaceType(type2) {
      if (isListType(type2)) {
        return new GraphQLList(replaceType(type2.ofType));
      }
      if (isNonNullType(type2)) {
        return new GraphQLNonNull(replaceType(type2.ofType));
      }
      return replaceNamedType(type2);
    }
    function replaceNamedType(type2) {
      return typeMap[type2.name];
    }
    function replaceDirective(directive) {
      const config = directive.toConfig();
      return new GraphQLDirective({
        ...config,
        args: mapValue(config.args, extendArg)
      });
    }
    function extendNamedType(type2) {
      if (isIntrospectionType(type2) || isSpecifiedScalarType(type2)) {
        return type2;
      }
      if (isScalarType(type2)) {
        return extendScalarType(type2);
      }
      if (isObjectType(type2)) {
        return extendObjectType(type2);
      }
      if (isInterfaceType(type2)) {
        return extendInterfaceType(type2);
      }
      if (isUnionType(type2)) {
        return extendUnionType(type2);
      }
      if (isEnumType(type2)) {
        return extendEnumType(type2);
      }
      if (isInputObjectType(type2)) {
        return extendInputObjectType(type2);
      }
      invariant(false, "Unexpected type: " + inspect(type2));
    }
    function extendInputObjectType(type2) {
      var _typeExtensionsMap$co;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
      return new GraphQLInputObjectType({
        ...config,
        fields: () => ({
          ...mapValue(config.fields, (field) => ({
            ...field,
            type: replaceType(field.type)
          })),
          ...buildInputFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendEnumType(type2) {
      var _typeExtensionsMap$ty;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
      return new GraphQLEnumType({
        ...config,
        values: { ...config.values, ...buildEnumValueMap(extensions) },
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendScalarType(type2) {
      var _typeExtensionsMap$co2;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
      let specifiedByURL = config.specifiedByURL;
      for (const extensionNode of extensions) {
        var _getSpecifiedByURL;
        specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
      }
      return new GraphQLScalarType({
        ...config,
        specifiedByURL,
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendObjectType(type2) {
      var _typeExtensionsMap$co3;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
      return new GraphQLObjectType({
        ...config,
        interfaces: () => [
          ...type2.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => ({
          ...mapValue(config.fields, extendField),
          ...buildFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendInterfaceType(type2) {
      var _typeExtensionsMap$co4;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => [
          ...type2.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => ({
          ...mapValue(config.fields, extendField),
          ...buildFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendUnionType(type2) {
      var _typeExtensionsMap$co5;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
      return new GraphQLUnionType({
        ...config,
        types: () => [
          ...type2.getTypes().map(replaceNamedType),
          ...buildUnionTypes(extensions)
        ],
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendField(field) {
      return {
        ...field,
        type: replaceType(field.type),
        args: field.args && mapValue(field.args, extendArg)
      };
    }
    function extendArg(arg) {
      return { ...arg, type: replaceType(arg.type) };
    }
    function getOperationTypes(nodes) {
      const opTypes = {};
      for (const node of nodes) {
        var _node$operationTypes;
        const operationTypesNodes = (
          /* c8 ignore next */
          (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
        );
        for (const operationType of operationTypesNodes) {
          opTypes[operationType.operation] = getNamedType2(operationType.type);
        }
      }
      return opTypes;
    }
    function getNamedType2(node) {
      var _stdTypeMap$name2;
      const name2 = node.name.value;
      const type2 = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];
      if (type2 === void 0) {
        throw new Error(`Unknown type: "${name2}".`);
      }
      return type2;
    }
    function getWrappedType(node) {
      if (node.kind === Kind.LIST_TYPE) {
        return new GraphQLList(getWrappedType(node.type));
      }
      if (node.kind === Kind.NON_NULL_TYPE) {
        return new GraphQLNonNull(getWrappedType(node.type));
      }
      return getNamedType2(node);
    }
    function buildDirective(node) {
      var _node$description;
      return new GraphQLDirective({
        name: node.name.value,
        description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
        // @ts-expect-error
        locations: node.locations.map(({ value }) => value),
        isRepeatable: node.repeatable,
        args: buildArgumentMap(node.arguments),
        astNode: node
      });
    }
    function buildFieldMap(nodes) {
      const fieldConfigMap = /* @__PURE__ */ Object.create(null);
      for (const node of nodes) {
        var _node$fields;
        const nodeFields = (
          /* c8 ignore next */
          (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
        );
        for (const field of nodeFields) {
          var _field$description;
          fieldConfigMap[field.name.value] = {
            // Note: While this could make assertions to get the correctly typed
            // value, that would throw immediately while type system validation
            // with validateSchema() will produce more actionable results.
            type: getWrappedType(field.type),
            description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
            args: buildArgumentMap(field.arguments),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return fieldConfigMap;
    }
    function buildArgumentMap(args) {
      const argsNodes = (
        /* c8 ignore next */
        args !== null && args !== void 0 ? args : []
      );
      const argConfigMap = /* @__PURE__ */ Object.create(null);
      for (const arg of argsNodes) {
        var _arg$description;
        const type2 = getWrappedType(arg.type);
        argConfigMap[arg.name.value] = {
          type: type2,
          description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
          defaultValue: valueFromAST(arg.defaultValue, type2),
          deprecationReason: getDeprecationReason(arg),
          astNode: arg
        };
      }
      return argConfigMap;
    }
    function buildInputFieldMap(nodes) {
      const inputFieldMap = /* @__PURE__ */ Object.create(null);
      for (const node of nodes) {
        var _node$fields2;
        const fieldsNodes = (
          /* c8 ignore next */
          (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
        );
        for (const field of fieldsNodes) {
          var _field$description2;
          const type2 = getWrappedType(field.type);
          inputFieldMap[field.name.value] = {
            type: type2,
            description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
            defaultValue: valueFromAST(field.defaultValue, type2),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return inputFieldMap;
    }
    function buildEnumValueMap(nodes) {
      const enumValueMap = /* @__PURE__ */ Object.create(null);
      for (const node of nodes) {
        var _node$values;
        const valuesNodes = (
          /* c8 ignore next */
          (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
        );
        for (const value of valuesNodes) {
          var _value$description;
          enumValueMap[value.name.value] = {
            description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
            deprecationReason: getDeprecationReason(value),
            astNode: value
          };
        }
      }
      return enumValueMap;
    }
    function buildInterfaces(nodes) {
      return nodes.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (node) => {
          var _node$interfaces$map, _node$interfaces;
          return (
            /* c8 ignore next */
            (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
          );
        }
      );
    }
    function buildUnionTypes(nodes) {
      return nodes.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (node) => {
          var _node$types$map, _node$types;
          return (
            /* c8 ignore next */
            (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
          );
        }
      );
    }
    function buildType(astNode) {
      var _typeExtensionsMap$na;
      const name2 = astNode.name.value;
      const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
      switch (astNode.kind) {
        case Kind.OBJECT_TYPE_DEFINITION: {
          var _astNode$description;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLObjectType({
            name: name2,
            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.INTERFACE_TYPE_DEFINITION: {
          var _astNode$description2;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLInterfaceType({
            name: name2,
            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.ENUM_TYPE_DEFINITION: {
          var _astNode$description3;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLEnumType({
            name: name2,
            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
            values: buildEnumValueMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.UNION_TYPE_DEFINITION: {
          var _astNode$description4;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLUnionType({
            name: name2,
            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
            types: () => buildUnionTypes(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.SCALAR_TYPE_DEFINITION: {
          var _astNode$description5;
          return new GraphQLScalarType({
            name: name2,
            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
            specifiedByURL: getSpecifiedByURL(astNode),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var _astNode$description6;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLInputObjectType({
            name: name2,
            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
            fields: () => buildInputFieldMap(allNodes),
            astNode,
            extensionASTNodes,
            isOneOf: isOneOf(astNode)
          });
        }
      }
    }
  }
  var stdTypeMap = keyMap(
    [...specifiedScalarTypes, ...introspectionTypes],
    (type2) => type2.name
  );
  function getDeprecationReason(node) {
    const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
    return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
  }
  function getSpecifiedByURL(node) {
    const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
    return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
  }
  function isOneOf(node) {
    return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));
  }

  // node_modules/graphql/utilities/buildASTSchema.mjs
  function buildASTSchema(documentAST, options) {
    documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
    if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
      assertValidSDL(documentAST);
    }
    const emptySchemaConfig = {
      description: void 0,
      types: [],
      directives: [],
      extensions: /* @__PURE__ */ Object.create(null),
      extensionASTNodes: [],
      assumeValid: false
    };
    const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
    if (config.astNode == null) {
      for (const type2 of config.types) {
        switch (type2.name) {
          // Note: While this could make early assertions to get the correctly
          // typed values below, that would throw immediately while type system
          // validation with validateSchema() will produce more actionable results.
          case "Query":
            config.query = type2;
            break;
          case "Mutation":
            config.mutation = type2;
            break;
          case "Subscription":
            config.subscription = type2;
            break;
        }
      }
    }
    const directives = [
      ...config.directives,
      // If specified directives were not explicitly declared, add them.
      ...specifiedDirectives.filter(
        (stdDirective) => config.directives.every(
          (directive) => directive.name !== stdDirective.name
        )
      )
    ];
    return new GraphQLSchema({ ...config, directives });
  }

  // node_modules/graphql-language-service/esm/interface/autocompleteUtils.js
  function objectValues(object) {
    const keys = Object.keys(object);
    const len = keys.length;
    const values = new Array(len);
    for (let i = 0; i < len; ++i) {
      values[i] = object[keys[i]];
    }
    return values;
  }
  function hintList(token, list2) {
    return filterAndSortList(list2, normalizeText(token.string));
  }
  function filterAndSortList(list2, text3) {
    if (!text3 || text3.trim() === "" || text3.trim() === ":" || text3.trim() === "{") {
      return filterNonEmpty(list2, (entry) => !entry.isDeprecated);
    }
    const byProximity = list2.map((entry) => ({
      proximity: getProximity(normalizeText(entry.label), text3),
      entry
    }));
    return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b2) => (a.entry.isDeprecated ? 1 : 0) - (b2.entry.isDeprecated ? 1 : 0) || a.proximity - b2.proximity || a.entry.label.length - b2.entry.label.length).map((pair) => pair.entry);
  }
  function filterNonEmpty(array, predicate) {
    const filtered = array.filter(predicate);
    return filtered.length === 0 ? array : filtered;
  }
  function normalizeText(text3) {
    return text3.toLowerCase().replaceAll(/\W/g, "");
  }
  function getProximity(suggestion, text3) {
    let proximity = lexicalDistance(text3, suggestion);
    if (suggestion.length > text3.length) {
      proximity -= suggestion.length - text3.length - 1;
      proximity += suggestion.indexOf(text3) === 0 ? 0 : 0.5;
    }
    return proximity;
  }
  function lexicalDistance(a, b2) {
    let i;
    let j2;
    const d = [];
    const aLength = a.length;
    const bLength = b2.length;
    for (i = 0; i <= aLength; i++) {
      d[i] = [i];
    }
    for (j2 = 1; j2 <= bLength; j2++) {
      d[0][j2] = j2;
    }
    for (i = 1; i <= aLength; i++) {
      for (j2 = 1; j2 <= bLength; j2++) {
        const cost = a[i - 1] === b2[j2 - 1] ? 0 : 1;
        d[i][j2] = Math.min(d[i - 1][j2] + 1, d[i][j2 - 1] + 1, d[i - 1][j2 - 1] + cost);
        if (i > 1 && j2 > 1 && a[i - 1] === b2[j2 - 2] && a[i - 2] === b2[j2 - 1]) {
          d[i][j2] = Math.min(d[i][j2], d[i - 2][j2 - 2] + cost);
        }
      }
    }
    return d[aLength][bLength];
  }
  var insertSuffix = (n) => ` {
   $${n !== null && n !== void 0 ? n : 1}
}`;
  var getInsertText = (prefix, type2, fallback) => {
    if (!type2) {
      return fallback !== null && fallback !== void 0 ? fallback : prefix;
    }
    const namedType = getNamedType(type2);
    if (isObjectType(namedType) || isInputObjectType(namedType) || isListType(namedType) || isAbstractType(namedType)) {
      return prefix + insertSuffix();
    }
    return fallback !== null && fallback !== void 0 ? fallback : prefix;
  };
  var getInputInsertText = (prefix, type2, fallback) => {
    if (isListType(type2)) {
      const baseType = getNamedType(type2.ofType);
      return prefix + `[${getInsertText("", baseType, "$1")}]`;
    }
    return getInsertText(prefix, type2, fallback);
  };
  var getFieldInsertText = (field) => {
    const requiredArgs = field.args.filter((arg) => arg.type.toString().endsWith("!"));
    if (!requiredArgs.length) {
      return;
    }
    return field.name + `(${requiredArgs.map((arg, i) => `${arg.name}: $${i + 1}`)}) ${getInsertText("", field.type, "\n")}`;
  };

  // node_modules/vscode-languageserver-types/lib/esm/main.js
  var DocumentUri;
  (function(DocumentUri2) {
    function is(value) {
      return typeof value === "string";
    }
    DocumentUri2.is = is;
  })(DocumentUri || (DocumentUri = {}));
  var URI2;
  (function(URI3) {
    function is(value) {
      return typeof value === "string";
    }
    URI3.is = is;
  })(URI2 || (URI2 = {}));
  var integer;
  (function(integer2) {
    integer2.MIN_VALUE = -2147483648;
    integer2.MAX_VALUE = 2147483647;
    function is(value) {
      return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
    }
    integer2.is = is;
  })(integer || (integer = {}));
  var uinteger;
  (function(uinteger2) {
    uinteger2.MIN_VALUE = 0;
    uinteger2.MAX_VALUE = 2147483647;
    function is(value) {
      return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
    }
    uinteger2.is = is;
  })(uinteger || (uinteger = {}));
  var Position2;
  (function(Position4) {
    function create(line, character) {
      if (line === Number.MAX_VALUE) {
        line = uinteger.MAX_VALUE;
      }
      if (character === Number.MAX_VALUE) {
        character = uinteger.MAX_VALUE;
      }
      return { line, character };
    }
    Position4.create = create;
    function is(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position4.is = is;
  })(Position2 || (Position2 = {}));
  var Range2;
  (function(Range4) {
    function create(one, two, three, four) {
      if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
        return { start: Position2.create(one, two), end: Position2.create(three, four) };
      } else if (Position2.is(one) && Position2.is(two)) {
        return { start: one, end: two };
      } else {
        throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
      }
    }
    Range4.create = create;
    function is(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
    }
    Range4.is = is;
  })(Range2 || (Range2 = {}));
  var Location2;
  (function(Location3) {
    function create(uri, range) {
      return { uri, range };
    }
    Location3.create = create;
    function is(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location3.is = is;
  })(Location2 || (Location2 = {}));
  var LocationLink;
  (function(LocationLink2) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
    }
    LocationLink2.create = create;
    function is(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink2.is = is;
  })(LocationLink || (LocationLink = {}));
  var Color2;
  (function(Color3) {
    function create(red, green, blue, alpha) {
      return {
        red,
        green,
        blue,
        alpha
      };
    }
    Color3.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color3.is = is;
  })(Color2 || (Color2 = {}));
  var ColorInformation;
  (function(ColorInformation2) {
    function create(range, color) {
      return {
        range,
        color
      };
    }
    ColorInformation2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.range) && Color2.is(candidate.color);
    }
    ColorInformation2.is = is;
  })(ColorInformation || (ColorInformation = {}));
  var ColorPresentation;
  (function(ColorPresentation2) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation2.is = is;
  })(ColorPresentation || (ColorPresentation = {}));
  var FoldingRangeKind2;
  (function(FoldingRangeKind3) {
    FoldingRangeKind3.Comment = "comment";
    FoldingRangeKind3.Imports = "imports";
    FoldingRangeKind3.Region = "region";
  })(FoldingRangeKind2 || (FoldingRangeKind2 = {}));
  var FoldingRange;
  (function(FoldingRange2) {
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
      const result = {
        startLine,
        endLine
      };
      if (Is.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is.defined(kind)) {
        result.kind = kind;
      }
      if (Is.defined(collapsedText)) {
        result.collapsedText = collapsedText;
      }
      return result;
    }
    FoldingRange2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange2.is = is;
  })(FoldingRange || (FoldingRange = {}));
  var DiagnosticRelatedInformation;
  (function(DiagnosticRelatedInformation2) {
    function create(location, message) {
      return {
        location,
        message
      };
    }
    DiagnosticRelatedInformation2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Location2.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation2.is = is;
  })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
  var DiagnosticSeverity;
  (function(DiagnosticSeverity2) {
    DiagnosticSeverity2.Error = 1;
    DiagnosticSeverity2.Warning = 2;
    DiagnosticSeverity2.Information = 3;
    DiagnosticSeverity2.Hint = 4;
  })(DiagnosticSeverity || (DiagnosticSeverity = {}));
  var DiagnosticTag;
  (function(DiagnosticTag2) {
    DiagnosticTag2.Unnecessary = 1;
    DiagnosticTag2.Deprecated = 2;
  })(DiagnosticTag || (DiagnosticTag = {}));
  var CodeDescription;
  (function(CodeDescription2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription2.is = is;
  })(CodeDescription || (CodeDescription = {}));
  var Diagnostic;
  (function(Diagnostic2) {
    function create(range, message, severity, code, source, relatedInformation) {
      let result = { range, message };
      if (Is.defined(severity)) {
        result.severity = severity;
      }
      if (Is.defined(code)) {
        result.code = code;
      }
      if (Is.defined(source)) {
        result.source = source;
      }
      if (Is.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic2.create = create;
    function is(value) {
      var _a3;
      let candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a3 = candidate.codeDescription) === null || _a3 === void 0 ? void 0 : _a3.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic2.is = is;
  })(Diagnostic || (Diagnostic = {}));
  var Command2;
  (function(Command3) {
    function create(title, command, ...args) {
      let result = { title, command };
      if (Is.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command3.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command3.is = is;
  })(Command2 || (Command2 = {}));
  var TextEdit;
  (function(TextEdit2) {
    function replace(range, newText) {
      return { range, newText };
    }
    TextEdit2.replace = replace;
    function insert(position, newText) {
      return { range: { start: position, end: position }, newText };
    }
    TextEdit2.insert = insert;
    function del(range) {
      return { range, newText: "" };
    }
    TextEdit2.del = del;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
    }
    TextEdit2.is = is;
  })(TextEdit || (TextEdit = {}));
  var ChangeAnnotation;
  (function(ChangeAnnotation2) {
    function create(label, needsConfirmation, description) {
      const result = { label };
      if (needsConfirmation !== void 0) {
        result.needsConfirmation = needsConfirmation;
      }
      if (description !== void 0) {
        result.description = description;
      }
      return result;
    }
    ChangeAnnotation2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    ChangeAnnotation2.is = is;
  })(ChangeAnnotation || (ChangeAnnotation = {}));
  var ChangeAnnotationIdentifier;
  (function(ChangeAnnotationIdentifier2) {
    function is(value) {
      const candidate = value;
      return Is.string(candidate);
    }
    ChangeAnnotationIdentifier2.is = is;
  })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
  var AnnotatedTextEdit;
  (function(AnnotatedTextEdit2) {
    function replace(range, newText, annotation) {
      return { range, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.replace = replace;
    function insert(position, newText, annotation) {
      return { range: { start: position, end: position }, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.insert = insert;
    function del(range, annotation) {
      return { range, newText: "", annotationId: annotation };
    }
    AnnotatedTextEdit2.del = del;
    function is(value) {
      const candidate = value;
      return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit2.is = is;
  })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
  var TextDocumentEdit;
  (function(TextDocumentEdit2) {
    function create(textDocument, edits) {
      return { textDocument, edits };
    }
    TextDocumentEdit2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit2.is = is;
  })(TextDocumentEdit || (TextDocumentEdit = {}));
  var CreateFile;
  (function(CreateFile2) {
    function create(uri, options, annotation) {
      let result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    CreateFile2.create = create;
    function is(value) {
      let candidate = value;
      return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile2.is = is;
  })(CreateFile || (CreateFile = {}));
  var RenameFile;
  (function(RenameFile2) {
    function create(oldUri, newUri, options, annotation) {
      let result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    RenameFile2.create = create;
    function is(value) {
      let candidate = value;
      return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile2.is = is;
  })(RenameFile || (RenameFile = {}));
  var DeleteFile;
  (function(DeleteFile2) {
    function create(uri, options, annotation) {
      let result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    DeleteFile2.create = create;
    function is(value) {
      let candidate = value;
      return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile2.is = is;
  })(DeleteFile || (DeleteFile = {}));
  var WorkspaceEdit;
  (function(WorkspaceEdit2) {
    function is(value) {
      let candidate = value;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
        if (Is.string(change.kind)) {
          return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
        } else {
          return TextDocumentEdit.is(change);
        }
      }));
    }
    WorkspaceEdit2.is = is;
  })(WorkspaceEdit || (WorkspaceEdit = {}));
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return { uri };
    }
    TextDocumentIdentifier2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return { uri, version };
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier2.is = is;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var OptionalVersionedTextDocumentIdentifier;
  (function(OptionalVersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return { uri, version };
    }
    OptionalVersionedTextDocumentIdentifier2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier2.is = is;
  })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId, version, text3) {
      return { uri, languageId, version, text: text3 };
    }
    TextDocumentItem2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem2.is = is;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind;
  (function(MarkupKind2) {
    MarkupKind2.PlainText = "plaintext";
    MarkupKind2.Markdown = "markdown";
    function is(value) {
      const candidate = value;
      return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
    }
    MarkupKind2.is = is;
  })(MarkupKind || (MarkupKind = {}));
  var MarkupContent;
  (function(MarkupContent2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent2.is = is;
  })(MarkupContent || (MarkupContent = {}));
  var CompletionItemKind2;
  (function(CompletionItemKind4) {
    CompletionItemKind4.Text = 1;
    CompletionItemKind4.Method = 2;
    CompletionItemKind4.Function = 3;
    CompletionItemKind4.Constructor = 4;
    CompletionItemKind4.Field = 5;
    CompletionItemKind4.Variable = 6;
    CompletionItemKind4.Class = 7;
    CompletionItemKind4.Interface = 8;
    CompletionItemKind4.Module = 9;
    CompletionItemKind4.Property = 10;
    CompletionItemKind4.Unit = 11;
    CompletionItemKind4.Value = 12;
    CompletionItemKind4.Enum = 13;
    CompletionItemKind4.Keyword = 14;
    CompletionItemKind4.Snippet = 15;
    CompletionItemKind4.Color = 16;
    CompletionItemKind4.File = 17;
    CompletionItemKind4.Reference = 18;
    CompletionItemKind4.Folder = 19;
    CompletionItemKind4.EnumMember = 20;
    CompletionItemKind4.Constant = 21;
    CompletionItemKind4.Struct = 22;
    CompletionItemKind4.Event = 23;
    CompletionItemKind4.Operator = 24;
    CompletionItemKind4.TypeParameter = 25;
  })(CompletionItemKind2 || (CompletionItemKind2 = {}));
  var InsertTextFormat;
  (function(InsertTextFormat2) {
    InsertTextFormat2.PlainText = 1;
    InsertTextFormat2.Snippet = 2;
  })(InsertTextFormat || (InsertTextFormat = {}));
  var CompletionItemTag2;
  (function(CompletionItemTag3) {
    CompletionItemTag3.Deprecated = 1;
  })(CompletionItemTag2 || (CompletionItemTag2 = {}));
  var InsertReplaceEdit;
  (function(InsertReplaceEdit2) {
    function create(newText, insert, replace) {
      return { newText, insert, replace };
    }
    InsertReplaceEdit2.create = create;
    function is(value) {
      const candidate = value;
      return candidate && Is.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
    }
    InsertReplaceEdit2.is = is;
  })(InsertReplaceEdit || (InsertReplaceEdit = {}));
  var InsertTextMode;
  (function(InsertTextMode2) {
    InsertTextMode2.asIs = 1;
    InsertTextMode2.adjustIndentation = 2;
  })(InsertTextMode || (InsertTextMode = {}));
  var CompletionItemLabelDetails;
  (function(CompletionItemLabelDetails2) {
    function is(value) {
      const candidate = value;
      return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    CompletionItemLabelDetails2.is = is;
  })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
  var CompletionItem;
  (function(CompletionItem2) {
    function create(label) {
      return { label };
    }
    CompletionItem2.create = create;
  })(CompletionItem || (CompletionItem = {}));
  var CompletionList;
  (function(CompletionList2) {
    function create(items, isIncomplete) {
      return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList2.create = create;
  })(CompletionList || (CompletionList = {}));
  var MarkedString;
  (function(MarkedString2) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString2.fromPlainText = fromPlainText;
    function is(value) {
      const candidate = value;
      return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString2.is = is;
  })(MarkedString || (MarkedString = {}));
  var Hover;
  (function(Hover2) {
    function is(value) {
      let candidate = value;
      return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
    }
    Hover2.is = is;
  })(Hover || (Hover = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? { label, documentation } : { label };
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation, ...parameters) {
      let result = { label };
      if (Is.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind3;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4.Text = 1;
    DocumentHighlightKind4.Read = 2;
    DocumentHighlightKind4.Write = 3;
  })(DocumentHighlightKind3 || (DocumentHighlightKind3 = {}));
  var DocumentHighlight;
  (function(DocumentHighlight2) {
    function create(range, kind) {
      let result = { range };
      if (Is.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight2.create = create;
  })(DocumentHighlight || (DocumentHighlight = {}));
  var SymbolKind2;
  (function(SymbolKind3) {
    SymbolKind3.File = 1;
    SymbolKind3.Module = 2;
    SymbolKind3.Namespace = 3;
    SymbolKind3.Package = 4;
    SymbolKind3.Class = 5;
    SymbolKind3.Method = 6;
    SymbolKind3.Property = 7;
    SymbolKind3.Field = 8;
    SymbolKind3.Constructor = 9;
    SymbolKind3.Enum = 10;
    SymbolKind3.Interface = 11;
    SymbolKind3.Function = 12;
    SymbolKind3.Variable = 13;
    SymbolKind3.Constant = 14;
    SymbolKind3.String = 15;
    SymbolKind3.Number = 16;
    SymbolKind3.Boolean = 17;
    SymbolKind3.Array = 18;
    SymbolKind3.Object = 19;
    SymbolKind3.Key = 20;
    SymbolKind3.Null = 21;
    SymbolKind3.EnumMember = 22;
    SymbolKind3.Struct = 23;
    SymbolKind3.Event = 24;
    SymbolKind3.Operator = 25;
    SymbolKind3.TypeParameter = 26;
  })(SymbolKind2 || (SymbolKind2 = {}));
  var SymbolTag2;
  (function(SymbolTag3) {
    SymbolTag3.Deprecated = 1;
  })(SymbolTag2 || (SymbolTag2 = {}));
  var SymbolInformation;
  (function(SymbolInformation2) {
    function create(name2, kind, range, uri, containerName) {
      let result = {
        name: name2,
        kind,
        location: { uri, range }
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation2.create = create;
  })(SymbolInformation || (SymbolInformation = {}));
  var WorkspaceSymbol;
  (function(WorkspaceSymbol2) {
    function create(name2, kind, uri, range) {
      return range !== void 0 ? { name: name2, kind, location: { uri, range } } : { name: name2, kind, location: { uri } };
    }
    WorkspaceSymbol2.create = create;
  })(WorkspaceSymbol || (WorkspaceSymbol = {}));
  var DocumentSymbol;
  (function(DocumentSymbol2) {
    function create(name2, detail, kind, range, selectionRange, children) {
      let result = {
        name: name2,
        detail,
        kind,
        range,
        selectionRange
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol2.create = create;
    function is(value) {
      let candidate = value;
      return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
    }
    DocumentSymbol2.is = is;
  })(DocumentSymbol || (DocumentSymbol = {}));
  var CodeActionKind;
  (function(CodeActionKind2) {
    CodeActionKind2.Empty = "";
    CodeActionKind2.QuickFix = "quickfix";
    CodeActionKind2.Refactor = "refactor";
    CodeActionKind2.RefactorExtract = "refactor.extract";
    CodeActionKind2.RefactorInline = "refactor.inline";
    CodeActionKind2.RefactorRewrite = "refactor.rewrite";
    CodeActionKind2.Source = "source";
    CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind2.SourceFixAll = "source.fixAll";
  })(CodeActionKind || (CodeActionKind = {}));
  var CodeActionTriggerKind;
  (function(CodeActionTriggerKind2) {
    CodeActionTriggerKind2.Invoked = 1;
    CodeActionTriggerKind2.Automatic = 2;
  })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
  var CodeActionContext;
  (function(CodeActionContext2) {
    function create(diagnostics, only, triggerKind) {
      let result = { diagnostics };
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      if (triggerKind !== void 0 && triggerKind !== null) {
        result.triggerKind = triggerKind;
      }
      return result;
    }
    CodeActionContext2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext2.is = is;
  })(CodeActionContext || (CodeActionContext = {}));
  var CodeAction;
  (function(CodeAction2) {
    function create(title, kindOrCommandOrEdit, kind) {
      let result = { title };
      let checkKind = true;
      if (typeof kindOrCommandOrEdit === "string") {
        checkKind = false;
        result.kind = kindOrCommandOrEdit;
      } else if (Command2.is(kindOrCommandOrEdit)) {
        result.command = kindOrCommandOrEdit;
      } else {
        result.edit = kindOrCommandOrEdit;
      }
      if (checkKind && kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction2.create = create;
    function is(value) {
      let candidate = value;
      return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction2.is = is;
  })(CodeAction || (CodeAction = {}));
  var CodeLens;
  (function(CodeLens2) {
    function create(range, data) {
      let result = { range };
      if (Is.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
    }
    CodeLens2.is = is;
  })(CodeLens || (CodeLens = {}));
  var FormattingOptions;
  (function(FormattingOptions2) {
    function create(tabSize, insertSpaces) {
      return { tabSize, insertSpaces };
    }
    FormattingOptions2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions2.is = is;
  })(FormattingOptions || (FormattingOptions = {}));
  var DocumentLink;
  (function(DocumentLink2) {
    function create(range, target, data) {
      return { range, target, data };
    }
    DocumentLink2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink2.is = is;
  })(DocumentLink || (DocumentLink = {}));
  var SelectionRange;
  (function(SelectionRange2) {
    function create(range, parent) {
      return { range, parent };
    }
    SelectionRange2.create = create;
    function is(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
    }
    SelectionRange2.is = is;
  })(SelectionRange || (SelectionRange = {}));
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["enumMember"] = "enumMember";
    SemanticTokenTypes2["event"] = "event";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["method"] = "method";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["modifier"] = "modifier";
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
    SemanticTokenTypes2["decorator"] = "decorator";
  })(SemanticTokenTypes || (SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["readonly"] = "readonly";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["modification"] = "modification";
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
  })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is;
  })(SemanticTokens || (SemanticTokens = {}));
  var InlineValueText;
  (function(InlineValueText2) {
    function create(range, text3) {
      return { range, text: text3 };
    }
    InlineValueText2.create = create;
    function is(value) {
      const candidate = value;
      return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText2.is = is;
  })(InlineValueText || (InlineValueText = {}));
  var InlineValueVariableLookup;
  (function(InlineValueVariableLookup2) {
    function create(range, variableName, caseSensitiveLookup) {
      return { range, variableName, caseSensitiveLookup };
    }
    InlineValueVariableLookup2.create = create;
    function is(value) {
      const candidate = value;
      return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
    }
    InlineValueVariableLookup2.is = is;
  })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
  var InlineValueEvaluatableExpression;
  (function(InlineValueEvaluatableExpression2) {
    function create(range, expression) {
      return { range, expression };
    }
    InlineValueEvaluatableExpression2.create = create;
    function is(value) {
      const candidate = value;
      return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
    }
    InlineValueEvaluatableExpression2.is = is;
  })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
  var InlineValueContext;
  (function(InlineValueContext2) {
    function create(frameId, stoppedLocation) {
      return { frameId, stoppedLocation };
    }
    InlineValueContext2.create = create;
    function is(value) {
      const candidate = value;
      return Is.defined(candidate) && Range2.is(value.stoppedLocation);
    }
    InlineValueContext2.is = is;
  })(InlineValueContext || (InlineValueContext = {}));
  var InlayHintKind3;
  (function(InlayHintKind4) {
    InlayHintKind4.Type = 1;
    InlayHintKind4.Parameter = 2;
    function is(value) {
      return value === 1 || value === 2;
    }
    InlayHintKind4.is = is;
  })(InlayHintKind3 || (InlayHintKind3 = {}));
  var InlayHintLabelPart;
  (function(InlayHintLabelPart2) {
    function create(value) {
      return { value };
    }
    InlayHintLabelPart2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location2.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
    }
    InlayHintLabelPart2.is = is;
  })(InlayHintLabelPart || (InlayHintLabelPart = {}));
  var InlayHint;
  (function(InlayHint2) {
    function create(position, label, kind) {
      const result = { position, label };
      if (kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    InlayHint2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
    }
    InlayHint2.is = is;
  })(InlayHint || (InlayHint = {}));
  var StringValue;
  (function(StringValue2) {
    function createSnippet(value) {
      return { kind: "snippet", value };
    }
    StringValue2.createSnippet = createSnippet;
  })(StringValue || (StringValue = {}));
  var InlineCompletionItem;
  (function(InlineCompletionItem2) {
    function create(insertText, filterText, range, command) {
      return { insertText, filterText, range, command };
    }
    InlineCompletionItem2.create = create;
  })(InlineCompletionItem || (InlineCompletionItem = {}));
  var InlineCompletionList;
  (function(InlineCompletionList2) {
    function create(items) {
      return { items };
    }
    InlineCompletionList2.create = create;
  })(InlineCompletionList || (InlineCompletionList = {}));
  var InlineCompletionTriggerKind3;
  (function(InlineCompletionTriggerKind4) {
    InlineCompletionTriggerKind4.Invoked = 0;
    InlineCompletionTriggerKind4.Automatic = 1;
  })(InlineCompletionTriggerKind3 || (InlineCompletionTriggerKind3 = {}));
  var SelectedCompletionInfo;
  (function(SelectedCompletionInfo2) {
    function create(range, text3) {
      return { range, text: text3 };
    }
    SelectedCompletionInfo2.create = create;
  })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
  var InlineCompletionContext;
  (function(InlineCompletionContext2) {
    function create(triggerKind, selectedCompletionInfo) {
      return { triggerKind, selectedCompletionInfo };
    }
    InlineCompletionContext2.create = create;
  })(InlineCompletionContext || (InlineCompletionContext = {}));
  var WorkspaceFolder;
  (function(WorkspaceFolder2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder2.is = is;
  })(WorkspaceFolder || (WorkspaceFolder = {}));
  var TextDocument;
  (function(TextDocument2) {
    function create(uri, languageId, version, content) {
      return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument2.create = create;
    function is(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument2.is = is;
    function applyEdits(document2, edits) {
      let text3 = document2.getText();
      let sortedEdits = mergeSort(edits, (a, b2) => {
        let diff = a.range.start.line - b2.range.start.line;
        if (diff === 0) {
          return a.range.start.character - b2.range.start.character;
        }
        return diff;
      });
      let lastModifiedOffset = text3.length;
      for (let i = sortedEdits.length - 1; i >= 0; i--) {
        let e = sortedEdits[i];
        let startOffset = document2.offsetAt(e.range.start);
        let endOffset = document2.offsetAt(e.range.end);
        if (endOffset <= lastModifiedOffset) {
          text3 = text3.substring(0, startOffset) + e.newText + text3.substring(endOffset, text3.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text3;
    }
    TextDocument2.applyEdits = applyEdits;
    function mergeSort(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      const p2 = data.length / 2 | 0;
      const left = data.slice(0, p2);
      const right = data.slice(p2);
      mergeSort(left, compare);
      mergeSort(right, compare);
      let leftIdx = 0;
      let rightIdx = 0;
      let i = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        let ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
          data[i++] = left[leftIdx++];
        } else {
          data[i++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument || (TextDocument = {}));
  var FullTextDocument = class {
    constructor(uri, languageId, version, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version;
      this._content = content;
      this._lineOffsets = void 0;
    }
    get uri() {
      return this._uri;
    }
    get languageId() {
      return this._languageId;
    }
    get version() {
      return this._version;
    }
    getText(range) {
      if (range) {
        let start = this.offsetAt(range.start);
        let end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    }
    update(event, version) {
      this._content = event.text;
      this._version = version;
      this._lineOffsets = void 0;
    }
    getLineOffsets() {
      if (this._lineOffsets === void 0) {
        let lineOffsets = [];
        let text3 = this._content;
        let isLineStart = true;
        for (let i = 0; i < text3.length; i++) {
          if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
          }
          let ch = text3.charAt(i);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i + 1 < text3.length && text3.charAt(i + 1) === "\n") {
            i++;
          }
        }
        if (isLineStart && text3.length > 0) {
          lineOffsets.push(text3.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    }
    positionAt(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      let lineOffsets = this.getLineOffsets();
      let low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position2.create(0, offset);
      }
      while (low < high) {
        let mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      let line = low - 1;
      return Position2.create(line, offset - lineOffsets[line]);
    }
    offsetAt(position) {
      let lineOffsets = this.getLineOffsets();
      if (position.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position.line < 0) {
        return 0;
      }
      let lineOffset = lineOffsets[position.line];
      let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
      return this.getLineOffsets().length;
    }
  };
  var Is;
  (function(Is2) {
    const toString = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    Is2.defined = defined;
    function undefined2(value) {
      return typeof value === "undefined";
    }
    Is2.undefined = undefined2;
    function boolean(value) {
      return value === true || value === false;
    }
    Is2.boolean = boolean;
    function string(value) {
      return toString.call(value) === "[object String]";
    }
    Is2.string = string;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    Is2.number = number;
    function numberRange(value, min, max) {
      return toString.call(value) === "[object Number]" && min <= value && value <= max;
    }
    Is2.numberRange = numberRange;
    function integer2(value) {
      return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
    }
    Is2.integer = integer2;
    function uinteger2(value) {
      return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
    }
    Is2.uinteger = uinteger2;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    Is2.func = func;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    Is2.objectLiteral = objectLiteral;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    Is2.typedArray = typedArray;
  })(Is || (Is = {}));

  // node_modules/graphql-language-service/esm/parser/CharacterStream.js
  var CharacterStream = class {
    constructor(sourceText) {
      this._start = 0;
      this._pos = 0;
      this.getStartOfToken = () => this._start;
      this.getCurrentPosition = () => this._pos;
      this.eol = () => this._sourceText.length === this._pos;
      this.sol = () => this._pos === 0;
      this.peek = () => {
        return this._sourceText.charAt(this._pos) || null;
      };
      this.next = () => {
        const char = this._sourceText.charAt(this._pos);
        this._pos++;
        return char;
      };
      this.eat = (pattern) => {
        const isMatched = this._testNextCharacter(pattern);
        if (isMatched) {
          this._start = this._pos;
          this._pos++;
          return this._sourceText.charAt(this._pos - 1);
        }
        return void 0;
      };
      this.eatWhile = (match) => {
        let isMatched = this._testNextCharacter(match);
        let didEat = false;
        if (isMatched) {
          didEat = isMatched;
          this._start = this._pos;
        }
        while (isMatched) {
          this._pos++;
          isMatched = this._testNextCharacter(match);
          didEat = true;
        }
        return didEat;
      };
      this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
      this.skipToEnd = () => {
        this._pos = this._sourceText.length;
      };
      this.skipTo = (position) => {
        this._pos = position;
      };
      this.match = (pattern, consume = true, caseFold = false) => {
        let token = null;
        let match = null;
        if (typeof pattern === "string") {
          const regex = new RegExp(pattern, caseFold ? "i" : "g");
          match = regex.test(this._sourceText.slice(this._pos, this._pos + pattern.length));
          token = pattern;
        } else if (pattern instanceof RegExp) {
          match = this._sourceText.slice(this._pos).match(pattern);
          token = match === null || match === void 0 ? void 0 : match[0];
        }
        if (match != null && (typeof pattern === "string" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos))) {
          if (consume) {
            this._start = this._pos;
            if (token && token.length) {
              this._pos += token.length;
            }
          }
          return match;
        }
        return false;
      };
      this.backUp = (num) => {
        this._pos -= num;
      };
      this.column = () => this._pos;
      this.indentation = () => {
        const match = this._sourceText.match(/\s*/);
        let indent2 = 0;
        if (match && match.length !== 0) {
          const whiteSpaces = match[0];
          let pos = 0;
          while (whiteSpaces.length > pos) {
            if (whiteSpaces.charCodeAt(pos) === 9) {
              indent2 += 2;
            } else {
              indent2++;
            }
            pos++;
          }
        }
        return indent2;
      };
      this.current = () => this._sourceText.slice(this._start, this._pos);
      this._sourceText = sourceText;
    }
    _testNextCharacter(pattern) {
      const character = this._sourceText.charAt(this._pos);
      let isMatched = false;
      if (typeof pattern === "string") {
        isMatched = character === pattern;
      } else {
        isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
      }
      return isMatched;
    }
  };

  // node_modules/graphql-language-service/esm/parser/RuleHelpers.js
  function opt(ofRule) {
    return { ofRule };
  }
  function list(ofRule, separator) {
    return { ofRule, isList: true, separator };
  }
  function butNot(rule, exclusions) {
    const ruleMatch = rule.match;
    rule.match = (token) => {
      let check = false;
      if (ruleMatch) {
        check = ruleMatch(token);
      }
      return check && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token));
    };
    return rule;
  }
  function t(kind, style) {
    return { style, match: (token) => token.kind === kind };
  }
  function p(value, style) {
    return {
      style: style || "punctuation",
      match: (token) => token.kind === "Punctuation" && token.value === value
    };
  }

  // node_modules/graphql-language-service/esm/parser/Rules.js
  var isIgnored = (ch) => ch === " " || ch === "	" || ch === "," || ch === "\n" || ch === "\r" || ch === "\uFEFF" || ch === "\xA0";
  var LexRules = {
    Name: /^[_A-Za-z][_0-9A-Za-z]*/,
    Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
    Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
    String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
    Comment: /^#.*/
  };
  var ParseRules = {
    Document: [list("Definition")],
    Definition(token) {
      switch (token.value) {
        case "{":
          return "ShortQuery";
        case "query":
          return "Query";
        case "mutation":
          return "Mutation";
        case "subscription":
          return "Subscription";
        case "fragment":
          return Kind.FRAGMENT_DEFINITION;
        case "schema":
          return "SchemaDef";
        case "scalar":
          return "ScalarDef";
        case "type":
          return "ObjectTypeDef";
        case "interface":
          return "InterfaceDef";
        case "union":
          return "UnionDef";
        case "enum":
          return "EnumDef";
        case "input":
          return "InputDef";
        case "extend":
          return "ExtendDef";
        case "directive":
          return "DirectiveDef";
      }
    },
    ShortQuery: ["SelectionSet"],
    Query: [
      word("query"),
      opt(name("def")),
      opt("VariableDefinitions"),
      list("Directive"),
      "SelectionSet"
    ],
    Mutation: [
      word("mutation"),
      opt(name("def")),
      opt("VariableDefinitions"),
      list("Directive"),
      "SelectionSet"
    ],
    Subscription: [
      word("subscription"),
      opt(name("def")),
      opt("VariableDefinitions"),
      list("Directive"),
      "SelectionSet"
    ],
    VariableDefinitions: [p("("), list("VariableDefinition"), p(")")],
    VariableDefinition: ["Variable", p(":"), "Type", opt("DefaultValue")],
    Variable: [p("$", "variable"), name("variable")],
    DefaultValue: [p("="), "Value"],
    SelectionSet: [p("{"), list("Selection"), p("}")],
    Selection(token, stream) {
      return token.value === "..." ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? "InlineFragment" : "FragmentSpread" : stream.match(/[\s\u00a0,]*:/, false) ? "AliasedField" : "Field";
    },
    AliasedField: [
      name("property"),
      p(":"),
      name("qualifier"),
      opt("Arguments"),
      list("Directive"),
      opt("SelectionSet")
    ],
    Field: [
      name("property"),
      opt("Arguments"),
      list("Directive"),
      opt("SelectionSet")
    ],
    Arguments: [p("("), list("Argument"), p(")")],
    Argument: [name("attribute"), p(":"), "Value"],
    FragmentSpread: [p("..."), name("def"), list("Directive")],
    InlineFragment: [
      p("..."),
      opt("TypeCondition"),
      list("Directive"),
      "SelectionSet"
    ],
    FragmentDefinition: [
      word("fragment"),
      opt(butNot(name("def"), [word("on")])),
      "TypeCondition",
      list("Directive"),
      "SelectionSet"
    ],
    TypeCondition: [word("on"), "NamedType"],
    Value(token) {
      switch (token.kind) {
        case "Number":
          return "NumberValue";
        case "String":
          return "StringValue";
        case "Punctuation":
          switch (token.value) {
            case "[":
              return "ListValue";
            case "{":
              return "ObjectValue";
            case "$":
              return "Variable";
            case "&":
              return "NamedType";
          }
          return null;
        case "Name":
          switch (token.value) {
            case "true":
            case "false":
              return "BooleanValue";
          }
          if (token.value === "null") {
            return "NullValue";
          }
          return "EnumValue";
      }
    },
    NumberValue: [t("Number", "number")],
    StringValue: [
      {
        style: "string",
        match: (token) => token.kind === "String",
        update(state, token) {
          if (token.value.startsWith('"""')) {
            state.inBlockstring = !token.value.slice(3).endsWith('"""');
          }
        }
      }
    ],
    BooleanValue: [t("Name", "builtin")],
    NullValue: [t("Name", "keyword")],
    EnumValue: [name("string-2")],
    ListValue: [p("["), list("Value"), p("]")],
    ObjectValue: [p("{"), list("ObjectField"), p("}")],
    ObjectField: [name("attribute"), p(":"), "Value"],
    Type(token) {
      return token.value === "[" ? "ListType" : "NonNullType";
    },
    ListType: [p("["), "Type", p("]"), opt(p("!"))],
    NonNullType: ["NamedType", opt(p("!"))],
    NamedType: [type("atom")],
    Directive: [p("@", "meta"), name("meta"), opt("Arguments")],
    DirectiveDef: [
      word("directive"),
      p("@", "meta"),
      name("meta"),
      opt("ArgumentsDef"),
      word("on"),
      list("DirectiveLocation", p("|"))
    ],
    InterfaceDef: [
      word("interface"),
      name("atom"),
      opt("Implements"),
      list("Directive"),
      p("{"),
      list("FieldDef"),
      p("}")
    ],
    Implements: [word("implements"), list("NamedType", p("&"))],
    DirectiveLocation: [name("string-2")],
    SchemaDef: [
      word("schema"),
      list("Directive"),
      p("{"),
      list("OperationTypeDef"),
      p("}")
    ],
    OperationTypeDef: [name("keyword"), p(":"), name("atom")],
    ScalarDef: [word("scalar"), name("atom"), list("Directive")],
    ObjectTypeDef: [
      word("type"),
      name("atom"),
      opt("Implements"),
      list("Directive"),
      p("{"),
      list("FieldDef"),
      p("}")
    ],
    FieldDef: [
      name("property"),
      opt("ArgumentsDef"),
      p(":"),
      "Type",
      list("Directive")
    ],
    ArgumentsDef: [p("("), list("InputValueDef"), p(")")],
    InputValueDef: [
      name("attribute"),
      p(":"),
      "Type",
      opt("DefaultValue"),
      list("Directive")
    ],
    UnionDef: [
      word("union"),
      name("atom"),
      list("Directive"),
      p("="),
      list("UnionMember", p("|"))
    ],
    UnionMember: ["NamedType"],
    EnumDef: [
      word("enum"),
      name("atom"),
      list("Directive"),
      p("{"),
      list("EnumValueDef"),
      p("}")
    ],
    EnumValueDef: [name("string-2"), list("Directive")],
    InputDef: [
      word("input"),
      name("atom"),
      list("Directive"),
      p("{"),
      list("InputValueDef"),
      p("}")
    ],
    ExtendDef: [word("extend"), "ExtensionDefinition"],
    ExtensionDefinition(token) {
      switch (token.value) {
        case "schema":
          return Kind.SCHEMA_EXTENSION;
        case "scalar":
          return Kind.SCALAR_TYPE_EXTENSION;
        case "type":
          return Kind.OBJECT_TYPE_EXTENSION;
        case "interface":
          return Kind.INTERFACE_TYPE_EXTENSION;
        case "union":
          return Kind.UNION_TYPE_EXTENSION;
        case "enum":
          return Kind.ENUM_TYPE_EXTENSION;
        case "input":
          return Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
    },
    [Kind.SCHEMA_EXTENSION]: ["SchemaDef"],
    [Kind.SCALAR_TYPE_EXTENSION]: ["ScalarDef"],
    [Kind.OBJECT_TYPE_EXTENSION]: ["ObjectTypeDef"],
    [Kind.INTERFACE_TYPE_EXTENSION]: ["InterfaceDef"],
    [Kind.UNION_TYPE_EXTENSION]: ["UnionDef"],
    [Kind.ENUM_TYPE_EXTENSION]: ["EnumDef"],
    [Kind.INPUT_OBJECT_TYPE_EXTENSION]: ["InputDef"]
  };
  function word(value) {
    return {
      style: "keyword",
      match: (token) => token.kind === "Name" && token.value === value
    };
  }
  function name(style) {
    return {
      style,
      match: (token) => token.kind === "Name",
      update(state, token) {
        state.name = token.value;
      }
    };
  }
  function type(style) {
    return {
      style,
      match: (token) => token.kind === "Name",
      update(state, token) {
        var _a3;
        if ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.prevState) {
          state.name = token.value;
          state.prevState.prevState.type = token.value;
        }
      }
    };
  }

  // node_modules/graphql-language-service/esm/parser/onlineParser.js
  function onlineParser(options = {
    eatWhitespace: (stream) => stream.eatWhile(isIgnored),
    lexRules: LexRules,
    parseRules: ParseRules,
    editorConfig: {}
  }) {
    return {
      startState() {
        const initialState = {
          level: 0,
          step: 0,
          name: null,
          kind: null,
          type: null,
          rule: null,
          needsSeparator: false,
          prevState: null
        };
        pushRule(options.parseRules, initialState, Kind.DOCUMENT);
        return initialState;
      },
      token(stream, state) {
        return getToken(stream, state, options);
      }
    };
  }
  function getToken(stream, state, options) {
    var _a3;
    if (state.inBlockstring) {
      if (stream.match(/.*"""/)) {
        state.inBlockstring = false;
        return "string";
      }
      stream.skipToEnd();
      return "string";
    }
    const { lexRules, parseRules, eatWhitespace, editorConfig } = options;
    if (state.rule && state.rule.length === 0) {
      popRule(state);
    } else if (state.needsAdvance) {
      state.needsAdvance = false;
      advanceRule(state, true);
    }
    if (stream.sol()) {
      const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;
      state.indentLevel = Math.floor(stream.indentation() / tabSize);
    }
    if (eatWhitespace(stream)) {
      return "ws";
    }
    const token = lex(lexRules, stream);
    if (!token) {
      const matchedSomething = stream.match(/\S+/);
      if (!matchedSomething) {
        stream.match(/\s/);
      }
      pushRule(SpecialParseRules, state, "Invalid");
      return "invalidchar";
    }
    if (token.kind === "Comment") {
      pushRule(SpecialParseRules, state, "Comment");
      return "comment";
    }
    const backupState = assign({}, state);
    if (token.kind === "Punctuation") {
      if (/^[{([]/.test(token.value)) {
        if (state.indentLevel !== void 0) {
          state.levels = (state.levels || []).concat(state.indentLevel + 1);
        }
      } else if (/^[})\]]/.test(token.value)) {
        const levels = state.levels = (state.levels || []).slice(0, -1);
        if (state.indentLevel && levels.length > 0 && levels.at(-1) < state.indentLevel) {
          state.indentLevel = levels.at(-1);
        }
      }
    }
    while (state.rule) {
      let expected = typeof state.rule === "function" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];
      if (state.needsSeparator) {
        expected = expected === null || expected === void 0 ? void 0 : expected.separator;
      }
      if (expected) {
        if (expected.ofRule) {
          expected = expected.ofRule;
        }
        if (typeof expected === "string") {
          pushRule(parseRules, state, expected);
          continue;
        }
        if ((_a3 = expected.match) === null || _a3 === void 0 ? void 0 : _a3.call(expected, token)) {
          if (expected.update) {
            expected.update(state, token);
          }
          if (token.kind === "Punctuation") {
            advanceRule(state, true);
          } else {
            state.needsAdvance = true;
          }
          return expected.style;
        }
      }
      unsuccessful(state);
    }
    assign(state, backupState);
    pushRule(SpecialParseRules, state, "Invalid");
    return "invalidchar";
  }
  function assign(to2, from) {
    const keys = Object.keys(from);
    for (let i = 0; i < keys.length; i++) {
      to2[keys[i]] = from[keys[i]];
    }
    return to2;
  }
  var SpecialParseRules = {
    Invalid: [],
    Comment: []
  };
  function pushRule(rules, state, ruleKind) {
    if (!rules[ruleKind]) {
      throw new TypeError("Unknown rule: " + ruleKind);
    }
    state.prevState = Object.assign({}, state);
    state.kind = ruleKind;
    state.name = null;
    state.type = null;
    state.rule = rules[ruleKind];
    state.step = 0;
    state.needsSeparator = false;
  }
  function popRule(state) {
    if (!state.prevState) {
      return;
    }
    state.kind = state.prevState.kind;
    state.name = state.prevState.name;
    state.type = state.prevState.type;
    state.rule = state.prevState.rule;
    state.step = state.prevState.step;
    state.needsSeparator = state.prevState.needsSeparator;
    state.prevState = state.prevState.prevState;
  }
  function advanceRule(state, successful) {
    var _a3;
    if (isList(state) && state.rule) {
      const step = state.rule[state.step];
      if (step.separator) {
        const { separator } = step;
        state.needsSeparator = !state.needsSeparator;
        if (!state.needsSeparator && separator.ofRule) {
          return;
        }
      }
      if (successful) {
        return;
      }
    }
    state.needsSeparator = false;
    state.step++;
    while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {
      popRule(state);
      if (state.rule) {
        if (isList(state)) {
          if ((_a3 = state.rule) === null || _a3 === void 0 ? void 0 : _a3[state.step].separator) {
            state.needsSeparator = !state.needsSeparator;
          }
        } else {
          state.needsSeparator = false;
          state.step++;
        }
      }
    }
  }
  function isList(state) {
    const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== "string" && state.rule[state.step];
    return step && step.isList;
  }
  function unsuccessful(state) {
    while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {
      popRule(state);
    }
    if (state.rule) {
      advanceRule(state, false);
    }
  }
  function lex(lexRules, stream) {
    const kinds = Object.keys(lexRules);
    for (let i = 0; i < kinds.length; i++) {
      const match = stream.match(lexRules[kinds[i]]);
      if (match && match instanceof Array) {
        return { kind: kinds[i], value: match[0] };
      }
    }
  }

  // node_modules/graphql-language-service/esm/parser/api.js
  function runOnlineParser(queryText, callback) {
    const lines = queryText.split("\n");
    const parser = onlineParser();
    let state = parser.startState();
    let style = "";
    let stream = new CharacterStream("");
    for (let i = 0; i < lines.length; i++) {
      stream = new CharacterStream(lines[i]);
      while (!stream.eol()) {
        style = parser.token(stream, state);
        const code = callback(stream, state, style, i);
        if (code === "BREAK") {
          break;
        }
      }
      callback(stream, state, style, i);
      if (!state.kind) {
        state = parser.startState();
      }
    }
    return {
      start: stream.getStartOfToken(),
      end: stream.getCurrentPosition(),
      string: stream.current(),
      state,
      style
    };
  }
  var GraphQLDocumentMode;
  (function(GraphQLDocumentMode2) {
    GraphQLDocumentMode2["TYPE_SYSTEM"] = "TYPE_SYSTEM";
    GraphQLDocumentMode2["EXECUTABLE"] = "EXECUTABLE";
    GraphQLDocumentMode2["UNKNOWN"] = "UNKNOWN";
  })(GraphQLDocumentMode || (GraphQLDocumentMode = {}));
  var TYPE_SYSTEM_KINDS = [
    Kind.SCHEMA_DEFINITION,
    Kind.OPERATION_TYPE_DEFINITION,
    Kind.SCALAR_TYPE_DEFINITION,
    Kind.OBJECT_TYPE_DEFINITION,
    Kind.INTERFACE_TYPE_DEFINITION,
    Kind.UNION_TYPE_DEFINITION,
    Kind.ENUM_TYPE_DEFINITION,
    Kind.INPUT_OBJECT_TYPE_DEFINITION,
    Kind.DIRECTIVE_DEFINITION,
    Kind.SCHEMA_EXTENSION,
    Kind.SCALAR_TYPE_EXTENSION,
    Kind.OBJECT_TYPE_EXTENSION,
    Kind.INTERFACE_TYPE_EXTENSION,
    Kind.UNION_TYPE_EXTENSION,
    Kind.ENUM_TYPE_EXTENSION,
    Kind.INPUT_OBJECT_TYPE_EXTENSION
  ];
  var getParsedMode = (sdl) => {
    let mode = GraphQLDocumentMode.UNKNOWN;
    if (sdl) {
      try {
        visit(parse(sdl), {
          enter(node) {
            if (node.kind === "Document") {
              mode = GraphQLDocumentMode.EXECUTABLE;
              return;
            }
            if (TYPE_SYSTEM_KINDS.includes(node.kind)) {
              mode = GraphQLDocumentMode.TYPE_SYSTEM;
              return BREAK;
            }
            return false;
          }
        });
      } catch (_a3) {
        return mode;
      }
    }
    return mode;
  };
  function getDocumentMode(documentText, uri) {
    if (uri === null || uri === void 0 ? void 0 : uri.endsWith(".graphqls")) {
      return GraphQLDocumentMode.TYPE_SYSTEM;
    }
    return getParsedMode(documentText);
  }
  function getTokenAtPosition(queryText, cursor, offset = 0) {
    let styleAtCursor = null;
    let stateAtCursor = null;
    let stringAtCursor = null;
    const token = runOnlineParser(queryText, (stream, state, style, index) => {
      if (index !== cursor.line || stream.getCurrentPosition() + offset < cursor.character + 1) {
        return;
      }
      styleAtCursor = style;
      stateAtCursor = Object.assign({}, state);
      stringAtCursor = stream.current();
      return "BREAK";
    });
    return {
      start: token.start,
      end: token.end,
      string: stringAtCursor || token.string,
      state: stateAtCursor || token.state,
      style: styleAtCursor || token.style
    };
  }
  function getContextAtPosition(queryText, cursor, schema, contextToken, options) {
    const token = contextToken || getTokenAtPosition(queryText, cursor, 1);
    if (!token) {
      return null;
    }
    const state = token.state.kind === "Invalid" ? token.state.prevState : token.state;
    if (!state) {
      return null;
    }
    const typeInfo = getTypeInfo(schema, token.state);
    const mode = (options === null || options === void 0 ? void 0 : options.mode) || getDocumentMode(queryText, options === null || options === void 0 ? void 0 : options.uri);
    return {
      token,
      state,
      typeInfo,
      mode
    };
  }

  // node_modules/graphql-language-service/esm/parser/getTypeInfo.js
  function getFieldDef2(schema, type2, fieldName) {
    if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type2) {
      return SchemaMetaFieldDef;
    }
    if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type2) {
      return TypeMetaFieldDef;
    }
    if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type2)) {
      return TypeNameMetaFieldDef;
    }
    if ("getFields" in type2) {
      return type2.getFields()[fieldName];
    }
    return null;
  }
  function forEachState(stack, fn) {
    const reverseStateStack = [];
    let state = stack;
    while (state === null || state === void 0 ? void 0 : state.kind) {
      reverseStateStack.push(state);
      state = state.prevState;
    }
    for (let i = reverseStateStack.length - 1; i >= 0; i--) {
      fn(reverseStateStack[i]);
    }
  }
  function getDefinitionState(tokenState) {
    let definitionState;
    forEachState(tokenState, (state) => {
      switch (state.kind) {
        case "Query":
        case "ShortQuery":
        case "Mutation":
        case "Subscription":
        case "FragmentDefinition":
          definitionState = state;
          break;
      }
    });
    return definitionState;
  }
  function getTypeInfo(schema, tokenState) {
    let argDef;
    let argDefs;
    let directiveDef;
    let enumValue;
    let fieldDef;
    let inputType;
    let objectTypeDef;
    let objectFieldDefs;
    let parentType;
    let type2;
    let interfaceDef;
    forEachState(tokenState, (state) => {
      var _a3;
      switch (state.kind) {
        case RuleKinds.QUERY:
        case "ShortQuery":
          type2 = schema.getQueryType();
          break;
        case RuleKinds.MUTATION:
          type2 = schema.getMutationType();
          break;
        case RuleKinds.SUBSCRIPTION:
          type2 = schema.getSubscriptionType();
          break;
        case RuleKinds.INLINE_FRAGMENT:
        case RuleKinds.FRAGMENT_DEFINITION:
          if (state.type) {
            type2 = schema.getType(state.type);
          }
          break;
        case RuleKinds.FIELD:
        case RuleKinds.ALIASED_FIELD: {
          if (!type2 || !state.name) {
            fieldDef = null;
          } else {
            fieldDef = parentType ? getFieldDef2(schema, parentType, state.name) : null;
            type2 = fieldDef ? fieldDef.type : null;
          }
          break;
        }
        case RuleKinds.SELECTION_SET:
          parentType = getNamedType(type2);
          break;
        case RuleKinds.DIRECTIVE:
          directiveDef = state.name ? schema.getDirective(state.name) : null;
          break;
        case RuleKinds.INTERFACE_DEF:
          if (state.name) {
            objectTypeDef = null;
            interfaceDef = new GraphQLInterfaceType({
              name: state.name,
              interfaces: [],
              fields: {}
            });
          }
          break;
        case RuleKinds.OBJECT_TYPE_DEF:
          if (state.name) {
            interfaceDef = null;
            objectTypeDef = new GraphQLObjectType({
              name: state.name,
              interfaces: [],
              fields: {}
            });
          }
          break;
        case RuleKinds.ARGUMENTS: {
          if (state.prevState) {
            switch (state.prevState.kind) {
              case RuleKinds.FIELD:
                argDefs = fieldDef && fieldDef.args;
                break;
              case RuleKinds.DIRECTIVE:
                argDefs = directiveDef && directiveDef.args;
                break;
              case RuleKinds.ALIASED_FIELD: {
                const name2 = (_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.name;
                if (!name2) {
                  argDefs = null;
                  break;
                }
                const field = parentType ? getFieldDef2(schema, parentType, name2) : null;
                if (!field) {
                  argDefs = null;
                  break;
                }
                argDefs = field.args;
                break;
              }
              default:
                argDefs = null;
                break;
            }
          } else {
            argDefs = null;
          }
          break;
        }
        case RuleKinds.ARGUMENT:
          if (argDefs) {
            for (let i = 0; i < argDefs.length; i++) {
              if (argDefs[i].name === state.name) {
                argDef = argDefs[i];
                break;
              }
            }
          }
          inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;
          break;
        case RuleKinds.VARIABLE_DEFINITION:
        case RuleKinds.VARIABLE:
          type2 = inputType;
          break;
        case RuleKinds.ENUM_VALUE:
          const enumType = getNamedType(inputType);
          enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;
          break;
        case RuleKinds.LIST_VALUE:
          const nullableType = getNullableType(inputType);
          inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;
          break;
        case RuleKinds.OBJECT_VALUE:
          const objectType = getNamedType(inputType);
          objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;
          break;
        case RuleKinds.OBJECT_FIELD:
          const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;
          inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;
          fieldDef = objectField;
          type2 = fieldDef ? fieldDef.type : null;
          break;
        case RuleKinds.NAMED_TYPE:
          if (state.name) {
            type2 = schema.getType(state.name);
          }
          break;
      }
    });
    return {
      argDef,
      argDefs,
      directiveDef,
      enumValue,
      fieldDef,
      inputType,
      objectFieldDefs,
      parentType,
      type: type2,
      interfaceDef,
      objectTypeDef
    };
  }

  // node_modules/graphql-language-service/esm/parser/types.js
  var AdditionalRuleKinds = {
    ALIASED_FIELD: "AliasedField",
    ARGUMENTS: "Arguments",
    SHORT_QUERY: "ShortQuery",
    QUERY: "Query",
    MUTATION: "Mutation",
    SUBSCRIPTION: "Subscription",
    TYPE_CONDITION: "TypeCondition",
    INVALID: "Invalid",
    COMMENT: "Comment",
    SCHEMA_DEF: "SchemaDef",
    SCALAR_DEF: "ScalarDef",
    OBJECT_TYPE_DEF: "ObjectTypeDef",
    OBJECT_VALUE: "ObjectValue",
    LIST_VALUE: "ListValue",
    INTERFACE_DEF: "InterfaceDef",
    UNION_DEF: "UnionDef",
    ENUM_DEF: "EnumDef",
    ENUM_VALUE: "EnumValue",
    FIELD_DEF: "FieldDef",
    INPUT_DEF: "InputDef",
    INPUT_VALUE_DEF: "InputValueDef",
    ARGUMENTS_DEF: "ArgumentsDef",
    EXTEND_DEF: "ExtendDef",
    EXTENSION_DEFINITION: "ExtensionDefinition",
    DIRECTIVE_DEF: "DirectiveDef",
    IMPLEMENTS: "Implements",
    VARIABLE_DEFINITIONS: "VariableDefinitions",
    TYPE: "Type",
    VARIABLE: "Variable"
  };
  var RuleKinds = Object.assign(Object.assign({}, Kind), AdditionalRuleKinds);

  // node_modules/graphql-language-service/esm/types.js
  var CompletionItemKind3;
  (function(CompletionItemKind4) {
    CompletionItemKind4.Text = 1;
    CompletionItemKind4.Method = 2;
    CompletionItemKind4.Function = 3;
    CompletionItemKind4.Constructor = 4;
    CompletionItemKind4.Field = 5;
    CompletionItemKind4.Variable = 6;
    CompletionItemKind4.Class = 7;
    CompletionItemKind4.Interface = 8;
    CompletionItemKind4.Module = 9;
    CompletionItemKind4.Property = 10;
    CompletionItemKind4.Unit = 11;
    CompletionItemKind4.Value = 12;
    CompletionItemKind4.Enum = 13;
    CompletionItemKind4.Keyword = 14;
    CompletionItemKind4.Snippet = 15;
    CompletionItemKind4.Color = 16;
    CompletionItemKind4.File = 17;
    CompletionItemKind4.Reference = 18;
    CompletionItemKind4.Folder = 19;
    CompletionItemKind4.EnumMember = 20;
    CompletionItemKind4.Constant = 21;
    CompletionItemKind4.Struct = 22;
    CompletionItemKind4.Event = 23;
    CompletionItemKind4.Operator = 24;
    CompletionItemKind4.TypeParameter = 25;
  })(CompletionItemKind3 || (CompletionItemKind3 = {}));

  // node_modules/graphql-language-service/esm/interface/getAutocompleteSuggestions.js
  var SuggestionCommand = {
    command: "editor.action.triggerSuggest",
    title: "Suggestions"
  };
  var collectFragmentDefs = (op) => {
    const externalFragments = [];
    if (op) {
      try {
        visit(parse(op), {
          FragmentDefinition(def) {
            externalFragments.push(def);
          }
        });
      } catch (_a3) {
        return [];
      }
    }
    return externalFragments;
  };
  function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {
    var _a3;
    const opts = Object.assign(Object.assign({}, options), { schema });
    const context = getContextAtPosition(queryText, cursor, schema, contextToken, options);
    if (!context) {
      return [];
    }
    const { state, typeInfo, mode, token } = context;
    const { kind, step, prevState } = state;
    if (kind === RuleKinds.DOCUMENT) {
      if (mode === GraphQLDocumentMode.TYPE_SYSTEM) {
        return getSuggestionsForTypeSystemDefinitions(token);
      }
      if (mode === GraphQLDocumentMode.EXECUTABLE) {
        return getSuggestionsForExecutableDefinitions(token);
      }
      return getSuggestionsForUnknownDocumentMode(token);
    }
    if (kind === RuleKinds.EXTEND_DEF) {
      return getSuggestionsForExtensionDefinitions(token);
    }
    if (((_a3 = prevState === null || prevState === void 0 ? void 0 : prevState.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === RuleKinds.EXTENSION_DEFINITION && state.name) {
      return hintList(token, []);
    }
    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.SCALAR_TYPE_EXTENSION) {
      return hintList(token, Object.values(schema.getTypeMap()).filter(isScalarType).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function
      })));
    }
    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.OBJECT_TYPE_EXTENSION) {
      return hintList(token, Object.values(schema.getTypeMap()).filter((type2) => isObjectType(type2) && !type2.name.startsWith("__")).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function
      })));
    }
    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.INTERFACE_TYPE_EXTENSION) {
      return hintList(token, Object.values(schema.getTypeMap()).filter(isInterfaceType).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function
      })));
    }
    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.UNION_TYPE_EXTENSION) {
      return hintList(token, Object.values(schema.getTypeMap()).filter(isUnionType).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function
      })));
    }
    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.ENUM_TYPE_EXTENSION) {
      return hintList(token, Object.values(schema.getTypeMap()).filter((type2) => isEnumType(type2) && !type2.name.startsWith("__")).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function
      })));
    }
    if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind.INPUT_OBJECT_TYPE_EXTENSION) {
      return hintList(token, Object.values(schema.getTypeMap()).filter(isInputObjectType).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function
      })));
    }
    if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && (prevState === null || prevState === void 0 ? void 0 : prevState.kind) === RuleKinds.IMPLEMENTS) {
      return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);
    }
    if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {
      return getSuggestionsForFieldNames(token, typeInfo, opts);
    }
    if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {
      const { argDefs } = typeInfo;
      if (argDefs) {
        return hintList(token, argDefs.map((argDef) => {
          var _a4;
          return {
            label: argDef.name,
            insertText: getInputInsertText(argDef.name + ": ", argDef.type),
            insertTextMode: InsertTextMode.adjustIndentation,
            insertTextFormat: InsertTextFormat.Snippet,
            command: SuggestionCommand,
            labelDetails: {
              detail: " " + String(argDef.type)
            },
            documentation: (_a4 = argDef.description) !== null && _a4 !== void 0 ? _a4 : void 0,
            kind: CompletionItemKind3.Variable,
            type: argDef.type
          };
        }));
      }
    }
    if ((kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) && typeInfo.objectFieldDefs) {
      const objectFields = objectValues(typeInfo.objectFieldDefs);
      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind3.Value : CompletionItemKind3.Field;
      return hintList(token, objectFields.map((field) => {
        var _a4;
        return {
          label: field.name,
          detail: String(field.type),
          documentation: (_a4 = field === null || field === void 0 ? void 0 : field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
          kind: completionKind,
          type: field.type,
          insertText: getInputInsertText(field.name + ": ", field.type),
          insertTextMode: InsertTextMode.adjustIndentation,
          insertTextFormat: InsertTextFormat.Snippet,
          command: SuggestionCommand
        };
      }));
    }
    if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {
      return getSuggestionsForInputValues(token, typeInfo, queryText, schema);
    }
    if (kind === RuleKinds.VARIABLE && step === 1) {
      const namedInputType = getNamedType(typeInfo.inputType);
      const variableDefinitions = getVariableCompletions(queryText, schema, token);
      return hintList(token, variableDefinitions.filter((v2) => v2.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));
    }
    if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && prevState != null && prevState.kind === RuleKinds.TYPE_CONDITION) {
      return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);
    }
    if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {
      return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));
    }
    const unwrappedState = unwrapType(state);
    if (unwrappedState.kind === RuleKinds.FIELD_DEF) {
      return hintList(token, Object.values(schema.getTypeMap()).filter((type2) => isOutputType(type2) && !type2.name.startsWith("__")).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function,
        insertText: (options === null || options === void 0 ? void 0 : options.fillLeafsOnComplete) ? type2.name + "\n" : type2.name,
        insertTextMode: InsertTextMode.adjustIndentation
      })));
    }
    if (unwrappedState.kind === RuleKinds.INPUT_VALUE_DEF && step === 2) {
      return hintList(token, Object.values(schema.getTypeMap()).filter((type2) => isInputType(type2) && !type2.name.startsWith("__")).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind3.Function,
        insertText: (options === null || options === void 0 ? void 0 : options.fillLeafsOnComplete) ? type2.name + "\n$1" : type2.name,
        insertTextMode: InsertTextMode.adjustIndentation,
        insertTextFormat: InsertTextFormat.Snippet
      })));
    }
    if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && prevState && (prevState.kind === RuleKinds.VARIABLE_DEFINITION || prevState.kind === RuleKinds.LIST_TYPE || prevState.kind === RuleKinds.NON_NULL_TYPE)) {
      return getSuggestionsForVariableDefinition(token, schema, kind);
    }
    if (kind === RuleKinds.DIRECTIVE) {
      return getSuggestionsForDirective(token, state, schema, kind);
    }
    if (kind === RuleKinds.DIRECTIVE_DEF) {
      return getSuggestionsForDirectiveArguments(token, state, schema, kind);
    }
    return [];
  }
  var typeSystemCompletionItems = [
    { label: "type", kind: CompletionItemKind3.Function },
    { label: "interface", kind: CompletionItemKind3.Function },
    { label: "union", kind: CompletionItemKind3.Function },
    { label: "input", kind: CompletionItemKind3.Function },
    { label: "scalar", kind: CompletionItemKind3.Function },
    { label: "schema", kind: CompletionItemKind3.Function }
  ];
  var executableCompletionItems = [
    { label: "query", kind: CompletionItemKind3.Function },
    { label: "mutation", kind: CompletionItemKind3.Function },
    { label: "subscription", kind: CompletionItemKind3.Function },
    { label: "fragment", kind: CompletionItemKind3.Function },
    { label: "{", kind: CompletionItemKind3.Constructor }
  ];
  function getSuggestionsForTypeSystemDefinitions(token) {
    return hintList(token, [
      { label: "extend", kind: CompletionItemKind3.Function },
      ...typeSystemCompletionItems
    ]);
  }
  function getSuggestionsForExecutableDefinitions(token) {
    return hintList(token, executableCompletionItems);
  }
  function getSuggestionsForUnknownDocumentMode(token) {
    return hintList(token, [
      { label: "extend", kind: CompletionItemKind3.Function },
      ...executableCompletionItems,
      ...typeSystemCompletionItems
    ]);
  }
  function getSuggestionsForExtensionDefinitions(token) {
    return hintList(token, typeSystemCompletionItems);
  }
  function getSuggestionsForFieldNames(token, typeInfo, options) {
    var _a3;
    if (typeInfo.parentType) {
      const { parentType } = typeInfo;
      let fields = [];
      if ("getFields" in parentType) {
        fields = objectValues(parentType.getFields());
      }
      if (isCompositeType(parentType)) {
        fields.push(TypeNameMetaFieldDef);
      }
      if (parentType === ((_a3 = options === null || options === void 0 ? void 0 : options.schema) === null || _a3 === void 0 ? void 0 : _a3.getQueryType())) {
        fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);
      }
      return hintList(token, fields.map((field, index) => {
        var _a4;
        const suggestion = {
          sortText: String(index) + field.name,
          label: field.name,
          detail: String(field.type),
          documentation: (_a4 = field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
          deprecated: Boolean(field.deprecationReason),
          isDeprecated: Boolean(field.deprecationReason),
          deprecationReason: field.deprecationReason,
          kind: CompletionItemKind3.Field,
          labelDetails: {
            detail: " " + field.type.toString()
          },
          type: field.type
        };
        if (options === null || options === void 0 ? void 0 : options.fillLeafsOnComplete) {
          suggestion.insertText = getFieldInsertText(field);
          if (!suggestion.insertText) {
            suggestion.insertText = getInsertText(field.name, field.type, field.name + (token.state.needsAdvance ? "" : "\n"));
          }
          if (suggestion.insertText) {
            suggestion.insertTextFormat = InsertTextFormat.Snippet;
            suggestion.insertTextMode = InsertTextMode.adjustIndentation;
            suggestion.command = SuggestionCommand;
          }
        }
        return suggestion;
      }));
    }
    return [];
  }
  function getSuggestionsForInputValues(token, typeInfo, queryText, schema) {
    const namedInputType = getNamedType(typeInfo.inputType);
    const queryVariables = getVariableCompletions(queryText, schema, token).filter((v2) => v2.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name));
    if (namedInputType instanceof GraphQLEnumType) {
      const values = namedInputType.getValues();
      return hintList(token, values.map((value) => {
        var _a3;
        return {
          label: value.name,
          detail: String(namedInputType),
          documentation: (_a3 = value.description) !== null && _a3 !== void 0 ? _a3 : void 0,
          deprecated: Boolean(value.deprecationReason),
          isDeprecated: Boolean(value.deprecationReason),
          deprecationReason: value.deprecationReason,
          kind: CompletionItemKind3.EnumMember,
          type: namedInputType
        };
      }).concat(queryVariables));
    }
    if (namedInputType === GraphQLBoolean) {
      return hintList(token, queryVariables.concat([
        {
          label: "true",
          detail: String(GraphQLBoolean),
          documentation: "Not false.",
          kind: CompletionItemKind3.Variable,
          type: GraphQLBoolean
        },
        {
          label: "false",
          detail: String(GraphQLBoolean),
          documentation: "Not true.",
          kind: CompletionItemKind3.Variable,
          type: GraphQLBoolean
        }
      ]));
    }
    return queryVariables;
  }
  function getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {
    if (tokenState.needsSeparator) {
      return [];
    }
    const typeMap = schema.getTypeMap();
    const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);
    const schemaInterfaceNames = schemaInterfaces.map(({ name: name2 }) => name2);
    const inlineInterfaces = /* @__PURE__ */ new Set();
    runOnlineParser(documentText, (_2, state) => {
      var _a3, _b2, _c, _d, _e2;
      if (state.name) {
        if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {
          inlineInterfaces.add(state.name);
        }
        if (state.kind === RuleKinds.NAMED_TYPE && ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === RuleKinds.IMPLEMENTS) {
          if (typeInfo.interfaceDef) {
            const existingType = (_b2 = typeInfo.interfaceDef) === null || _b2 === void 0 ? void 0 : _b2.getInterfaces().find(({ name: name2 }) => name2 === state.name);
            if (existingType) {
              return;
            }
            const type2 = schema.getType(state.name);
            const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();
            typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [
              ...interfaceConfig.interfaces,
              type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })
            ] }));
          } else if (typeInfo.objectTypeDef) {
            const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name: name2 }) => name2 === state.name);
            if (existingType) {
              return;
            }
            const type2 = schema.getType(state.name);
            const objectTypeConfig = (_e2 = typeInfo.objectTypeDef) === null || _e2 === void 0 ? void 0 : _e2.toConfig();
            typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [
              ...objectTypeConfig.interfaces,
              type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })
            ] }));
          }
        }
      }
    });
    const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;
    const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];
    const siblingInterfaceNames = siblingInterfaces.map(({ name: name2 }) => name2);
    const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name2) => ({ name: name2 }))).filter(({ name: name2 }) => name2 !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name2));
    return hintList(token, possibleInterfaces.map((type2) => {
      const result = {
        label: type2.name,
        kind: CompletionItemKind3.Interface,
        type: type2
      };
      if (type2 === null || type2 === void 0 ? void 0 : type2.description) {
        result.documentation = type2.description;
      }
      return result;
    }));
  }
  function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {
    let possibleTypes;
    if (typeInfo.parentType) {
      if (isAbstractType(typeInfo.parentType)) {
        const abstractType = assertAbstractType(typeInfo.parentType);
        const possibleObjTypes = schema.getPossibleTypes(abstractType);
        const possibleIfaceMap = /* @__PURE__ */ Object.create(null);
        for (const type2 of possibleObjTypes) {
          for (const iface of type2.getInterfaces()) {
            possibleIfaceMap[iface.name] = iface;
          }
        }
        possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));
      } else {
        possibleTypes = [typeInfo.parentType];
      }
    } else {
      const typeMap = schema.getTypeMap();
      possibleTypes = objectValues(typeMap).filter((type2) => isCompositeType(type2) && !type2.name.startsWith("__"));
    }
    return hintList(token, possibleTypes.map((type2) => {
      const namedType = getNamedType(type2);
      return {
        label: String(type2),
        documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || "",
        kind: CompletionItemKind3.Field
      };
    }));
  }
  function getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {
    if (!queryText) {
      return [];
    }
    const typeMap = schema.getTypeMap();
    const defState = getDefinitionState(token.state);
    const fragments = getFragmentDefinitions(queryText);
    if (fragmentDefs && fragmentDefs.length > 0) {
      fragments.push(...fragmentDefs);
    }
    const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));
    return hintList(token, relevantFrags.map((frag) => ({
      label: frag.name.value,
      detail: String(typeMap[frag.typeCondition.name.value]),
      documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,
      labelDetails: {
        detail: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`
      },
      kind: CompletionItemKind3.Field,
      type: typeMap[frag.typeCondition.name.value]
    })));
  }
  var getParentDefinition = (state, kind) => {
    var _a3, _b2, _c, _d, _e2, _f, _g, _h, _j, _k;
    if (((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === kind) {
      return state.prevState;
    }
    if (((_c = (_b2 = state.prevState) === null || _b2 === void 0 ? void 0 : _b2.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {
      return state.prevState.prevState;
    }
    if (((_f = (_e2 = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e2 === void 0 ? void 0 : _e2.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {
      return state.prevState.prevState.prevState;
    }
    if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {
      return state.prevState.prevState.prevState.prevState;
    }
  };
  function getVariableCompletions(queryText, schema, token) {
    let variableName = null;
    let variableType;
    const definitions = /* @__PURE__ */ Object.create({});
    runOnlineParser(queryText, (_2, state) => {
      var _a3;
      if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {
        variableName = state.name;
      }
      if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {
        const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);
        if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {
          variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);
        }
      }
      if (variableName && variableType && !definitions[variableName]) {
        const replaceString = token.string === "$" || ((_a3 = token === null || token === void 0 ? void 0 : token.state) === null || _a3 === void 0 ? void 0 : _a3.kind) === "Variable" ? variableName : "$" + variableName;
        definitions[variableName] = {
          detail: variableType.toString(),
          insertText: replaceString,
          label: "$" + variableName,
          rawInsert: replaceString,
          type: variableType,
          kind: CompletionItemKind3.Variable
        };
        variableName = null;
        variableType = null;
      }
    });
    return objectValues(definitions);
  }
  function getFragmentDefinitions(queryText) {
    const fragmentDefs = [];
    runOnlineParser(queryText, (_2, state) => {
      if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {
        fragmentDefs.push({
          kind: RuleKinds.FRAGMENT_DEFINITION,
          name: {
            kind: Kind.NAME,
            value: state.name
          },
          selectionSet: {
            kind: RuleKinds.SELECTION_SET,
            selections: []
          },
          typeCondition: {
            kind: RuleKinds.NAMED_TYPE,
            name: {
              kind: Kind.NAME,
              value: state.type
            }
          }
        });
      }
    });
    return fragmentDefs;
  }
  function getSuggestionsForVariableDefinition(token, schema, _kind) {
    const inputTypeMap = schema.getTypeMap();
    const inputTypes = objectValues(inputTypeMap).filter(isInputType);
    return hintList(token, inputTypes.map((type2) => ({
      label: type2.name,
      documentation: (type2 === null || type2 === void 0 ? void 0 : type2.description) || "",
      kind: CompletionItemKind3.Variable
    })));
  }
  function getSuggestionsForDirective(token, state, schema, _kind) {
    var _a3;
    if ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) {
      const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));
      return hintList(token, directives.map((directive) => ({
        label: directive.name,
        documentation: (directive === null || directive === void 0 ? void 0 : directive.description) || "",
        kind: CompletionItemKind3.Function
      })));
    }
    return [];
  }
  function getSuggestionsForDirectiveArguments(token, state, schema, _kind) {
    const directive = schema.getDirectives().find((d) => d.name === state.name);
    return hintList(token, (directive === null || directive === void 0 ? void 0 : directive.args.map((arg) => ({
      label: arg.name,
      documentation: arg.description || "",
      kind: CompletionItemKind3.Field
    }))) || []);
  }
  function canUseDirective(state, directive) {
    if (!(state === null || state === void 0 ? void 0 : state.kind)) {
      return false;
    }
    const { kind, prevState } = state;
    const { locations } = directive;
    switch (kind) {
      case RuleKinds.QUERY:
        return locations.includes(DirectiveLocation.QUERY);
      case RuleKinds.MUTATION:
        return locations.includes(DirectiveLocation.MUTATION);
      case RuleKinds.SUBSCRIPTION:
        return locations.includes(DirectiveLocation.SUBSCRIPTION);
      case RuleKinds.FIELD:
      case RuleKinds.ALIASED_FIELD:
        return locations.includes(DirectiveLocation.FIELD);
      case RuleKinds.FRAGMENT_DEFINITION:
        return locations.includes(DirectiveLocation.FRAGMENT_DEFINITION);
      case RuleKinds.FRAGMENT_SPREAD:
        return locations.includes(DirectiveLocation.FRAGMENT_SPREAD);
      case RuleKinds.INLINE_FRAGMENT:
        return locations.includes(DirectiveLocation.INLINE_FRAGMENT);
      case RuleKinds.SCHEMA_DEF:
        return locations.includes(DirectiveLocation.SCHEMA);
      case RuleKinds.SCALAR_DEF:
        return locations.includes(DirectiveLocation.SCALAR);
      case RuleKinds.OBJECT_TYPE_DEF:
        return locations.includes(DirectiveLocation.OBJECT);
      case RuleKinds.FIELD_DEF:
        return locations.includes(DirectiveLocation.FIELD_DEFINITION);
      case RuleKinds.INTERFACE_DEF:
        return locations.includes(DirectiveLocation.INTERFACE);
      case RuleKinds.UNION_DEF:
        return locations.includes(DirectiveLocation.UNION);
      case RuleKinds.ENUM_DEF:
        return locations.includes(DirectiveLocation.ENUM);
      case RuleKinds.ENUM_VALUE:
        return locations.includes(DirectiveLocation.ENUM_VALUE);
      case RuleKinds.INPUT_DEF:
        return locations.includes(DirectiveLocation.INPUT_OBJECT);
      case RuleKinds.INPUT_VALUE_DEF:
        const prevStateKind = prevState === null || prevState === void 0 ? void 0 : prevState.kind;
        switch (prevStateKind) {
          case RuleKinds.ARGUMENTS_DEF:
            return locations.includes(DirectiveLocation.ARGUMENT_DEFINITION);
          case RuleKinds.INPUT_DEF:
            return locations.includes(DirectiveLocation.INPUT_FIELD_DEFINITION);
        }
    }
    return false;
  }
  function unwrapType(state) {
    if (state.prevState && state.kind && [
      RuleKinds.NAMED_TYPE,
      RuleKinds.LIST_TYPE,
      RuleKinds.TYPE,
      RuleKinds.NON_NULL_TYPE
    ].includes(state.kind)) {
      return unwrapType(state.prevState);
    }
    return state;
  }

  // node_modules/graphql-language-service/esm/utils/fragmentDependencies.js
  var import_nullthrows = __toESM(require_nullthrows());

  // node_modules/graphql-language-service/esm/utils/getVariablesJSONSchema.js
  function text(into, newText) {
    into.push(newText);
  }
  function renderType(into, t2) {
    if (isNonNullType(t2)) {
      renderType(into, t2.ofType);
      text(into, "!");
    } else if (isListType(t2)) {
      text(into, "[");
      renderType(into, t2.ofType);
      text(into, "]");
    } else {
      text(into, t2.name);
    }
  }
  function renderDefinitionDescription(t2, useMarkdown, description) {
    const into = [];
    const type2 = "type" in t2 ? t2.type : t2;
    if ("type" in t2 && t2.description) {
      text(into, t2.description);
      text(into, "\n\n");
    }
    text(into, renderTypeToString(type2, useMarkdown));
    if (description) {
      text(into, "\n");
      text(into, description);
    } else if (!isScalarType(type2) && "description" in type2 && type2.description) {
      text(into, "\n");
      text(into, type2.description);
    } else if ("ofType" in type2 && !isScalarType(type2.ofType) && "description" in type2.ofType && type2.ofType.description) {
      text(into, "\n");
      text(into, type2.ofType.description);
    }
    return into.join("");
  }
  function renderTypeToString(t2, useMarkdown) {
    const into = [];
    if (useMarkdown) {
      text(into, "```graphql\n");
    }
    renderType(into, t2);
    if (useMarkdown) {
      text(into, "\n```");
    }
    return into.join("");
  }
  var defaultScalarTypesMap = {
    Int: { type: "integer" },
    String: { type: "string" },
    Float: { type: "number" },
    ID: { type: "string" },
    Boolean: { type: "boolean" },
    DateTime: { type: "string" }
  };
  var Marker = class {
    constructor() {
      this.set = /* @__PURE__ */ new Set();
    }
    mark(name2) {
      if (this.set.has(name2)) {
        return false;
      }
      this.set.add(name2);
      return true;
    }
  };
  function getJSONSchemaFromGraphQLType(fieldOrType, options) {
    var _a3, _b2;
    let definition = /* @__PURE__ */ Object.create(null);
    const definitions = /* @__PURE__ */ Object.create(null);
    const isField = "type" in fieldOrType;
    const type2 = isField ? fieldOrType.type : fieldOrType;
    const baseType = isNonNullType(type2) ? type2.ofType : type2;
    const required = isNonNullType(type2);
    if (isScalarType(baseType)) {
      if ((_a3 = options === null || options === void 0 ? void 0 : options.scalarSchemas) === null || _a3 === void 0 ? void 0 : _a3[baseType.name]) {
        definition = JSON.parse(JSON.stringify(options.scalarSchemas[baseType.name]));
      } else {
        definition.type = ["string", "number", "boolean", "integer"];
      }
      if (!required) {
        if (Array.isArray(definition.type)) {
          definition.type.push("null");
        } else if (definition.type) {
          definition.type = [definition.type, "null"];
        } else if (definition.enum) {
          definition.enum.push(null);
        } else if (definition.oneOf) {
          definition.oneOf.push({ type: "null" });
        } else {
          definition = {
            oneOf: [definition, { type: "null" }]
          };
        }
      }
    } else if (isEnumType(baseType)) {
      definition.enum = baseType.getValues().map((val) => val.name);
      if (!required) {
        definition.enum.push(null);
      }
    } else if (isListType(baseType)) {
      if (required) {
        definition.type = "array";
      } else {
        definition.type = ["array", "null"];
      }
      const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(baseType.ofType, options);
      definition.items = def;
      if (defs) {
        for (const defName of Object.keys(defs)) {
          definitions[defName] = defs[defName];
        }
      }
    } else if (isInputObjectType(baseType)) {
      if (required) {
        definition.$ref = `#/definitions/${baseType.name}`;
      } else {
        definition.oneOf = [
          { $ref: `#/definitions/${baseType.name}` },
          { type: "null" }
        ];
      }
      if ((_b2 = options === null || options === void 0 ? void 0 : options.definitionMarker) === null || _b2 === void 0 ? void 0 : _b2.mark(baseType.name)) {
        const fields = baseType.getFields();
        const fieldDef = {
          type: "object",
          properties: {},
          required: []
        };
        fieldDef.description = renderDefinitionDescription(baseType);
        if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
          fieldDef.markdownDescription = renderDefinitionDescription(baseType, true);
        }
        for (const fieldName of Object.keys(fields)) {
          const field = fields[fieldName];
          const { required: fieldRequired, definition: fieldDefinition, definitions: typeDefinitions } = getJSONSchemaFromGraphQLType(field, options);
          fieldDef.properties[fieldName] = fieldDefinition;
          if (fieldRequired) {
            fieldDef.required.push(fieldName);
          }
          if (typeDefinitions) {
            for (const [defName, value] of Object.entries(typeDefinitions)) {
              definitions[defName] = value;
            }
          }
        }
        definitions[baseType.name] = fieldDef;
      }
    }
    if ("defaultValue" in fieldOrType && fieldOrType.defaultValue !== void 0) {
      definition.default = fieldOrType.defaultValue;
    }
    const { description } = definition;
    definition.description = renderDefinitionDescription(fieldOrType, false, description);
    if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
      definition.markdownDescription = renderDefinitionDescription(fieldOrType, true, description);
    }
    return { required, definition, definitions };
  }
  function getVariablesJSONSchema(variableToType, options) {
    var _a3;
    const jsonSchema = {
      $schema: "http://json-schema.org/draft-04/schema",
      type: "object",
      properties: {},
      required: [],
      additionalProperties: false
    };
    const runtimeOptions = Object.assign(Object.assign({}, options), { definitionMarker: new Marker(), scalarSchemas: Object.assign(Object.assign({}, defaultScalarTypesMap), options === null || options === void 0 ? void 0 : options.scalarSchemas) });
    if (variableToType) {
      for (const [variableName, type2] of Object.entries(variableToType)) {
        const { definition, required, definitions } = getJSONSchemaFromGraphQLType(type2, runtimeOptions);
        jsonSchema.properties[variableName] = definition;
        if (required) {
          (_a3 = jsonSchema.required) === null || _a3 === void 0 ? void 0 : _a3.push(variableName);
        }
        if (definitions) {
          jsonSchema.definitions = Object.assign(Object.assign({}, jsonSchema === null || jsonSchema === void 0 ? void 0 : jsonSchema.definitions), definitions);
        }
      }
    }
    return jsonSchema;
  }

  // node_modules/graphql-language-service/esm/utils/Range.js
  var Range3 = class {
    constructor(start, end) {
      this.containsPosition = (position) => {
        if (this.start.line === position.line) {
          return this.start.character <= position.character;
        }
        if (this.end.line === position.line) {
          return this.end.character >= position.character;
        }
        return this.start.line <= position.line && this.end.line >= position.line;
      };
      this.start = start;
      this.end = end;
    }
    setStart(line, character) {
      this.start = new Position3(line, character);
    }
    setEnd(line, character) {
      this.end = new Position3(line, character);
    }
  };
  var Position3 = class {
    constructor(line, character) {
      this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;
      this.line = line;
      this.character = character;
    }
    setLine(line) {
      this.line = line;
    }
    setCharacter(character) {
      this.character = character;
    }
  };

  // node_modules/graphql-language-service/esm/utils/validateWithCustomRules.js
  var specifiedSDLRules2 = [
    LoneSchemaDefinitionRule,
    UniqueOperationTypesRule,
    UniqueTypeNamesRule,
    UniqueEnumValueNamesRule,
    UniqueFieldDefinitionNamesRule,
    UniqueDirectiveNamesRule,
    KnownTypeNamesRule,
    KnownDirectivesRule,
    UniqueDirectivesPerLocationRule,
    PossibleTypeExtensionsRule,
    UniqueArgumentNamesRule,
    UniqueInputFieldNamesRule,
    UniqueVariableNamesRule,
    FragmentsOnCompositeTypesRule,
    ProvidedRequiredArgumentsRule
  ];
  function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {
    const rules = specifiedRules.filter((rule) => {
      if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {
        return false;
      }
      if (isRelayCompatMode && rule === KnownFragmentNamesRule) {
        return false;
      }
      return true;
    });
    if (customRules) {
      Array.prototype.push.apply(rules, customRules);
    }
    if (isSchemaDocument) {
      Array.prototype.push.apply(rules, specifiedSDLRules2);
    }
    const errors = validate(schema, ast, rules);
    return errors.filter((error) => {
      if (error.message.includes("Unknown directive") && error.nodes) {
        const node = error.nodes[0];
        if (node && node.kind === Kind.DIRECTIVE) {
          const name2 = node.name.value;
          if (name2 === "arguments" || name2 === "argumentDefinitions") {
            return false;
          }
        }
      }
      return true;
    });
  }

  // node_modules/graphql-language-service/esm/utils/collectVariables.js
  function collectVariables(schema, documentAST) {
    const variableToType = /* @__PURE__ */ Object.create(null);
    for (const definition of documentAST.definitions) {
      if (definition.kind === "OperationDefinition") {
        const { variableDefinitions } = definition;
        if (variableDefinitions) {
          for (const { variable, type: type2 } of variableDefinitions) {
            const inputType = typeFromAST(schema, type2);
            if (inputType) {
              variableToType[variable.name.value] = inputType;
            } else if (type2.kind === Kind.NAMED_TYPE && type2.name.value === "Float") {
              variableToType[variable.name.value] = GraphQLFloat;
            }
          }
        }
      }
    }
    return variableToType;
  }

  // node_modules/graphql-language-service/esm/utils/getOperationFacts.js
  function getOperationASTFacts(documentAST, schema) {
    const variableToType = schema ? collectVariables(schema, documentAST) : void 0;
    const operations = [];
    visit(documentAST, {
      OperationDefinition(node) {
        operations.push(node);
      }
    });
    return { variableToType, operations };
  }

  // node_modules/graphql-language-service/esm/interface/getDiagnostics.js
  var SEVERITY = {
    Error: "Error",
    Warning: "Warning",
    Information: "Information",
    Hint: "Hint"
  };
  var DIAGNOSTIC_SEVERITY = {
    [SEVERITY.Error]: 1,
    [SEVERITY.Warning]: 2,
    [SEVERITY.Information]: 3,
    [SEVERITY.Hint]: 4
  };
  var invariant2 = (condition, message) => {
    if (!condition) {
      throw new Error(message);
    }
  };
  function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {
    var _a3, _b2;
    let ast = null;
    let fragments = "";
    if (externalFragments) {
      fragments = typeof externalFragments === "string" ? externalFragments : externalFragments.reduce((acc, node) => acc + print(node) + "\n\n", "");
    }
    const enhancedQuery = fragments ? `${query}

${fragments}` : query;
    try {
      ast = parse(enhancedQuery);
    } catch (error) {
      if (error instanceof GraphQLError) {
        const range = getRange((_b2 = (_a3 = error.locations) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b2 !== void 0 ? _b2 : { line: 0, column: 0 }, enhancedQuery);
        return [
          {
            severity: DIAGNOSTIC_SEVERITY.Error,
            message: error.message,
            source: "GraphQL: Syntax",
            range
          }
        ];
      }
      throw error;
    }
    return validateQuery(ast, schema, customRules, isRelayCompatMode);
  }
  function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {
    if (!schema) {
      return [];
    }
    const validationErrorAnnotations = validateWithCustomRules(schema, ast, customRules, isRelayCompatMode).flatMap((error) => annotations(error, DIAGNOSTIC_SEVERITY.Error, "Validation"));
    const deprecationWarningAnnotations = validate(schema, ast, [
      NoDeprecatedCustomRule
    ]).flatMap((error) => annotations(error, DIAGNOSTIC_SEVERITY.Warning, "Deprecation"));
    return validationErrorAnnotations.concat(deprecationWarningAnnotations);
  }
  function annotations(error, severity, type2) {
    if (!error.nodes) {
      return [];
    }
    const highlightedNodes = [];
    for (const [i, node] of error.nodes.entries()) {
      const highlightNode = node.kind !== "Variable" && "name" in node && node.name !== void 0 ? node.name : "variable" in node && node.variable !== void 0 ? node.variable : node;
      if (highlightNode) {
        invariant2(error.locations, "GraphQL validation error requires locations.");
        const loc = error.locations[i];
        const highlightLoc = getLocation2(highlightNode);
        const end = loc.column + (highlightLoc.end - highlightLoc.start);
        highlightedNodes.push({
          source: `GraphQL: ${type2}`,
          message: error.message,
          severity,
          range: new Range3(new Position3(loc.line - 1, loc.column - 1), new Position3(loc.line - 1, end))
        });
      }
    }
    return highlightedNodes;
  }
  function getRange(location, queryText) {
    const parser = onlineParser();
    const state = parser.startState();
    const lines = queryText.split("\n");
    invariant2(lines.length >= location.line, "Query text must have more lines than where the error happened");
    let stream = null;
    for (let i = 0; i < location.line; i++) {
      stream = new CharacterStream(lines[i]);
      while (!stream.eol()) {
        const style = parser.token(stream, state);
        if (style === "invalidchar") {
          break;
        }
      }
    }
    invariant2(stream, "Expected Parser stream to be available.");
    const line = location.line - 1;
    const start = stream.getStartOfToken();
    const end = stream.getCurrentPosition();
    return new Range3(new Position3(line, start), new Position3(line, end));
  }
  function getLocation2(node) {
    const typeCastedNode = node;
    const location = typeCastedNode.loc;
    invariant2(location, "Expected ASTNode to have a location.");
    return location;
  }

  // node_modules/graphql-language-service/esm/interface/getHoverInformation.js
  function getHoverInformation(schema, queryText, cursor, contextToken, config) {
    const options = Object.assign(Object.assign({}, config), { schema });
    const context = getContextAtPosition(queryText, cursor, schema, contextToken);
    if (!context) {
      return "";
    }
    const { typeInfo, token } = context;
    const { kind, step } = token.state;
    if (kind === "Field" && step === 0 && typeInfo.fieldDef || kind === "AliasedField" && step === 2 && typeInfo.fieldDef || kind === "ObjectField" && step === 0 && typeInfo.fieldDef) {
      const into = [];
      renderMdCodeStart(into, options);
      renderField(into, typeInfo, options);
      renderMdCodeEnd(into, options);
      renderDescription(into, options, typeInfo.fieldDef);
      return into.join("").trim();
    }
    if (kind === "Directive" && step === 1 && typeInfo.directiveDef) {
      const into = [];
      renderMdCodeStart(into, options);
      renderDirective(into, typeInfo, options);
      renderMdCodeEnd(into, options);
      renderDescription(into, options, typeInfo.directiveDef);
      return into.join("").trim();
    }
    if (kind === "Variable" && typeInfo.type) {
      const into = [];
      renderMdCodeStart(into, options);
      renderType2(into, typeInfo, options, typeInfo.type);
      renderMdCodeEnd(into, options);
      renderDescription(into, options, typeInfo.type);
      return into.join("").trim();
    }
    if (kind === "Argument" && step === 0 && typeInfo.argDef) {
      const into = [];
      renderMdCodeStart(into, options);
      renderArg(into, typeInfo, options);
      renderMdCodeEnd(into, options);
      renderDescription(into, options, typeInfo.argDef);
      return into.join("").trim();
    }
    if (kind === "EnumValue" && typeInfo.enumValue && "description" in typeInfo.enumValue) {
      const into = [];
      renderMdCodeStart(into, options);
      renderEnumValue(into, typeInfo, options);
      renderMdCodeEnd(into, options);
      renderDescription(into, options, typeInfo.enumValue);
      return into.join("").trim();
    }
    if (kind === "NamedType" && typeInfo.type && "description" in typeInfo.type) {
      const into = [];
      renderMdCodeStart(into, options);
      renderType2(into, typeInfo, options, typeInfo.type);
      renderMdCodeEnd(into, options);
      renderDescription(into, options, typeInfo.type);
      return into.join("").trim();
    }
    return "";
  }
  function renderMdCodeStart(into, options) {
    if (options.useMarkdown) {
      text2(into, "```graphql\n");
    }
  }
  function renderMdCodeEnd(into, options) {
    if (options.useMarkdown) {
      text2(into, "\n```");
    }
  }
  function renderField(into, typeInfo, options) {
    renderQualifiedField(into, typeInfo, options);
    renderTypeAnnotation(into, typeInfo, options, typeInfo.type);
  }
  function renderQualifiedField(into, typeInfo, options) {
    if (!typeInfo.fieldDef) {
      return;
    }
    const fieldName = typeInfo.fieldDef.name;
    if (fieldName.slice(0, 2) !== "__") {
      renderType2(into, typeInfo, options, typeInfo.parentType);
      text2(into, ".");
    }
    text2(into, fieldName);
  }
  function renderDirective(into, typeInfo, _options) {
    if (!typeInfo.directiveDef) {
      return;
    }
    const name2 = "@" + typeInfo.directiveDef.name;
    text2(into, name2);
  }
  function renderArg(into, typeInfo, options) {
    if (typeInfo.directiveDef) {
      renderDirective(into, typeInfo, options);
    } else if (typeInfo.fieldDef) {
      renderQualifiedField(into, typeInfo, options);
    }
    if (!typeInfo.argDef) {
      return;
    }
    const { name: name2 } = typeInfo.argDef;
    text2(into, "(");
    text2(into, name2);
    renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);
    text2(into, ")");
  }
  function renderTypeAnnotation(into, typeInfo, options, t2) {
    text2(into, ": ");
    renderType2(into, typeInfo, options, t2);
  }
  function renderEnumValue(into, typeInfo, options) {
    if (!typeInfo.enumValue) {
      return;
    }
    const { name: name2 } = typeInfo.enumValue;
    renderType2(into, typeInfo, options, typeInfo.inputType);
    text2(into, ".");
    text2(into, name2);
  }
  function renderType2(into, typeInfo, options, t2) {
    if (!t2) {
      return;
    }
    if (t2 instanceof GraphQLNonNull) {
      renderType2(into, typeInfo, options, t2.ofType);
      text2(into, "!");
    } else if (t2 instanceof GraphQLList) {
      text2(into, "[");
      renderType2(into, typeInfo, options, t2.ofType);
      text2(into, "]");
    } else {
      text2(into, t2.name);
    }
  }
  function renderDescription(into, options, def) {
    if (!def) {
      return;
    }
    const description = typeof def.description === "string" ? def.description : null;
    if (description) {
      text2(into, "\n\n");
      text2(into, description);
    }
    renderDeprecation(into, options, def);
  }
  function renderDeprecation(into, _options, def) {
    if (!def) {
      return;
    }
    const reason = def.deprecationReason;
    if (!reason) {
      return;
    }
    text2(into, "\n\n");
    text2(into, "Deprecated: ");
    text2(into, reason);
  }
  function text2(into, content) {
    into.push(content);
  }

  // node_modules/monaco-graphql/esm/LanguageService.js
  var import_picomatch_browser = __toESM(require_picomatch_browser());

  // node_modules/monaco-graphql/esm/schemaLoader.js
  var defaultSchemaLoader = (schemaConfig, parser) => {
    const { schema, documentAST, introspectionJSON, introspectionJSONString, buildSchemaOptions, documentString } = schemaConfig;
    if (schema) {
      return schema;
    }
    if (introspectionJSONString) {
      const introspectionJSONResult = JSON.parse(introspectionJSONString);
      return buildClientSchema(introspectionJSONResult, buildSchemaOptions);
    }
    if (documentString && parser) {
      const docAST = parser(documentString);
      return buildASTSchema(docAST, buildSchemaOptions);
    }
    if (introspectionJSON) {
      return buildClientSchema(introspectionJSON, buildSchemaOptions);
    }
    if (documentAST) {
      return buildASTSchema(documentAST, buildSchemaOptions);
    }
    throw new Error("No schema supplied");
  };

  // node_modules/monaco-graphql/esm/LanguageService.js
  var schemaCache = /* @__PURE__ */ new Map();
  var LanguageService = class {
    _parser = parse;
    _schemas = [];
    _schemaCache = schemaCache;
    _schemaLoader = defaultSchemaLoader;
    _parseOptions;
    _customValidationRules;
    _externalFragmentDefinitionNodes = null;
    _externalFragmentDefinitionsString = null;
    _completionSettings;
    constructor({ parser, schemas, parseOptions, externalFragmentDefinitions, customValidationRules, fillLeafsOnComplete, completionSettings }) {
      this._schemaLoader = defaultSchemaLoader;
      if (schemas) {
        this._schemas = schemas;
        this._cacheSchemas();
      }
      if (parser) {
        this._parser = parser;
      }
      this._completionSettings = {
        ...completionSettings,
        fillLeafsOnComplete: completionSettings?.fillLeafsOnComplete ?? fillLeafsOnComplete
      };
      if (parseOptions) {
        this._parseOptions = parseOptions;
      }
      if (customValidationRules) {
        this._customValidationRules = customValidationRules;
      }
      if (externalFragmentDefinitions) {
        if (Array.isArray(externalFragmentDefinitions)) {
          this._externalFragmentDefinitionNodes = externalFragmentDefinitions;
        } else {
          this._externalFragmentDefinitionsString = externalFragmentDefinitions;
        }
      }
    }
    _cacheSchemas() {
      for (const schema of this._schemas) {
        this._cacheSchema(schema);
      }
    }
    _cacheSchema(schemaConfig) {
      const schema = this._schemaLoader(schemaConfig, this.parse.bind(this));
      return this._schemaCache.set(schemaConfig.uri, {
        ...schemaConfig,
        schema
      });
    }
    getSchemaForFile(uri) {
      if (!this._schemas.length) {
        return;
      }
      if (this._schemas.length === 1) {
        return this._schemaCache.get(this._schemas[0].uri);
      }
      const schema = this._schemas.find((schemaConfig) => {
        if (!schemaConfig.fileMatch) {
          return false;
        }
        return schemaConfig.fileMatch.some((glob) => {
          const isMatch = (0, import_picomatch_browser.default)(glob);
          return isMatch(uri);
        });
      });
      if (schema) {
        const cacheEntry = this._schemaCache.get(schema.uri);
        if (cacheEntry) {
          return cacheEntry;
        }
        const cache = this._cacheSchema(schema);
        return cache.get(schema.uri);
      }
    }
    getExternalFragmentDefinitions() {
      if (!this._externalFragmentDefinitionNodes && this._externalFragmentDefinitionsString) {
        const definitionNodes = [];
        try {
          visit(this._parser(this._externalFragmentDefinitionsString), {
            FragmentDefinition(node) {
              definitionNodes.push(node);
            }
          });
        } catch {
          throw new Error(`Failed parsing externalFragmentDefinitions string:
${this._externalFragmentDefinitionsString}`);
        }
        this._externalFragmentDefinitionNodes = definitionNodes;
      }
      return this._externalFragmentDefinitionNodes;
    }
    async updateSchemas(schemas) {
      this._schemas = schemas;
      this._cacheSchemas();
    }
    updateSchema(schema) {
      const schemaIndex = this._schemas.findIndex((c) => c.uri === schema.uri);
      if (schemaIndex < 0) {
        console.warn("updateSchema could not find a schema in your config by that URI", schema.uri);
        return;
      }
      this._schemas[schemaIndex] = schema;
      this._cacheSchema(schema);
    }
    addSchema(schema) {
      this._schemas.push(schema);
      this._cacheSchema(schema);
    }
    parse(text3, options) {
      return this._parser(text3, options || this._parseOptions);
    }
    getCompletion = (uri, documentText, position) => {
      const schema = this.getSchemaForFile(uri);
      if (!documentText || !schema?.schema) {
        return [];
      }
      return getAutocompleteSuggestions(schema.schema, documentText, position, void 0, this.getExternalFragmentDefinitions(), { uri, ...this._completionSettings });
    };
    getDiagnostics = (uri, documentText, customRules) => {
      const schema = this.getSchemaForFile(uri);
      if (!documentText || documentText.trim().length < 2 || !schema?.schema) {
        return [];
      }
      return getDiagnostics(documentText, schema.schema, customRules ?? this._customValidationRules, false, this.getExternalFragmentDefinitions());
    };
    getHover = (uri, documentText, position, options) => {
      const schema = this.getSchemaForFile(uri);
      if (schema && documentText.length > 3) {
        return getHoverInformation(schema.schema, documentText, position, void 0, {
          useMarkdown: true,
          ...options
        });
      }
    };
    getVariablesJSONSchema = (uri, documentText, options) => {
      const schema = this.getSchemaForFile(uri);
      if (schema && documentText.length > 3) {
        try {
          const documentAST = this.parse(documentText);
          const { variableToType } = getOperationASTFacts(documentAST, schema.schema);
          if (variableToType) {
            return getVariablesJSONSchema(variableToType, {
              ...options,
              scalarSchemas: schema.customScalarSchemas
            });
          }
        } catch {
        }
      }
      return null;
    };
  };

  // node_modules/monaco-graphql/esm/utils.js
  function toMonacoRange(range) {
    return {
      startLineNumber: range.start.line + 1,
      startColumn: range.start.character + 1,
      endLineNumber: range.end.line + 1,
      endColumn: range.end.character + 1
    };
  }
  function toGraphQLPosition(position) {
    return new Position3(position.lineNumber - 1, position.column - 1);
  }
  function toCompletion(entry, range) {
    return {
      label: entry.label,
      insertText: entry.insertText,
      sortText: entry.sortText,
      filterText: entry.filterText,
      ...entry.documentation && {
        documentation: {
          value: entry.documentation
        }
      },
      detail: entry.detail,
      ...range && { range: toMonacoRange(range) },
      kind: entry.kind,
      ...entry.insertTextFormat && { insertTextFormat: entry.insertTextFormat },
      ...entry.insertTextMode && { insertTextMode: entry.insertTextMode },
      ...entry.command && {
        command: { ...entry.command, id: entry.command.command }
      },
      ...entry.labelDetails && { labelDetails: entry.labelDetails }
    };
  }
  function toMonacoSeverity(severity) {
    const severityMap = {
      1: MarkerSeverity.Error,
      2: MarkerSeverity.Warning,
      3: MarkerSeverity.Info,
      4: MarkerSeverity.Hint
    };
    return severity ? severityMap[severity] : severityMap[2];
  }
  function toMarkerData(diagnostic) {
    return {
      startLineNumber: diagnostic.range.start.line + 1,
      endLineNumber: diagnostic.range.end.line + 1,
      startColumn: diagnostic.range.start.character + 1,
      endColumn: diagnostic.range.end.character,
      message: diagnostic.message,
      severity: toMonacoSeverity(diagnostic.severity),
      code: diagnostic.code || void 0
    };
  }

  // node_modules/monaco-graphql/esm/GraphQLWorker.js
  var GraphQLWorker = class {
    _ctx;
    _languageService;
    _formattingOptions;
    constructor(ctx, createData) {
      this._ctx = ctx;
      this._languageService = new LanguageService(createData.languageConfig);
      this._formattingOptions = createData.formattingOptions;
    }
    async doValidation(uri) {
      try {
        const documentModel = this._getTextModel(uri);
        const document2 = documentModel?.getValue();
        if (!document2) {
          return [];
        }
        const graphqlDiagnostics = this._languageService.getDiagnostics(uri, document2);
        return graphqlDiagnostics.map(toMarkerData);
      } catch (err) {
        console.error(err);
        return [];
      }
    }
    async doComplete(uri, position) {
      try {
        const documentModel = this._getTextModel(uri);
        const document2 = documentModel?.getValue();
        if (!document2) {
          return [];
        }
        const graphQLPosition = toGraphQLPosition(position);
        const suggestions = this._languageService.getCompletion(uri, document2, graphQLPosition);
        return suggestions.map((suggestion) => toCompletion(suggestion));
      } catch (err) {
        console.error(err);
        return [];
      }
    }
    async doHover(uri, position) {
      try {
        const documentModel = this._getTextModel(uri);
        const document2 = documentModel?.getValue();
        if (!document2) {
          return null;
        }
        const graphQLPosition = toGraphQLPosition(position);
        const hover = this._languageService.getHover(uri, document2, graphQLPosition);
        const location = {
          column: graphQLPosition.character,
          line: graphQLPosition.line
        };
        return {
          content: hover,
          range: toMonacoRange(getRange(location, document2))
        };
      } catch (err) {
        console.error(err);
        return null;
      }
    }
    async doGetVariablesJSONSchema(uri) {
      const documentModel = this._getTextModel(uri);
      const document2 = documentModel?.getValue();
      if (!documentModel || !document2) {
        return null;
      }
      const jsonSchema = this._languageService.getVariablesJSONSchema(uri, document2, { useMarkdownDescription: true });
      if (jsonSchema) {
        return {
          ...jsonSchema,
          $id: "monaco://variables-schema.json",
          title: "GraphQL Variables"
        };
      }
      return null;
    }
    async doFormat(uri) {
      const documentModel = this._getTextModel(uri);
      const document2 = documentModel?.getValue();
      if (!documentModel || !document2) {
        return null;
      }
      const prettierStandalone = await Promise.resolve().then(() => (init_standalone(), standalone_exports));
      const prettierGraphqlParser = await Promise.resolve().then(() => __toESM(require_graphql()));
      return prettierStandalone.format(document2, {
        parser: "graphql",
        plugins: [prettierGraphqlParser],
        ...this._formattingOptions?.prettierConfig
      });
    }
    _getTextModel(uri) {
      const models = this._ctx.getMirrorModels();
      for (const model of models) {
        if (model.uri.toString() === uri) {
          return model;
        }
      }
      return null;
    }
    doUpdateSchema(schema) {
      return this._languageService.updateSchema(schema);
    }
    doUpdateSchemas(schemas) {
      return this._languageService.updateSchemas(schemas);
    }
  };

  // node_modules/monaco-graphql/esm/graphql.worker.js
  globalThis.onmessage = () => {
    initialize((ctx, createData) => new GraphQLWorker(ctx, createData));
  };
})();
